---
title: Java多线程-synchronized与锁
date: 2020-04-22 15:47:46
categories: Java多线程
tags:
  - Java
  - 多线程
---

## synchronized关键字

`synchronized`翻译成中文就是同步的意思。我们通常使用`synchronized`关键字来给一段代码或一个方法上锁。其主要有以下三种方式

```java
   //关键字在实例方法上，锁为当前实例
    public synchronized void instanceLock(){
        //code
    }
	//关键字在静态方法上，锁为当前Class对象
    public static synchronized void classLock(){
        //code
    }
	//关键字在代码块上，锁为括号里面对象
    public void blockLock(){
        Object o = new Object();
        synchronized (o){
            //code
        }
    }
```

>**java中的锁都是对象锁，我们常说的类锁也是对象锁。Java类只要一个Class对象，多个实例对象共享这一个Class对象。类锁就是Class对象的锁。**

<!--more-->

Java中临界区指的是某一代码区域同一时刻只能由一个线程执行。`synchronized`关键字如果加在方法上，那么整个方法都是临界区；如果加载代码块上，临界区就是代码块内部区域。



## 偏向锁、轻量级锁与重量级锁

Java6为了减少获得和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。Java6以前，所有的锁都是重量级锁。

一个对象有4种锁状态，从低到高分别为：

1. 无锁
2. 偏向锁
3. 轻量级锁
4. 重量级锁

无锁就是没有对资源进行锁定，任何线程都可以去执行。

几种锁会随着竞争情况逐级升级，锁的升级很容易发生，但降级条件很苛刻。

#### Java对象头

每个Java对象都有对象头，如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽存储对象头。32位机器中，一个字宽是32位；64位虚拟机中，一个字宽是64位。对象头的内容如下表：

|   长度   |          内容          |             说明             |
| :------: | :--------------------: | :--------------------------: |
| 32/64bit |       Mark Word        | 存储对象的hashCode或锁信息等 |
| 32/64bit | Class Metadata Address |   存储到对象类型数据的指针   |
| 32/64bit |      Array length      |    数组的长度(如果是数组)    |

其中，`Mark Word`的格式如下：

|  锁状态  |         29或61bit          |      1bit是否是偏向锁      | 2bit锁标志位 |
| :------: | :------------------------: | :------------------------: | :----------: |
|   无锁   |                            |             0              |      01      |
|  偏向锁  |           线程ID           |             1              |      01      |
| 轻量级锁 |    指向栈中锁记录的指针    | 此时这一位不用于标识偏向锁 |      00      |
| 重量级锁 | 指向互斥量(重量级锁)的指针 | 此时这一位不用于标识偏向锁 |      10      |
|  GC标志  |                            | 此时这一位不用于标识偏向锁 |      11      |

当对象状态为偏向锁时，`Mark Word`中记录的是线程ID；当状态是轻量级锁时，`Mark Word`中存储的是指向线程栈中`Lock Record`的指针；当状态是重量级锁时，`Mark Word`为指向堆中的monitor对象的指针。

#### 偏向锁

大多数情况下，锁不仅不存在多线程竞争，还总是由同一线程多次获得，于是引入了偏向锁。

偏向锁会偏向于第一个获得锁的线程，如果在接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程永远不会触发同步。也就是，**偏向锁在资源无竞争条件下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。**

>CAS: Compare And Swap
>
>比较并设置。

##### 实现原理

一个线程在第一次进入同步块时，会在对象头和栈帧的锁记录中存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的`Mark Word`中是否存在自己的线程ID。

如果是，代表当前线程已获得锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁。

如果不是，代表有另一个线程来竞争这个偏向锁。这时会尝试用CAS操作来替换`Mark Word`中的线程ID为新线程的ID，有两种结果：

- 如果成功，代表之前的线程不存在了，`Mark Word`中为新线程的ID，锁不会升级，仍然为偏向锁。
- 如果失败，表示之前的线程依然存在。暂停之前的线程，设置锁标识为0，并设置锁标识位为00，升级为轻量级锁，按照轻量级锁的方式竞争锁。

线程竞争偏向锁的过程如下：

![线程竞争偏向锁的过程.JPG](https://f1bu920.github.io/images/线程竞争偏向锁的过程.JPG)

图中涉及到了`lock record`指针指向当前堆栈中最近的一个`lock record`，是轻量级锁按照先来先服务的模式进行轻量级锁的加锁。

##### 撤销偏向锁

