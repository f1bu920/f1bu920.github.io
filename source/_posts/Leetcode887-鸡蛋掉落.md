---
title: Leetcode887.鸡蛋掉落
date: 2020-04-11 11:37:45
categories: Leetcode
tags:
  - 动态规划
  - 二分搜索
---

## Leetcode887.鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

 [题目链接](https://leetcode-cn.com/problems/super-egg-drop)

<!--more-->

示例 1：

>输入：K = 1, N = 2
>输出：2
>解释：
>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
>如果它没碎，那么我们肯定知道 F = 2 。
>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

示例 2：

>输入：K = 2, N = 6
>输出：3
>示例 3：
>
>输入：K = 3, N = 14
>输出：4


提示：

>1 <= K <= 100
>1 <= N <= 10000



#### 思路

[参考链接](https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/)

题意解释：

- 题目中“移动”的意思是：把一个鸡蛋从某个楼层扔下去，看它是否破碎。没破的鸡蛋可以重复使用。
- 这 K 个鸡蛋，F 值满足的特点是：
  在所有小于等于 F 的楼层扔下它不破碎；
  在所有大于 F 的楼层扔下它一定会破碎；
  所有鸡蛋的 F 值都一样，且确定的，并且 0 <= F <= N，即 F 值一定不会超过楼层高度。
- F值是确定的，但它不是题目要我们求的。题目要我们求的是找到这个 F 值的最小实验次数。这其实是时间复杂度的概念，时间复杂度是在最坏情况下（即运气最差的情况下），程序执行完毕最少执行的次数，例如：
  - 在一个数组（长度为 NN）里查找一个数，找到某个数可以用线性查找，最好情况下，下标为 0 的位置就是要找的元素，但是在计算复杂度的时候，需要考虑到最差情况，即看到最后一个位置的时候，才找到这个元素，因此至少执行数组长度这么多次的查找，才能找到；
  - 在一个有序数组（长度为 NN）里查找，可以使用二分查找算法，最好情况下依然是 1 次就找到（中点位置），但是最坏情况下，例如中点的两个邻居，就得找 \log NlogN（这个数值需要上取整，这里不深究）次；
- 题目中的「最小」字眼很让人迷惑，我的理解是：把求解 F 的过程认为是用最好的算法，即使是在最坏的运气下，为了准确得到结果，找到 F 这个值的实验的次数最少是多少。



解法：

- 动态规划

  令`dp[i][j]`代表`i`层使用`j`个鸡蛋的最少试验次数，**注意这里`i`不是楼层高度，而是层数**。`j`表示可以使用鸡蛋的个数，是约束条件。

  设指定的楼层为`k`，`k>=1`且`k<=i`.

  - 如果鸡蛋破碎，所以`F`在`k`层以下(不包括`k`层)，因为这里已经使用了一个鸡蛋，所以最少试验次数为`dp[k-1][j-1]`
  - 如果鸡蛋完好，则`F`在`k`层以上，这个鸡蛋还能使用，所以最少试验次数为`dp[k+1][j]`。

  最坏的情况是这两个子问题的较大者，`k`的取值范围为`[1,i]`，对于每个`k`都对应着一个最大值，所以
  $$
  dp[i][j]= 
  1≤k≤i
  min
  	
   (max(dp[k−1][j−1],dp[i−k][j]+1))
  $$
  初始化：

  这里需要`0`这个状态的值，它的值会被后来的值参考到，所以表格需要`N+1`行`K+1`列。

  - 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 `F` 值，故全为 0； 
  - 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次； 
  - 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 `F` 值，故全为 0，虽然不符合题意，但是这个值有效，它在后面的计算中会被用到； 
  - 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 `F` 值，最少次数就等于楼层高度； 

  单纯的动态规划时间复杂度为O(~NK^2~)，超出时间限制。

- 二分搜索+动态规划

  `dp[k - 1][j - 1]`：根据语义，`k` 增大的时候，楼层大小越大，它的值就越大，是单调递增的函数；

  `dp[i - k][j]`：根据语义，`k` 增大的时候，楼层大小越小，它的值就越小，是单调递减的函数。

  当找到他们交汇的时候，二者较大值的最小者一定出现在那里。

  也就是找到使得 `dp[i - k][j] <= dp[k - i][j - 1] `最大的那个 `k `值即可。这里使用二分查找算法。关键在于 `dp[i - k][j] > dp[k - i][j - 1] `的时候，`k` 一定不是我们要找的，根据这一点写出二分的代码。

  
#### 代码实现

- 动态规划

  ```java
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp = new int[N + 1][K + 1];
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], i);
        }
        //第0行
        for (int i = 0; i <= K; i++) {
            dp[0][i] = 0;
        }
        //第1行
        for (int i = 1; i <= K; i++) {
            dp[1][i] = 1;
        }
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
            dp[i][1] = i;
        }
        for (int i = 2; i <= N; i++) {
            for (int j = 2; j <= K; j++) {
                for (int k = 1; k <= i; k++) {
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
                }
            }
        }
        return dp[N][K];
    }
}
  ```



- 二分搜索+动态规划

  ```java
  class Solution {
      public int superEggDrop(int K, int N) {
          int[][] dp = new int[N + 1][K + 1];
          for (int i = 0; i <= N; i++) {
              Arrays.fill(dp[i], i);
          }
          //第0行
          for (int i = 0; i <= K; i++) {
              dp[0][i] = 0;
          }
          //第1行
          for (int i = 1; i <= K; i++) {
              dp[1][i] = 1;
          }
          for (int i = 0; i <= N; i++) {
              dp[i][0] = 0;
              dp[i][1] = i;
          }
          for (int i = 2; i <= N; i++) {
              for (int j = 2; j <= K; j++) {
                  int left = 1;
                  int right = i;
                  while (left < right) {
                      int mid = left + (right - left + 1) / 2;
                      int t1 = dp[mid - 1][j - 1];
                      int t2 = dp[i - mid][j];
                      if (t1 > t2) {
                          right = mid - 1;
                      } else {
                          left = mid;
                      }
                  }
                  dp[i][j] = Math.max(dp[left - 1][j - 1], dp[i - left][j]) + 1;
              }
          }
          return dp[N][K];
      }
  }
  ```

  