<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flbu blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-24T07:21:31.821Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flbu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode面试题17.16按摩师</title>
    <link href="http://yoursite.com/2020/03/24/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9817-16%E6%8C%89%E6%91%A9%E5%B8%88/"/>
    <id>http://yoursite.com/2020/03/24/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9817-16%E6%8C%89%E6%91%A9%E5%B8%88/</id>
    <published>2020-03-24T07:08:59.000Z</published>
    <updated>2020-03-24T07:21:31.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题17-16按摩师"><a href="#Leetcode面试题17-16按摩师" class="headerlink" title="Leetcode面试题17.16按摩师"></a>Leetcode面试题17.16按摩师</h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><p>注意：本题相对原题稍作改动</p><p> <a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入： [1,2,3,1]</p><p>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p></blockquote><p>示例 2：</p><blockquote><p>输入： [2,7,9,3,1]</p><p>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</p></blockquote><p>示例 3：</p><blockquote><p>输入： [2,1,4,5,3,1,1,3]</p><p>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此类动态规划题都可先找出所有情况的转移状态。此题中令<code>dp[i][0]</code>表示前<code>i</code>个预约，第<code>i</code>个预约不接的最长时间；令<code>dp[i][1]</code>表示前<code>i</code>个预约，第<code>i</code>个预约接的最长时间。</p><p>因为不能接受相邻的预约，所以可以得出状态转移方程如下：</p><ol><li><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1])</code></li><li><code>dp[i][1]=nums[i]+dp[i-1][0]</code></li></ol><p>最终，<code>dp[nums.length-1][1]</code>或者<code>dp[nums.length-1][0]</code>中的最大者就是最长时间。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = nums[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[nums.length - <span class="number">1</span>][<span class="number">0</span>], dp[nums.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题17-16按摩师&quot;&gt;&lt;a href=&quot;#Leetcode面试题17-16按摩师&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题17.16按摩师&quot;&gt;&lt;/a&gt;Leetcode面试题17.16按摩师&lt;/h2&gt;&lt;p&gt;一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。&lt;/p&gt;
&lt;p&gt;注意：本题相对原题稍作改动&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/the-masseuse-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.07.链表相交</title>
    <link href="http://yoursite.com/2020/03/23/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
    <id>http://yoursite.com/2020/03/23/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</id>
    <published>2020-03-23T04:12:47.000Z</published>
    <updated>2020-03-23T04:25:16.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-07-链表相交"><a href="#Leetcode面试题02-07-链表相交" class="headerlink" title="Leetcode面试题02.07.链表相交"></a>Leetcode面试题02.07.链表相交</h2><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p><p> <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">2</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">2</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">null</span></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 <span class="built_in">int</span>ersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 <span class="literal">null</span>。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code> 。</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><h4 id="思路及代码实现"><a href="#思路及代码实现" class="headerlink" title="思路及代码实现"></a>思路及代码实现</h4><ul><li><p>暴力法</p><p>对于每个<code>headA</code>中的节点，都在<code>headB</code>中遍历。不符合O(n)的时间复杂度。</p></li><li><p>集合法</p><p>将<code>headA</code>中所有结点放入<code>HashSet</code>中，再遍历<code>headB</code>中结点，看<code>set</code>中是否包含正在遍历的结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode pa = headA;</span><br><span class="line">        <span class="keyword">while</span> (pa != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.add(pa);</span><br><span class="line">            pa = pa.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pb = headB;</span><br><span class="line">        <span class="keyword">while</span> (pb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(pb)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pb;</span><br><span class="line">            &#125;</span><br><span class="line">            pb = pb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双指针法</p><p>利用双指针法消除长度差，令<code>pa</code>、<code>pb</code>分别指向<code>headA</code>、<code>headB</code>，若<code>pa</code>、<code>pb</code>任一为空，则指向另一链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode pa = headA;</span><br><span class="line">    ListNode pb = headB;</span><br><span class="line">    <span class="keyword">while</span> (pa != pb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pa = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pb = pb.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pb = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-07-链表相交&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-07-链表相交&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.07.链表相交&quot;&gt;&lt;/a&gt;Leetcode面试题02.07.链表相交&lt;/h2&gt;&lt;p&gt;给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode876.链表的中间结点</title>
    <link href="http://yoursite.com/2020/03/23/Leetcode876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/23/Leetcode876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</id>
    <published>2020-03-23T03:30:52.000Z</published>
    <updated>2020-03-23T03:38:44.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode876-链表的中间结点"><a href="#Leetcode876-链表的中间结点" class="headerlink" title="Leetcode876.链表的中间结点"></a>Leetcode876.链表的中间结点</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p> <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">3</span> (序列化形式：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">返回的结点值为 <span class="number">3</span> 。 (测评系统对该结点序列化表述是 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = <span class="number">3</span>, ans.next.val = <span class="number">4</span>, ans.next.next.val = <span class="number">5</span>, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br></pre></td></tr></table></figure><ul><li><p>思路</p><p>使用快慢指针，初始时快慢指针皆指向虚拟头结点，慢指针一次走一步，快指针一次走两步，当快指针走到链表尾时，慢指针正好走到中间结点或两个中间结点的前者。</p><p>最后，如果链表元素个数为偶数个时，中间结点有两个，题目要求指向后一个，所以需要加上判断：若快指针不为空时，此时为偶数个元素的链表，慢指针移动一位即可。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        slow.next = head;</span><br><span class="line">        ListNode fast = slow;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode876-链表的中间结点&quot;&gt;&lt;a href=&quot;#Leetcode876-链表的中间结点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode876.链表的中间结点&quot;&gt;&lt;/a&gt;Leetcode876.链表的中间结点&lt;/h2&gt;&lt;p&gt;给定一个带有头结点 &lt;code&gt;head&lt;/code&gt; 的非空单链表，返回链表的中间结点。&lt;/p&gt;
&lt;p&gt;如果有两个中间结点，则返回第二个中间结点。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.05.链表求和</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-05-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-05-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</id>
    <published>2020-03-22T09:43:59.000Z</published>
    <updated>2020-03-22T09:55:24.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-05-链表求和"><a href="#Leetcode面试题02-05-链表求和" class="headerlink" title="Leetcode面试题02.05.链表求和"></a>Leetcode面试题02.05.链表求和</h2><p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><p> <a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">7</span> -&gt; <span class="number">1</span> -&gt; <span class="number">6</span>) + (<span class="number">5</span> -&gt; <span class="number">9</span> -&gt; <span class="number">2</span>)，即<span class="number">617</span> + <span class="number">295</span></span><br><span class="line">输出：<span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span>，即<span class="number">912</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong>假设这些数位是正向存放的，请再做一遍。</p><p><strong>示例：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(<span class="number">6</span> -&gt; <span class="number">1</span> -&gt; <span class="number">7</span>) + (<span class="number">2</span> -&gt; <span class="number">9</span> -&gt; <span class="number">5</span>)，即<span class="number">617</span> + <span class="number">295</span></span><br><span class="line">输出：<span class="number">9</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span>，即<span class="number">912</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>将链表转化为整数，但会超出<code>int</code>类型范围，发生溢出。</li><li>因为两个链表中数位是反向存放的，可利用队列进行缓存。链表中先读的元素是低位，要先运算即先出，符合先进先出的特点，所以使用队列。</li><li>维护两个变量<code>num</code>和<code>carray</code>，分别表示当前的和与进位，若<code>num&gt;=10</code>，则进1位。</li><li>使用尾插法构造节点</li><li>判断最后是否还有进位，若有则构造一个<code>val=1</code>的节点。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       Queue&lt;ListNode&gt; queue1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       Queue&lt;ListNode&gt; queue2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       head.next = <span class="keyword">null</span>;</span><br><span class="line">       ListNode cur = head;</span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">           queue1.add(l1);</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">           queue2.add(l2);</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!queue1.isEmpty() || !queue2.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> num = carry;</span><br><span class="line">           <span class="keyword">if</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">               num += queue1.poll().val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!queue2.isEmpty()) &#123;</span><br><span class="line">               num += queue2.poll().val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">               carry = <span class="number">1</span>;</span><br><span class="line">               num %= <span class="number">10</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               carry = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode temp = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">           cur.next = temp;</span><br><span class="line">           cur = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">           ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">           cur.next = temp;</span><br><span class="line">           cur = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-05-链表求和&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-05-链表求和&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.05.链表求和&quot;&gt;&lt;/a&gt;Leetcode面试题02.05.链表求和&lt;/h2&gt;&lt;p&gt;给定两个用链表表示的整数，每个节点包含一个数位。&lt;/p&gt;
&lt;p&gt;这些数位是反向存放的，也就是个位排在链表首部。&lt;/p&gt;
&lt;p&gt;编写函数对这两个整数求和，并用链表形式返回结果。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/sum-lists-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode82.删除排序链表中的重复元素II</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</id>
    <published>2020-03-22T07:38:37.000Z</published>
    <updated>2020-03-22T07:49:29.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode82-删除排序链表中的重复元素II"><a href="#Leetcode82-删除排序链表中的重复元素II" class="headerlink" title="Leetcode82.删除排序链表中的重复元素II"></a>Leetcode82.删除排序链表中的重复元素II</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="comment">//temp为局部重复的第一个元素</span></span><br><span class="line">                ListNode temp = cur.next;</span><br><span class="line">                <span class="comment">//通过while循环找到局部重复的最后一个元素</span></span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span> &amp;&amp; temp.val == temp.next.val) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = temp.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode82-删除排序链表中的重复元素II&quot;&gt;&lt;a href=&quot;#Leetcode82-删除排序链表中的重复元素II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode82.删除排序链表中的重复元素II&quot;&gt;&lt;/a&gt;Leetcode82.删除排序链表中的重复元素II&lt;/h2&gt;&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 &lt;em&gt;没有重复出现&lt;/em&gt; 的数字。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode83.删除排序链表中的重复元素</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2020-03-22T05:57:36.000Z</published>
    <updated>2020-03-22T07:48:55.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode83-删除排序链表中的重复元素"><a href="#Leetcode83-删除排序链表中的重复元素" class="headerlink" title="Leetcode83.删除排序链表中的重复元素"></a>Leetcode83.删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode83-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#Leetcode83-删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;Leetcode83.删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;Leetcode83.删除排序链表中的重复元素&lt;/h2&gt;&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode945.使数组唯一的最小增量</title>
    <link href="http://yoursite.com/2020/03/22/Leetcode945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
    <id>http://yoursite.com/2020/03/22/Leetcode945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</id>
    <published>2020-03-22T02:43:07.000Z</published>
    <updated>2020-03-22T03:16:02.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode945-使数组唯一的最小增量"><a href="#Leetcode945-使数组唯一的最小增量" class="headerlink" title="Leetcode945.使数组唯一的最小增量"></a>Leetcode945.使数组唯一的最小增量</h2><p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p><p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p><p><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：经过一次 move 操作，数组将变为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：经过 <span class="number">6</span> 次 move 操作，数组将变为 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>]。</span><br><span class="line">可以看出 <span class="number">5</span> 次或 <span class="number">5</span> 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 40000</code></li><li><code>0 &lt;= A[i] &lt; 40000</code></li></ol><ul><li><p>思路及代码实现</p><ol><li><p>使用集合<code>HashSet</code>存储，若重复出现，则暴力+1。（超出时间限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(A[i])) &#123;</span><br><span class="line">                set.add(A[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[i]++;</span><br><span class="line">                i--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计数法</p><p>由题意<code>0&lt;=A[i]&lt;=40000</code>，所以开辟空间大小为80000的数组<code>count</code>，(为了防止A中为40000个40000的特殊情况)，<code>count</code>记录A中每个数字出现次数，其下标为A中元素。维护两个变量，<code>res</code>代表增加次数，<code>token</code>记录重复数字出现次数。若<code>count[x]&gt;=2</code>，即A中<code>x</code>元素出现两次以上，<code>token</code>加上<code>count[x]-1</code>，<code>res</code>减去<code>x*(count[x]-1)</code>，否则如果还有重复元素即<code>token&gt;0</code>，则在没有元素处加上即<code>res+=x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">        count[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, token = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">8000</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[x] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            token += count[x] - <span class="number">1</span>;</span><br><span class="line">            res -= x * (count[x] - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[x] == <span class="number">0</span> &amp;&amp; token &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += x;</span><br><span class="line">                token--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li><li><p>排序</p><p>先将数组排序。然后对数组进行扫描。</p><ul><li>如果<code>A[i-1]==A[i]</code>，将操作次数减去<code>A[i-1]</code>，并且重复数字+1；</li><li>如果<code>A[i-1]&lt;A[i]</code>，那么两者之间有<code>A[i]-A[i-1]-1</code>个数，我们有<code>token</code>个重复的数可以变成这之间的数。所以我们最多可以改变<code>give = Math.min(token,A[i]-A[i-1]-1)</code>个数。这<code>give</code>个数对结果的影响为<code>A[i-1]*give+(give+1)*give/2</code>。</li><li>最后遍历完成后，如果还有重复的数，例如<code>[2,2,3]</code>，上步<code>give</code>始终为0，就需要把这些数变成<code>A[A.length-1]</code>后面区间上的数了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, token = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                token++;</span><br><span class="line">                res -= A[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> give = Math.min(token, A[i] - A[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">                token -= give;</span><br><span class="line">                res += give * A[i - <span class="number">1</span>] + (give + <span class="number">1</span>) * give / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += token * A[A.length - <span class="number">1</span>] + (token + <span class="number">1</span>) * token / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode945-使数组唯一的最小增量&quot;&gt;&lt;a href=&quot;#Leetcode945-使数组唯一的最小增量&quot; class=&quot;headerlink&quot; title=&quot;Leetcode945.使数组唯一的最小增量&quot;&gt;&lt;/a&gt;Leetcode945.使数组唯一的最小增量&lt;/h2&gt;&lt;p&gt;给定整数数组 A，每次 &lt;em&gt;move&lt;/em&gt; 操作将会选择任意 &lt;code&gt;A[i]&lt;/code&gt;，并将其递增 &lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回使 &lt;code&gt;A&lt;/code&gt; 中的每个值都是唯一的最少操作次数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode365.水壶问题</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-21T06:59:30.000Z</published>
    <updated>2020-03-21T07:13:02.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode365-水壶问题"><a href="#Leetcode365-水壶问题" class="headerlink" title="Leetcode365.水壶问题"></a>Leetcode365.水壶问题</h2><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener">*”Die Hard”* example</a>)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">3</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">5</span><span class="string">,</span> <span class="string">z</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">2</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">6</span><span class="string">,</span> <span class="string">z</span> <span class="string">=</span> <span class="number">5</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以定义一个内部类<code>Pair</code>，<code>Pair</code>中的两个变量<code>x、y</code>分别表示当前两个水壶的水<code>curX、curY</code>。创建一个队列<code>queue</code>，来存储所有的状态，创建一个哈希集合<code>visited</code>来避免保存遍历过的状态。</p><p>题目说：</p><blockquote><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul></blockquote><p>所以一共有以下几种情况</p><p>装满任意一个水壶，定义为「情况一」，分为：<br>（1）装满 <code>A</code>；<br>（2）装满 <code>B</code>。</p><p>清空任意一个水壶，定义为「情况二」，分为<br>（1）清空 <code>A</code>；<br>（2）清空 <code>B</code>。</p><p>从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「情况三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：</p><p>（1）从 <code>A</code> 到 <code>B</code>，使得 <code>B</code> 满，<code>A</code> 还有剩；<br>（2）从 <code>A</code> 到 <code>B</code>，此时 <code>A</code> 的水太少，<code>A</code> 倒尽，<code>B</code> 没有满；<br>（3）从 <code>B</code> 到 <code>A</code>，使得 <code>A</code> 满，<code>B</code> 还有剩余；<br>（4）从 <code>B</code> 到 <code>A</code>，此时 <code>B</code> 的水太少，<code>B</code> 倒尽，<code>A</code> 没有满。</p><p>因此，从当前「状态」最多可以进行 8 种操作，得到 8 个新「状态」，对这 8 个新「状态」，依然可以扩展，一直做下去，直到某一个状态满足题目要求。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Pair&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Pair&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Pair pair = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        queue.add(pair);</span><br><span class="line">        visited.add(pair);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair head = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curX = head.getX();</span><br><span class="line">            <span class="keyword">int</span> curY = head.getY();</span><br><span class="line">            <span class="keyword">if</span> (curX == z || curY == z || curX + curY == z) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Pair&gt; nextPairs = getNextPairs(curX, curY, x, y);</span><br><span class="line"><span class="comment">//            System.out.println(head+"-&gt;" +nextPairs);</span></span><br><span class="line">            <span class="keyword">for</span> (Pair p : nextPairs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(p)) &#123;</span><br><span class="line">                    visited.add(p);</span><br><span class="line">                    queue.add(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(queue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">getNextPairs</span><span class="params">(<span class="keyword">int</span> curX, <span class="keyword">int</span> curY, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        List&lt;Pair&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//装满A</span></span><br><span class="line">        Pair pair1 = <span class="keyword">new</span> Pair(x, curY);</span><br><span class="line">        <span class="comment">//装满B</span></span><br><span class="line">        Pair pair2 = <span class="keyword">new</span> Pair(curX, y);</span><br><span class="line">        <span class="comment">//A没满时装满</span></span><br><span class="line">        <span class="keyword">if</span> (curX &lt; x) &#123;</span><br><span class="line">            list.add(pair1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B没满时装满</span></span><br><span class="line">        <span class="keyword">if</span> (curY &lt; y) &#123;</span><br><span class="line">            list.add(pair2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        Pair pair3 = <span class="keyword">new</span> Pair(<span class="number">0</span>, curY);</span><br><span class="line">        Pair pair4 = <span class="keyword">new</span> Pair(curX, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//有水时清空</span></span><br><span class="line">        <span class="keyword">if</span> (curX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A-&gt;B,B fill,A left</span></span><br><span class="line">        Pair pair5 = <span class="keyword">new</span> Pair(curX - (y - curY), y);</span><br><span class="line">        <span class="comment">//A-&gt;B,B not fill,A empty</span></span><br><span class="line">        Pair pair6 = <span class="keyword">new</span> Pair(<span class="number">0</span>, curY + curX);</span><br><span class="line">        <span class="comment">//B-&gt;A,A fill,B left</span></span><br><span class="line">        Pair pair7 = <span class="keyword">new</span> Pair(x, curY - (x - curX));</span><br><span class="line">        <span class="comment">//B-&gt;A,A not fill,B empty</span></span><br><span class="line">        Pair pair8 = <span class="keyword">new</span> Pair(curX + curY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//有剩余</span></span><br><span class="line">        <span class="keyword">if</span> (curX - (y - curY) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY - (x - curX) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair7);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//装不满</span></span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; x) &#123;</span><br><span class="line">            list.add(pair8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; y) &#123;</span><br><span class="line">            list.add(pair6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Pair&#123;"</span> +</span><br><span class="line">                    <span class="string">"x="</span> + x +</span><br><span class="line">                    <span class="string">", y="</span> + y +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Pair)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Pair pair = (Pair) o;</span><br><span class="line">            <span class="keyword">return</span> getX() == pair.getX() &amp;&amp;</span><br><span class="line">                    getY() == pair.getY();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(getX(), getY());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode365-水壶问题&quot;&gt;&lt;a href=&quot;#Leetcode365-水壶问题&quot; class=&quot;headerlink&quot; title=&quot;Leetcode365.水壶问题&quot;&gt;&lt;/a&gt;Leetcode365.水壶问题&lt;/h2&gt;&lt;p&gt;有两个容量分别为 &lt;em&gt;x&lt;/em&gt;升 和 &lt;em&gt;y&lt;/em&gt;升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;em&gt;z&lt;/em&gt;升 的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 &lt;em&gt;z升&lt;/em&gt; 水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.06.回文链表</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-21T04:59:25.000Z</published>
    <updated>2020-03-21T05:12:07.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-06-回文链表"><a href="#Leetcode面试题02-06-回文链表" class="headerlink" title="Leetcode面试题02.06.回文链表"></a>Leetcode面试题02.06.回文链表</h2><p>编写一个函数，检查输入的链表是否是回文的。</p><p> <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出： <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出： <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><ul><li><p>思路</p><p>使用快慢指针找到链表的中间节点，将后半部分链表反转，再逐个比较，因为回文链表必定以中间节点为中心对称。此时时间复杂度为O(n)，空间复杂度为O(1)。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转后半部分链表  </span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.val != head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-06-回文链表&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-06-回文链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.06.回文链表&quot;&gt;&lt;/a&gt;Leetcode面试题02.06.回文链表&lt;/h2&gt;&lt;p&gt;编写一个函数，检查输入的链表是否是回文的。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.01.移除重复节点</title>
    <link href="http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</id>
    <published>2020-03-20T08:30:37.000Z</published>
    <updated>2020-03-20T08:38:14.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-01-移除重复节点"><a href="#Leetcode面试题02-01-移除重复节点" class="headerlink" title="Leetcode面试题02.01.移除重复节点"></a>Leetcode面试题02.01.移除重复节点</h2><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><ul><li><p>思路</p><p>使用<code>HashMap</code>作为缓冲区存储出现过的值，若遇到的值已出现过，则删除。使用了虚拟头结点</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用HashSet更好</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next=head;</span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (prev.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(prev.next.val))&#123;</span><br><span class="line">                map.put(prev.next.val,<span class="number">1</span>);</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = prev.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-01-移除重复节点&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-01-移除重复节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.01.移除重复节点&quot;&gt;&lt;/a&gt;Leetcode面试题02.01.移除重复节点&lt;/h2&gt;&lt;p&gt;编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-node-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题40.最小的k个数</title>
    <link href="http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-20T03:30:50.000Z</published>
    <updated>2020-03-20T03:35:13.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题40-最小的k个数"><a href="#Leetcode面试题40-最小的k个数" class="headerlink" title="Leetcode面试题40.最小的k个数"></a>Leetcode面试题40.最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><blockquote><p><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></p></blockquote><blockquote><p><code>0 &lt;= arr[i] &lt;= 10000</code></p></blockquote><ul><li><p>思路</p><p>排序后取数组的前k个元素</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题40-最小的k个数&quot;&gt;&lt;a href=&quot;#Leetcode面试题40-最小的k个数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题40.最小的k个数&quot;&gt;&lt;/a&gt;Leetcode面试题40.最小的k个数&lt;/h2&gt;&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode695.岛屿的最大面积</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-19T06:04:54.000Z</published>
    <updated>2020-03-19T06:39:45.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode695-岛屿的最大面积"><a href="#Leetcode695-岛屿的最大面积" class="headerlink" title="Leetcode695.岛屿的最大面积"></a>Leetcode695.岛屿的最大面积</h2><p>给定一个包含了一些 <code>0</code> 和 <code>1</code> 的非空二维数组 <code>grid</code> 。</p><p>一个 <strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在水平或者竖直方向上相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code>0</code> 。)</p><p> <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>对于上面这个给定矩阵应返回 <code>6</code>。注意答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code>1</code> </p></blockquote><p><strong>示例 2:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p><p><strong>注意:</strong> 给定的矩阵<code>grid</code> 的长度和宽度都不超过 50。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>递归</p><p>当登录某个岛屿时，以此岛屿为中心，向上下左右扩散。当步入新地点时，则继续以新地点为中心朝四周扩散。很明显这符合递归的特性。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//以此为中心朝四周扩散</span></span><br><span class="line">                    area = getArea(grid, i, j);</span><br><span class="line">                    maxArea = maxArea &gt; area ? maxArea : area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//保证每块土地最多被访问一次，将登陆后的土地置为0</span></span><br><span class="line">          grid[i][j] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> + getArea(grid, i - <span class="number">1</span>, j) + getArea(grid, i + <span class="number">1</span>, j) + getArea(grid, i, j - <span class="number">1</span>) + getArea(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode695-岛屿的最大面积&quot;&gt;&lt;a href=&quot;#Leetcode695-岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;Leetcode695.岛屿的最大面积&quot;&gt;&lt;/a&gt;Leetcode695.岛屿的最大面积&lt;/h2&gt;&lt;p&gt;给定一个包含了一些 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 的非空二维数组 &lt;code&gt;grid&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个 &lt;strong&gt;岛屿&lt;/strong&gt; 是由一些相邻的 &lt;code&gt;1&lt;/code&gt; (代表土地) 构成的组合，这里的「相邻」要求两个 &lt;code&gt;1&lt;/code&gt; 必须在水平或者竖直方向上相邻。你可以假设 &lt;code&gt;grid&lt;/code&gt; 的四个边缘都被 &lt;code&gt;0&lt;/code&gt;（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 &lt;code&gt;0&lt;/code&gt; 。)&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/max-area-of-island/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="深度优先搜索" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode409.最长回文串</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2020-03-19T03:06:39.000Z</published>
    <updated>2020-03-19T03:17:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode409-最长回文串"><a href="#Leetcode409-最长回文串" class="headerlink" title="Leetcode409.最长回文串"></a>Leetcode409.最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p><p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p><p><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line"><span class="string">"abccccdd"</span></span><br><span class="line"></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">"dccaccd"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure><ul><li><p>思路</p><p>回文串正着和反着相同，所以有一个回文中心作为分界线，左右两边对称分布。从<code>abbcbba</code>可知一个回文串最多有一个字符出现奇数次，其他全为偶数次。所以我们构建最长回文串时，可以将每个字符使用偶数次，如果有奇数个字符，我们取出一个且只能取出一个作为回文中心。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//将每个字符使用偶数次，res为偶数</span></span><br><span class="line">            res += entry.getValue() / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//遇到奇数个字符时res++，此时res变为奇数，不会再++了</span></span><br><span class="line">            <span class="keyword">if</span> (res % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; entry.getValue() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode409-最长回文串&quot;&gt;&lt;a href=&quot;#Leetcode409-最长回文串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode409.最长回文串&quot;&gt;&lt;/a&gt;Leetcode409.最长回文串&lt;/h2&gt;&lt;p&gt;给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。&lt;/p&gt;
&lt;p&gt;在构造过程中，请注意区分大小写。比如 &lt;code&gt;&amp;quot;Aa&amp;quot;&lt;/code&gt; 不能当做一个回文字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;假设字符串的长度不会超过 1010。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode322.零钱兑换</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2020-03-18T06:32:31.000Z</published>
    <updated>2020-03-18T07:15:18.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode322-零钱兑换"><a href="#Leetcode322-零钱兑换" class="headerlink" title="Leetcode322.零钱兑换"></a>Leetcode322.零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><blockquote><p>你可以认为每种硬币的数量是无限的。</p></blockquote><a id="more"></a><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">题目链接</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>动态规划与记忆化搜索</p><p>定义memory[i]为凑成i所需的最小硬币数，则<code>memory[i] = memory[i-coins[j]] + 1</code>，其中<code>coins[j]</code>代表一个硬币面值，使用<code>memory</code>数组存储结果。</p></li><li><p>递归</p><p><code>findWay</code>方法中<code>amount</code>不断减去<code>coins[i]</code>，并用<code>count</code>记录次数，最终与结果<code>res</code>比较.</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findWay(coins,amount,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有任何一种硬币组合能组成总金额，返回 -1。</span></span><br><span class="line">        <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">            res = Math.min(res,count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            findWay(coins,amount-coins[i],count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>记忆化搜索(自上而下)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//memory[n]表示n可被换取的最少硬币数，不能被换则为-1</span></span><br><span class="line">    <span class="keyword">int</span>[] memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="keyword">int</span>[amount];</span><br><span class="line">        <span class="keyword">return</span> findWay(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findWay返回可凑成amount所需的最小硬币数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记忆化搜索，如果memory[amount]被赋过值，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (memory[amount-<span class="number">1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memory[amount-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = findWay(coins,amount-coins[i]);</span><br><span class="line">            <span class="keyword">if</span> (res!=-<span class="number">1</span>&amp;&amp;res&lt;min)&#123;</span><br><span class="line">                min = res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory[amount-<span class="number">1</span>] = (min==Integer.MAX_VALUE)?-<span class="number">1</span>:min;</span><br><span class="line">        <span class="keyword">return</span> memory[amount-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>动态规划(自下而上)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] memory;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memory[n]表示凑成总金额为n需要的最少硬币数</span></span><br><span class="line">        memory = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span> &amp;&amp; memory[i - coins[j]] &lt; min) &#123;</span><br><span class="line">                    min = memory[i - coins[j]] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//凑不成时memory[i]为Integer.MAX_VALUE</span></span><br><span class="line">            memory[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memory[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : memory[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode322-零钱兑换&quot;&gt;&lt;a href=&quot;#Leetcode322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;Leetcode322.零钱兑换&quot;&gt;&lt;/a&gt;Leetcode322.零钱兑换&lt;/h2&gt;&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], amount = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], amount = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="记忆化搜索" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1103.分糖果II</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode1103-%E5%88%86%E7%B3%96%E6%9E%9CII/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode1103-%E5%88%86%E7%B3%96%E6%9E%9CII/</id>
    <published>2020-03-18T04:20:55.000Z</published>
    <updated>2020-03-18T04:25:57.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1103-分糖果II"><a href="#Leetcode1103-分糖果II" class="headerlink" title="Leetcode1103.分糖果II"></a>Leetcode1103.分糖果II</h2><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p> <a href="https://leetcode-cn.com/problems/distribute-candies-to-people" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：candies = 7, num_people = 4</p><p>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</p></blockquote><p>示例 2：</p><blockquote><p>输入：candies = 10, num_people = 3</p><p>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= candies &lt;= 10^9</p><p>1 &lt;= num_people &lt;= 1000</p></blockquote><ul><li><p>思路</p><p>可通过<code>i%num_people</code>累加直到糖果为0</p><p>也可通过等差数列转化为数学问题。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret[i % num_people] += Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">            candies -= Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1103-分糖果II&quot;&gt;&lt;a href=&quot;#Leetcode1103-分糖果II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1103.分糖果II&quot;&gt;&lt;/a&gt;Leetcode1103.分糖果II&lt;/h2&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。&lt;/p&gt;
&lt;p&gt;给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。&lt;/p&gt;
&lt;p&gt;然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。&lt;/p&gt;
&lt;p&gt;重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。&lt;/p&gt;
&lt;p&gt;返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/distribute-candies-to-people&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode836.矩形重叠</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T03:20:22.000Z</published>
    <updated>2020-03-18T03:25:14.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode836-矩形重叠"><a href="#Leetcode836-矩形重叠" class="headerlink" title="Leetcode836.矩形重叠"></a>Leetcode836.矩形重叠</h2><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p> <a href="https://leetcode-cn.com/problems/rectangle-overlap" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</p><p>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</p><p>输出：false</p></blockquote><p>提示：</p><blockquote><p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</p><p>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p></blockquote><ul><li><p>思路</p><p>判断两个矩形是否重叠只需判断以下几种情况</p><ul><li>矩形1在矩形2上方</li><li>矩形1在矩形2下方</li><li>矩形1在矩形2左边</li><li>矩形1在矩形2右边</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">0</span>]&gt;=rec2[<span class="number">2</span>]||rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode836-矩形重叠&quot;&gt;&lt;a href=&quot;#Leetcode836-矩形重叠&quot; class=&quot;headerlink&quot; title=&quot;Leetcode836.矩形重叠&quot;&gt;&lt;/a&gt;Leetcode836.矩形重叠&lt;/h2&gt;&lt;p&gt;矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。&lt;/p&gt;
&lt;p&gt;如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。&lt;/p&gt;
&lt;p&gt;给出两个矩形，判断它们是否重叠并返回结果。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rectangle-overlap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode面试题01.06.字符串压缩</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-03-17T07:27:00.000Z</published>
    <updated>2020-03-17T07:59:44.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题01-06-字符串压缩"><a href="#Leetcode面试题01-06-字符串压缩" class="headerlink" title="Leetcode面试题01.06.字符串压缩"></a>Leetcode面试题01.06.字符串压缩</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p><a href="https://leetcode-cn.com/problems/compress-string-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例1:</p><blockquote><p>输入：”aabcccccaaa”</p><p>输出：”a2b1c5a3”</p></blockquote><p>示例2:</p><blockquote><p>输入：”abbccd”</p><p>输出：”abbccd”<br>解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。</p></blockquote><p>提示：</p><blockquote><p>字符串长度在[0, 50000]范围内。</p></blockquote><ul><li><p>思路</p><p>利用双指针可以很快速的得到结果，不能用哈希表，因为会有前后出现一样字母的可能，例<code>aabcccccaaa</code></p><p>使用<code>StringBuilder</code>可以消耗少量内存构建字符串。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenS = S.length();</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; lenS &amp;&amp; S.charAt(i) == S.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(S.charAt(i));</span><br><span class="line">        stringBuilder.append(j - i);</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (lenS &lt;= stringBuilder.length()) ? S : stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题01-06-字符串压缩&quot;&gt;&lt;a href=&quot;#Leetcode面试题01-06-字符串压缩&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题01.06.字符串压缩&quot;&gt;&lt;/a&gt;Leetcode面试题01.06.字符串压缩&lt;/h2&gt;&lt;p&gt;字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/compress-string-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1160.拼写单词</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</id>
    <published>2020-03-17T07:08:55.000Z</published>
    <updated>2020-03-17T07:19:08.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1160-拼写单词"><a href="#Leetcode1160-拼写单词" class="headerlink" title="Leetcode1160.拼写单词"></a>Leetcode1160.拼写单词</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p> <a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”</p><p>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。</p></blockquote><p>示例 2：</p><blockquote><p>输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”</p><p>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= words.length &lt;= 1000</p><p>1 &lt;= words[i].length, chars.length &lt;= 100<br>所有字符串中都仅包含小写英文字母</p></blockquote><ul><li><p>思路</p><p>很明显可以利用哈希表来做，统计mapChar是否覆盖mapWord。</p><p>也可以统计26个字母出现次数来判断。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; mapWord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; mapChar = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mapChar.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = mapChar.get(c);</span><br><span class="line">                mapChar.put(c, t + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapChar.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (mapWord.containsKey(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = mapWord.get(c);</span><br><span class="line">                    mapWord.put(c, t + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mapWord.put(c, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : mapWord.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">char</span> ck = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (!(mapChar.containsKey(ck) &amp;&amp; entry.getValue() &lt;= mapChar.get(ck))) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lenSum += (flag == <span class="keyword">true</span>) ? word.length() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//记得每次遍历完一次word后要把mapWord清空</span></span><br><span class="line">            mapWord.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1160-拼写单词&quot;&gt;&lt;a href=&quot;#Leetcode1160-拼写单词&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1160.拼写单词&quot;&gt;&lt;/a&gt;Leetcode1160.拼写单词&lt;/h2&gt;&lt;p&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1013.将数组分成相等的三个部分</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-16T09:05:38.000Z</published>
    <updated>2020-03-16T09:10:30.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1013-将数组分成相等的三个部分"><a href="#Leetcode1013-将数组分成相等的三个部分" class="headerlink" title="Leetcode1013.将数组分成相等的三个部分"></a>Leetcode1013.将数组分成相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p> <a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]</p><p>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]</p><p>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：[3,3,6,5,-2,2,5,1,-9,4]</p><p>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p></blockquote><p>提示：</p><blockquote><p>3 &lt;= A.length &lt;= 50000</p><p>-10^4 &lt;= A[i] &lt;= 10^4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">                temp += A[i];</span><br><span class="line">                <span class="keyword">if</span>(temp==target)&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//防止[1,-1,1,-1,1,-1,1,-1]的情况下time&gt;3</span></span><br><span class="line">        <span class="keyword">return</span> time&gt;=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1013-将数组分成相等的三个部分&quot;&gt;&lt;a href=&quot;#Leetcode1013-将数组分成相等的三个部分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1013.将数组分成相等的三个部分&quot;&gt;&lt;/a&gt;Leetcode1013.将数组分成相等的三个部分&lt;/h2&gt;&lt;p&gt;给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。&lt;/p&gt;
&lt;p&gt;形式上，如果可以找出索引 i+1 &amp;lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode994.腐烂的橘子</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-16T07:57:37.000Z</published>
    <updated>2020-03-16T08:10:49.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode994-腐烂的橘子"><a href="#Leetcode994-腐烂的橘子" class="headerlink" title="Leetcode994.腐烂的橘子"></a>Leetcode994.腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p> <a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：[[2,1,1],[1,1,0],[0,1,1]]</p><p>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：[[2,1,1],[0,1,1],[1,0,1]]</p><p>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p></blockquote><p>示例 3：</p><blockquote><p>输入：[[0,2]]</p><p>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= grid.length &lt;= 10</p><p>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p></blockquote><ul><li><p>思路</p><p>第一天将所有的烂橘子入队列，然后按天数依次腐烂，新腐烂的橘子入队列，记录天数。然后判断是否还有没腐烂的橘子。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照上左下右的顺序腐烂</span></span><br><span class="line">    <span class="keyword">int</span>[] tr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] tc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.length;</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        Queue&lt;Integer&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> C = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//存储天数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; depth = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第0天所有腐烂的橘子入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//转换为单数组</span></span><br><span class="line">                    <span class="keyword">int</span> code = r * C + c;</span><br><span class="line">                    arrayDeque.add(code);</span><br><span class="line">                    depth.put(code, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!arrayDeque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> code = arrayDeque.remove();</span><br><span class="line">            <span class="keyword">int</span> r = code / C, c = code % C;</span><br><span class="line">            <span class="comment">//按上左下右顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = r + tr[k];</span><br><span class="line">                <span class="keyword">int</span> nc = c + tc[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> ncode = nr * C + nc;</span><br><span class="line">                    arrayDeque.add(ncode);</span><br><span class="line">                    depth.put(ncode, depth.get(code) + <span class="number">1</span>);</span><br><span class="line">                    ret = depth.get(ncode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断是否还有新鲜的橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode994-腐烂的橘子&quot;&gt;&lt;a href=&quot;#Leetcode994-腐烂的橘子&quot; class=&quot;headerlink&quot; title=&quot;Leetcode994.腐烂的橘子&quot;&gt;&lt;/a&gt;Leetcode994.腐烂的橘子&lt;/h2&gt;&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;p&gt;值 0 代表空单元格；&lt;br&gt;值 1 代表新鲜橘子；&lt;br&gt;值 2 代表腐烂的橘子。&lt;br&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p&gt;
&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
