<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flbu blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-21T07:13:02.268Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flbu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode365.水壶问题</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-21T06:59:30.000Z</published>
    <updated>2020-03-21T07:13:02.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode365-水壶问题"><a href="#Leetcode365-水壶问题" class="headerlink" title="Leetcode365.水壶问题"></a>Leetcode365.水壶问题</h2><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener">*”Die Hard”* example</a>)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">3</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">5</span><span class="string">,</span> <span class="string">z</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">x</span> <span class="string">=</span> <span class="number">2</span><span class="string">,</span> <span class="string">y</span> <span class="string">=</span> <span class="number">6</span><span class="string">,</span> <span class="string">z</span> <span class="string">=</span> <span class="number">5</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以定义一个内部类<code>Pair</code>，<code>Pair</code>中的两个变量<code>x、y</code>分别表示当前两个水壶的水<code>curX、curY</code>。创建一个队列<code>queue</code>，来存储所有的状态，创建一个哈希集合<code>visited</code>来避免保存遍历过的状态。</p><p>题目说：</p><blockquote><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul></blockquote><p>所以一共有以下几种情况</p><p>装满任意一个水壶，定义为「情况一」，分为：<br>（1）装满 <code>A</code>；<br>（2）装满 <code>B</code>。</p><p>清空任意一个水壶，定义为「情况二」，分为<br>（1）清空 <code>A</code>；<br>（2）清空 <code>B</code>。</p><p>从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「情况三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：</p><p>（1）从 <code>A</code> 到 <code>B</code>，使得 <code>B</code> 满，<code>A</code> 还有剩；<br>（2）从 <code>A</code> 到 <code>B</code>，此时 <code>A</code> 的水太少，<code>A</code> 倒尽，<code>B</code> 没有满；<br>（3）从 <code>B</code> 到 <code>A</code>，使得 <code>A</code> 满，<code>B</code> 还有剩余；<br>（4）从 <code>B</code> 到 <code>A</code>，此时 <code>B</code> 的水太少，<code>B</code> 倒尽，<code>A</code> 没有满。</p><p>因此，从当前「状态」最多可以进行 8 种操作，得到 8 个新「状态」，对这 8 个新「状态」，依然可以扩展，一直做下去，直到某一个状态满足题目要求。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Pair&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Pair&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Pair pair = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        queue.add(pair);</span><br><span class="line">        visited.add(pair);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair head = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curX = head.getX();</span><br><span class="line">            <span class="keyword">int</span> curY = head.getY();</span><br><span class="line">            <span class="keyword">if</span> (curX == z || curY == z || curX + curY == z) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Pair&gt; nextPairs = getNextPairs(curX, curY, x, y);</span><br><span class="line"><span class="comment">//            System.out.println(head+"-&gt;" +nextPairs);</span></span><br><span class="line">            <span class="keyword">for</span> (Pair p : nextPairs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(p)) &#123;</span><br><span class="line">                    visited.add(p);</span><br><span class="line">                    queue.add(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(queue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">getNextPairs</span><span class="params">(<span class="keyword">int</span> curX, <span class="keyword">int</span> curY, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        List&lt;Pair&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//装满A</span></span><br><span class="line">        Pair pair1 = <span class="keyword">new</span> Pair(x, curY);</span><br><span class="line">        <span class="comment">//装满B</span></span><br><span class="line">        Pair pair2 = <span class="keyword">new</span> Pair(curX, y);</span><br><span class="line">        <span class="comment">//A没满时装满</span></span><br><span class="line">        <span class="keyword">if</span> (curX &lt; x) &#123;</span><br><span class="line">            list.add(pair1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B没满时装满</span></span><br><span class="line">        <span class="keyword">if</span> (curY &lt; y) &#123;</span><br><span class="line">            list.add(pair2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        Pair pair3 = <span class="keyword">new</span> Pair(<span class="number">0</span>, curY);</span><br><span class="line">        Pair pair4 = <span class="keyword">new</span> Pair(curX, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//有水时清空</span></span><br><span class="line">        <span class="keyword">if</span> (curX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A-&gt;B,B fill,A left</span></span><br><span class="line">        Pair pair5 = <span class="keyword">new</span> Pair(curX - (y - curY), y);</span><br><span class="line">        <span class="comment">//A-&gt;B,B not fill,A empty</span></span><br><span class="line">        Pair pair6 = <span class="keyword">new</span> Pair(<span class="number">0</span>, curY + curX);</span><br><span class="line">        <span class="comment">//B-&gt;A,A fill,B left</span></span><br><span class="line">        Pair pair7 = <span class="keyword">new</span> Pair(x, curY - (x - curX));</span><br><span class="line">        <span class="comment">//B-&gt;A,A not fill,B empty</span></span><br><span class="line">        Pair pair8 = <span class="keyword">new</span> Pair(curX + curY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//有剩余</span></span><br><span class="line">        <span class="keyword">if</span> (curX - (y - curY) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curY - (x - curX) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(pair7);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//装不满</span></span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; x) &#123;</span><br><span class="line">            list.add(pair8);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curX + curY &lt; y) &#123;</span><br><span class="line">            list.add(pair6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Pair&#123;"</span> +</span><br><span class="line">                    <span class="string">"x="</span> + x +</span><br><span class="line">                    <span class="string">", y="</span> + y +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Pair)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Pair pair = (Pair) o;</span><br><span class="line">            <span class="keyword">return</span> getX() == pair.getX() &amp;&amp;</span><br><span class="line">                    getY() == pair.getY();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(getX(), getY());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode365-水壶问题&quot;&gt;&lt;a href=&quot;#Leetcode365-水壶问题&quot; class=&quot;headerlink&quot; title=&quot;Leetcode365.水壶问题&quot;&gt;&lt;/a&gt;Leetcode365.水壶问题&lt;/h2&gt;&lt;p&gt;有两个容量分别为 &lt;em&gt;x&lt;/em&gt;升 和 &lt;em&gt;y&lt;/em&gt;升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;em&gt;z&lt;/em&gt;升 的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 &lt;em&gt;z升&lt;/em&gt; 水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/water-and-jug-problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.06.回文链表</title>
    <link href="http://yoursite.com/2020/03/21/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/21/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2020-03-21T04:59:25.000Z</published>
    <updated>2020-03-21T05:12:07.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-06-回文链表"><a href="#Leetcode面试题02-06-回文链表" class="headerlink" title="Leetcode面试题02.06.回文链表"></a>Leetcode面试题02.06.回文链表</h2><p>编写一个函数，检查输入的链表是否是回文的。</p><p> <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出： <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出： <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><ul><li><p>思路</p><p>使用快慢指针找到链表的中间节点，将后半部分链表反转，再逐个比较，因为回文链表必定以中间节点为中心对称。此时时间复杂度为O(n)，空间复杂度为O(1)。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = slow.next;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转后半部分链表  </span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.val != head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-06-回文链表&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-06-回文链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.06.回文链表&quot;&gt;&lt;/a&gt;Leetcode面试题02.06.回文链表&lt;/h2&gt;&lt;p&gt;编写一个函数，检查输入的链表是否是回文的。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题02.01.移除重复节点</title>
    <link href="http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9802-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</id>
    <published>2020-03-20T08:30:37.000Z</published>
    <updated>2020-03-20T08:38:14.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题02-01-移除重复节点"><a href="#Leetcode面试题02-01-移除重复节点" class="headerlink" title="Leetcode面试题02.01.移除重复节点"></a>Leetcode面试题02.01.移除重复节点</h2><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><ul><li><p>思路</p><p>使用<code>HashMap</code>作为缓冲区存储出现过的值，若遇到的值已出现过，则删除。使用了虚拟头结点</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用HashSet更好</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next=head;</span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (prev.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(prev.next.val))&#123;</span><br><span class="line">                map.put(prev.next.val,<span class="number">1</span>);</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = prev.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题02-01-移除重复节点&quot;&gt;&lt;a href=&quot;#Leetcode面试题02-01-移除重复节点&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题02.01.移除重复节点&quot;&gt;&lt;/a&gt;Leetcode面试题02.01.移除重复节点&lt;/h2&gt;&lt;p&gt;编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicate-node-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题40.最小的k个数</title>
    <link href="http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/20/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-20T03:30:50.000Z</published>
    <updated>2020-03-20T03:35:13.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题40-最小的k个数"><a href="#Leetcode面试题40-最小的k个数" class="headerlink" title="Leetcode面试题40.最小的k个数"></a>Leetcode面试题40.最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><blockquote><p><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></p></blockquote><blockquote><p><code>0 &lt;= arr[i] &lt;= 10000</code></p></blockquote><ul><li><p>思路</p><p>排序后取数组的前k个元素</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题40-最小的k个数&quot;&gt;&lt;a href=&quot;#Leetcode面试题40-最小的k个数&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题40.最小的k个数&quot;&gt;&lt;/a&gt;Leetcode面试题40.最小的k个数&lt;/h2&gt;&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode695.岛屿的最大面积</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-03-19T06:04:54.000Z</published>
    <updated>2020-03-19T06:39:45.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode695-岛屿的最大面积"><a href="#Leetcode695-岛屿的最大面积" class="headerlink" title="Leetcode695.岛屿的最大面积"></a>Leetcode695.岛屿的最大面积</h2><p>给定一个包含了一些 <code>0</code> 和 <code>1</code> 的非空二维数组 <code>grid</code> 。</p><p>一个 <strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在水平或者竖直方向上相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code>0</code> 。)</p><p> <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>对于上面这个给定矩阵应返回 <code>6</code>。注意答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code>1</code> </p></blockquote><p><strong>示例 2:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p><p><strong>注意:</strong> 给定的矩阵<code>grid</code> 的长度和宽度都不超过 50。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>递归</p><p>当登录某个岛屿时，以此岛屿为中心，向上下左右扩散。当步入新地点时，则继续以新地点为中心朝四周扩散。很明显这符合递归的特性。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//以此为中心朝四周扩散</span></span><br><span class="line">                    area = getArea(grid, i, j);</span><br><span class="line">                    maxArea = maxArea &gt; area ? maxArea : area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//保证每块土地最多被访问一次，将登陆后的土地置为0</span></span><br><span class="line">          grid[i][j] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> + getArea(grid, i - <span class="number">1</span>, j) + getArea(grid, i + <span class="number">1</span>, j) + getArea(grid, i, j - <span class="number">1</span>) + getArea(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode695-岛屿的最大面积&quot;&gt;&lt;a href=&quot;#Leetcode695-岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;Leetcode695.岛屿的最大面积&quot;&gt;&lt;/a&gt;Leetcode695.岛屿的最大面积&lt;/h2&gt;&lt;p&gt;给定一个包含了一些 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 的非空二维数组 &lt;code&gt;grid&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个 &lt;strong&gt;岛屿&lt;/strong&gt; 是由一些相邻的 &lt;code&gt;1&lt;/code&gt; (代表土地) 构成的组合，这里的「相邻」要求两个 &lt;code&gt;1&lt;/code&gt; 必须在水平或者竖直方向上相邻。你可以假设 &lt;code&gt;grid&lt;/code&gt; 的四个边缘都被 &lt;code&gt;0&lt;/code&gt;（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 &lt;code&gt;0&lt;/code&gt; 。)&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/max-area-of-island/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="深度优先搜索" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode409.最长回文串</title>
    <link href="http://yoursite.com/2020/03/19/Leetcode409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/03/19/Leetcode409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2020-03-19T03:06:39.000Z</published>
    <updated>2020-03-19T03:17:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode409-最长回文串"><a href="#Leetcode409-最长回文串" class="headerlink" title="Leetcode409.最长回文串"></a>Leetcode409.最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p><p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p><p><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line"><span class="string">"abccccdd"</span></span><br><span class="line"></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">"dccaccd"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure><ul><li><p>思路</p><p>回文串正着和反着相同，所以有一个回文中心作为分界线，左右两边对称分布。从<code>abbcbba</code>可知一个回文串最多有一个字符出现奇数次，其他全为偶数次。所以我们构建最长回文串时，可以将每个字符使用偶数次，如果有奇数个字符，我们取出一个且只能取出一个作为回文中心。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//将每个字符使用偶数次，res为偶数</span></span><br><span class="line">            res += entry.getValue() / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//遇到奇数个字符时res++，此时res变为奇数，不会再++了</span></span><br><span class="line">            <span class="keyword">if</span> (res % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; entry.getValue() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode409-最长回文串&quot;&gt;&lt;a href=&quot;#Leetcode409-最长回文串&quot; class=&quot;headerlink&quot; title=&quot;Leetcode409.最长回文串&quot;&gt;&lt;/a&gt;Leetcode409.最长回文串&lt;/h2&gt;&lt;p&gt;给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。&lt;/p&gt;
&lt;p&gt;在构造过程中，请注意区分大小写。比如 &lt;code&gt;&amp;quot;Aa&amp;quot;&lt;/code&gt; 不能当做一个回文字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;假设字符串的长度不会超过 1010。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode322.零钱兑换</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2020-03-18T06:32:31.000Z</published>
    <updated>2020-03-18T07:15:18.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode322-零钱兑换"><a href="#Leetcode322-零钱兑换" class="headerlink" title="Leetcode322.零钱兑换"></a>Leetcode322.零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><blockquote><p>你可以认为每种硬币的数量是无限的。</p></blockquote><a id="more"></a><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">题目链接</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>动态规划与记忆化搜索</p><p>定义memory[i]为凑成i所需的最小硬币数，则<code>memory[i] = memory[i-coins[j]] + 1</code>，其中<code>coins[j]</code>代表一个硬币面值，使用<code>memory</code>数组存储结果。</p></li><li><p>递归</p><p><code>findWay</code>方法中<code>amount</code>不断减去<code>coins[i]</code>，并用<code>count</code>记录次数，最终与结果<code>res</code>比较.</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findWay(coins,amount,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有任何一种硬币组合能组成总金额，返回 -1。</span></span><br><span class="line">        <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">            res = Math.min(res,count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            findWay(coins,amount-coins[i],count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>记忆化搜索(自上而下)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//memory[n]表示n可被换取的最少硬币数，不能被换则为-1</span></span><br><span class="line">    <span class="keyword">int</span>[] memory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="keyword">int</span>[amount];</span><br><span class="line">        <span class="keyword">return</span> findWay(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findWay返回可凑成amount所需的最小硬币数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记忆化搜索，如果memory[amount]被赋过值，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (memory[amount-<span class="number">1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memory[amount-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = findWay(coins,amount-coins[i]);</span><br><span class="line">            <span class="keyword">if</span> (res!=-<span class="number">1</span>&amp;&amp;res&lt;min)&#123;</span><br><span class="line">                min = res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory[amount-<span class="number">1</span>] = (min==Integer.MAX_VALUE)?-<span class="number">1</span>:min;</span><br><span class="line">        <span class="keyword">return</span> memory[amount-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>动态规划(自下而上)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] memory;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memory[n]表示凑成总金额为n需要的最少硬币数</span></span><br><span class="line">        memory = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span> &amp;&amp; memory[i - coins[j]] &lt; min) &#123;</span><br><span class="line">                    min = memory[i - coins[j]] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//凑不成时memory[i]为Integer.MAX_VALUE</span></span><br><span class="line">            memory[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memory[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : memory[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode322-零钱兑换&quot;&gt;&lt;a href=&quot;#Leetcode322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;Leetcode322.零钱兑换&quot;&gt;&lt;/a&gt;Leetcode322.零钱兑换&lt;/h2&gt;&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], amount = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], amount = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="记忆化搜索" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1103.分糖果II</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode1103-%E5%88%86%E7%B3%96%E6%9E%9CII/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode1103-%E5%88%86%E7%B3%96%E6%9E%9CII/</id>
    <published>2020-03-18T04:20:55.000Z</published>
    <updated>2020-03-18T04:25:57.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1103-分糖果II"><a href="#Leetcode1103-分糖果II" class="headerlink" title="Leetcode1103.分糖果II"></a>Leetcode1103.分糖果II</h2><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p> <a href="https://leetcode-cn.com/problems/distribute-candies-to-people" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：candies = 7, num_people = 4</p><p>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</p></blockquote><p>示例 2：</p><blockquote><p>输入：candies = 10, num_people = 3</p><p>输出：[5,2,3]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= candies &lt;= 10^9</p><p>1 &lt;= num_people &lt;= 1000</p></blockquote><ul><li><p>思路</p><p>可通过<code>i%num_people</code>累加直到糖果为0</p><p>也可通过等差数列转化为数学问题。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret[i % num_people] += Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">            candies -= Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1103-分糖果II&quot;&gt;&lt;a href=&quot;#Leetcode1103-分糖果II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1103.分糖果II&quot;&gt;&lt;/a&gt;Leetcode1103.分糖果II&lt;/h2&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。&lt;/p&gt;
&lt;p&gt;给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。&lt;/p&gt;
&lt;p&gt;然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。&lt;/p&gt;
&lt;p&gt;重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。&lt;/p&gt;
&lt;p&gt;返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/distribute-candies-to-people&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode836.矩形重叠</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T03:20:22.000Z</published>
    <updated>2020-03-18T03:25:14.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode836-矩形重叠"><a href="#Leetcode836-矩形重叠" class="headerlink" title="Leetcode836.矩形重叠"></a>Leetcode836.矩形重叠</h2><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p> <a href="https://leetcode-cn.com/problems/rectangle-overlap" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</p><p>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</p><p>输出：false</p></blockquote><p>提示：</p><blockquote><p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</p><p>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p></blockquote><ul><li><p>思路</p><p>判断两个矩形是否重叠只需判断以下几种情况</p><ul><li>矩形1在矩形2上方</li><li>矩形1在矩形2下方</li><li>矩形1在矩形2左边</li><li>矩形1在矩形2右边</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">0</span>]&gt;=rec2[<span class="number">2</span>]||rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode836-矩形重叠&quot;&gt;&lt;a href=&quot;#Leetcode836-矩形重叠&quot; class=&quot;headerlink&quot; title=&quot;Leetcode836.矩形重叠&quot;&gt;&lt;/a&gt;Leetcode836.矩形重叠&lt;/h2&gt;&lt;p&gt;矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。&lt;/p&gt;
&lt;p&gt;如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。&lt;/p&gt;
&lt;p&gt;给出两个矩形，判断它们是否重叠并返回结果。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rectangle-overlap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode面试题01.06.字符串压缩</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-03-17T07:27:00.000Z</published>
    <updated>2020-03-17T07:59:44.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题01-06-字符串压缩"><a href="#Leetcode面试题01-06-字符串压缩" class="headerlink" title="Leetcode面试题01.06.字符串压缩"></a>Leetcode面试题01.06.字符串压缩</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p><a href="https://leetcode-cn.com/problems/compress-string-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例1:</p><blockquote><p>输入：”aabcccccaaa”</p><p>输出：”a2b1c5a3”</p></blockquote><p>示例2:</p><blockquote><p>输入：”abbccd”</p><p>输出：”abbccd”<br>解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。</p></blockquote><p>提示：</p><blockquote><p>字符串长度在[0, 50000]范围内。</p></blockquote><ul><li><p>思路</p><p>利用双指针可以很快速的得到结果，不能用哈希表，因为会有前后出现一样字母的可能，例<code>aabcccccaaa</code></p><p>使用<code>StringBuilder</code>可以消耗少量内存构建字符串。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenS = S.length();</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; lenS &amp;&amp; S.charAt(i) == S.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(S.charAt(i));</span><br><span class="line">        stringBuilder.append(j - i);</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (lenS &lt;= stringBuilder.length()) ? S : stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题01-06-字符串压缩&quot;&gt;&lt;a href=&quot;#Leetcode面试题01-06-字符串压缩&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题01.06.字符串压缩&quot;&gt;&lt;/a&gt;Leetcode面试题01.06.字符串压缩&lt;/h2&gt;&lt;p&gt;字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/compress-string-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1160.拼写单词</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</id>
    <published>2020-03-17T07:08:55.000Z</published>
    <updated>2020-03-17T07:19:08.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1160-拼写单词"><a href="#Leetcode1160-拼写单词" class="headerlink" title="Leetcode1160.拼写单词"></a>Leetcode1160.拼写单词</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p> <a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”</p><p>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。</p></blockquote><p>示例 2：</p><blockquote><p>输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”</p><p>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= words.length &lt;= 1000</p><p>1 &lt;= words[i].length, chars.length &lt;= 100<br>所有字符串中都仅包含小写英文字母</p></blockquote><ul><li><p>思路</p><p>很明显可以利用哈希表来做，统计mapChar是否覆盖mapWord。</p><p>也可以统计26个字母出现次数来判断。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; mapWord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; mapChar = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mapChar.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = mapChar.get(c);</span><br><span class="line">                mapChar.put(c, t + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapChar.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (mapWord.containsKey(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = mapWord.get(c);</span><br><span class="line">                    mapWord.put(c, t + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mapWord.put(c, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : mapWord.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">char</span> ck = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (!(mapChar.containsKey(ck) &amp;&amp; entry.getValue() &lt;= mapChar.get(ck))) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lenSum += (flag == <span class="keyword">true</span>) ? word.length() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//记得每次遍历完一次word后要把mapWord清空</span></span><br><span class="line">            mapWord.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1160-拼写单词&quot;&gt;&lt;a href=&quot;#Leetcode1160-拼写单词&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1160.拼写单词&quot;&gt;&lt;/a&gt;Leetcode1160.拼写单词&lt;/h2&gt;&lt;p&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1013.将数组分成相等的三个部分</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-16T09:05:38.000Z</published>
    <updated>2020-03-16T09:10:30.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1013-将数组分成相等的三个部分"><a href="#Leetcode1013-将数组分成相等的三个部分" class="headerlink" title="Leetcode1013.将数组分成相等的三个部分"></a>Leetcode1013.将数组分成相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p> <a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]</p><p>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]</p><p>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：[3,3,6,5,-2,2,5,1,-9,4]</p><p>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p></blockquote><p>提示：</p><blockquote><p>3 &lt;= A.length &lt;= 50000</p><p>-10^4 &lt;= A[i] &lt;= 10^4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">                temp += A[i];</span><br><span class="line">                <span class="keyword">if</span>(temp==target)&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//防止[1,-1,1,-1,1,-1,1,-1]的情况下time&gt;3</span></span><br><span class="line">        <span class="keyword">return</span> time&gt;=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1013-将数组分成相等的三个部分&quot;&gt;&lt;a href=&quot;#Leetcode1013-将数组分成相等的三个部分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1013.将数组分成相等的三个部分&quot;&gt;&lt;/a&gt;Leetcode1013.将数组分成相等的三个部分&lt;/h2&gt;&lt;p&gt;给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。&lt;/p&gt;
&lt;p&gt;形式上，如果可以找出索引 i+1 &amp;lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode994.腐烂的橘子</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-16T07:57:37.000Z</published>
    <updated>2020-03-16T08:10:49.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode994-腐烂的橘子"><a href="#Leetcode994-腐烂的橘子" class="headerlink" title="Leetcode994.腐烂的橘子"></a>Leetcode994.腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p> <a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：[[2,1,1],[1,1,0],[0,1,1]]</p><p>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：[[2,1,1],[0,1,1],[1,0,1]]</p><p>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p></blockquote><p>示例 3：</p><blockquote><p>输入：[[0,2]]</p><p>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= grid.length &lt;= 10</p><p>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p></blockquote><ul><li><p>思路</p><p>第一天将所有的烂橘子入队列，然后按天数依次腐烂，新腐烂的橘子入队列，记录天数。然后判断是否还有没腐烂的橘子。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照上左下右的顺序腐烂</span></span><br><span class="line">    <span class="keyword">int</span>[] tr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] tc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.length;</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        Queue&lt;Integer&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> C = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//存储天数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; depth = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第0天所有腐烂的橘子入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//转换为单数组</span></span><br><span class="line">                    <span class="keyword">int</span> code = r * C + c;</span><br><span class="line">                    arrayDeque.add(code);</span><br><span class="line">                    depth.put(code, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!arrayDeque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> code = arrayDeque.remove();</span><br><span class="line">            <span class="keyword">int</span> r = code / C, c = code % C;</span><br><span class="line">            <span class="comment">//按上左下右顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = r + tr[k];</span><br><span class="line">                <span class="keyword">int</span> nc = c + tc[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> ncode = nr * C + nc;</span><br><span class="line">                    arrayDeque.add(ncode);</span><br><span class="line">                    depth.put(ncode, depth.get(code) + <span class="number">1</span>);</span><br><span class="line">                    ret = depth.get(ncode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断是否还有新鲜的橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode994-腐烂的橘子&quot;&gt;&lt;a href=&quot;#Leetcode994-腐烂的橘子&quot; class=&quot;headerlink&quot; title=&quot;Leetcode994.腐烂的橘子&quot;&gt;&lt;/a&gt;Leetcode994.腐烂的橘子&lt;/h2&gt;&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;p&gt;值 0 代表空单元格；&lt;br&gt;值 1 代表新鲜橘子；&lt;br&gt;值 2 代表腐烂的橘子。&lt;br&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p&gt;
&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode169.多数元素</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2020-03-15T10:09:55.000Z</published>
    <updated>2020-03-15T10:36:46.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode169-多数元素"><a href="#LeetCode169-多数元素" class="headerlink" title="LeetCode169.多数元素"></a>LeetCode169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><a href="https://leetcode-cn.com/problems/majority-element" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [3,2,3]</p><p>输出: 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: [2,2,1,1,1,2,2]</p><p>输出: 2</p></blockquote><h4 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(num))&#123;</span><br><span class="line">               map.put(num,<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Map.Entry&lt;Integer,Integer&gt; majorityEntry = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">           <span class="keyword">if</span> (majorityEntry == <span class="keyword">null</span>||entry.getValue()&gt;majorityEntry.getValue())&#123;</span><br><span class="line">               majorityEntry = entry;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二：排序"><a href="#解法二：排序" class="headerlink" title="解法二：排序"></a>解法二：排序</h4><p>因为题中说明了众数数目多余n/2，所以排序后n/2处一定为众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="解法三：投票算法"><a href="#解法三：投票算法" class="headerlink" title="解法三：投票算法"></a>解法三：投票算法</h3><ul><li><p>思路</p><p>如果我们把众数记为1，其他数记为-1，全部加起来后，显然和大于0.</p></li><li><p>算法</p><ul><li>我们先维护一个候选众数<code>candidate</code>和它出现的次数<code>count</code>，初始时<code>candidate</code>为任意值，<code>count</code>为0.</li><li>遍历数组元素，对于每个出现的元素<code>num</code>，如果判断<code>num</code>之前，<code>count</code>为0，将<code>num</code>的值赋给<code>candidate</code>。然后进行如下判断：<ul><li>若<code>num</code>与<code>candidate</code>相等，则<code>count++</code></li><li>如果<code>num</code>与<code>candidate</code>不等，则<code>count--</code></li></ul></li><li>遍历完成后，<code>candidate</code>即为众数</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//投票算法</span></span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span> )&#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count+=num==candidate? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode169-多数元素&quot;&gt;&lt;a href=&quot;#LeetCode169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode169.多数元素&quot;&gt;&lt;/a&gt;LeetCode169.多数元素&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode121.买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-03-15T08:00:47.000Z</published>
    <updated>2020-03-15T08:31:34.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode121-买卖股票的最佳时机"><a href="#Leetcode121-买卖股票的最佳时机" class="headerlink" title="Leetcode121.买卖股票的最佳时机"></a>Leetcode121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">题目链接</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">一个非常牛逼的大佬的解法</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [7,1,5,3,6,4]</p><p>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [7,6,4,3,1]</p><p>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录最大利润</span></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&lt;minPrice)&#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i]-minPrice&gt;maxProfit)&#123;</span><br><span class="line">                    maxProfit = prices[i] - minPrice;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#Leetcode121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;Leetcode121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;Leetcode121.买卖股票的最佳时机&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个非常牛逼的大佬的解法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题57-II.和为s的连续正数序列</title>
    <link href="http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9857-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9857-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T07:27:59.000Z</published>
    <updated>2020-03-14T07:49:55.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题57-II-和为s的连续正数序列"><a href="#Leetcode面试题57-II-和为s的连续正数序列" class="headerlink" title="Leetcode面试题57-II.和为s的连续正数序列"></a>Leetcode面试题57-II.和为s的连续正数序列</h2><p>输入一个正整数 <code>target</code>，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：target = 9</p><p>输出：[[2,3,4],[4,5]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：target = 15</p><p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote><p>限制：</p><blockquote><p>1 &lt;= target &lt;= 10^5</p></blockquote><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口可以看成数组中框起来的一部分，我们可以用滑动窗口来观察可能的结果，当滑动窗口从数组的左边滑倒了右边，就可以得到所有可能的结果。</p><p>设窗口左边界为i，右边界为j，则滑动窗口是<code>[i,j)</code>，设窗口的和为<code>sum</code>。</p><ul><li>当<code>sum&gt;target</code>时，窗口的和需要减小，所以要缩小窗口，左边界右移，即<code>i++</code></li><li>当<code>sum&lt;target</code>时，窗口的和需要增大，所以要增大窗口，右边界右移，即<code>j++</code></li><li>当<code>sum==target</code>时，记录结果，接下来找<code>i+1</code>开头的序列，所以·<code>sum-=i,i++</code></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">         List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//左窗口</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">//右窗口</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;(target-<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;target)&#123;</span><br><span class="line">                sum-=i;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;<span class="keyword">if</span> (sum&lt;target)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum==target)&#123;</span><br><span class="line">                <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k =i;k&lt;j;k++)&#123;</span><br><span class="line">                    arr[k-i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题57-II-和为s的连续正数序列&quot;&gt;&lt;a href=&quot;#Leetcode面试题57-II-和为s的连续正数序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题57-II.和为s的连续正数序列&quot;&gt;&lt;/a&gt;Leetcode面试题57-II.和为s的连续正数序列&lt;/h2&gt;&lt;p&gt;输入一个正整数 &lt;code&gt;target&lt;/code&gt;，输出所有和为 &lt;code&gt;target&lt;/code&gt; 的连续正整数序列（至少含有两个数）。&lt;/p&gt;
&lt;p&gt;序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题 10.01.合并排序的数组</title>
    <link href="http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-03-14T05:00:04.000Z</published>
    <updated>2020-03-14T07:51:53.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题-10-01-合并排序的数组"><a href="#Leetcode面试题-10-01-合并排序的数组" class="headerlink" title="Leetcode面试题 10.01.合并排序的数组"></a>Leetcode面试题 10.01.合并排序的数组</h2><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例:</p><blockquote><p>输入:</p><p>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p></blockquote><p>说明:</p><blockquote><p>A.length == n + m</p></blockquote><p><strong>思路：双指针法，利用数组已经排序的性质，将两个数组看成队列，每次从两个数组头部取出较小的数字放入结果中。代码实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x,y为数组A，B的指针</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将A复制到t中</span></span><br><span class="line">        <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            t[j]=A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次从B和t头部取出较小的数字放入A中，直至有一个数组全部取出后将另一个数组接到A的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (x&lt;m||y&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x==m)&#123;</span><br><span class="line">               A[i++] = B[y++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (y==n)&#123;</span><br><span class="line">                  A[i++] = t[x++];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (t[x]&lt;B[y])&#123;</span><br><span class="line">                    A[i++] = t[x++];</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                   A[i++] = B[y++];</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题-10-01-合并排序的数组&quot;&gt;&lt;a href=&quot;#Leetcode面试题-10-01-合并排序的数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题 10.01.合并排序的数组&quot;&gt;&lt;/a&gt;Leetcode面试题 10.01.合并排序的数组&lt;/h2&gt;&lt;p&gt;给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。&lt;/p&gt;
&lt;p&gt;初始化 A 和 B 的元素数量分别为 m 和 n。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sorted-merge-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1071.字符串的最大公因子</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</id>
    <published>2020-03-12T08:16:25.000Z</published>
    <updated>2020-03-14T07:51:34.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1071-字符串的最大公因子"><a href="#Leetcode1071-字符串的最大公因子" class="headerlink" title="Leetcode1071.字符串的最大公因子"></a>Leetcode1071.字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：str1 = “ABCABC”, str2 = “ABC”</p><p>输出：”ABC”</p></blockquote><p>示例 2：</p><blockquote><p>输入：str1 = “ABABAB”, str2 = “ABAB”</p><p>输出：”AB”</p></blockquote><p>示例 3：</p><blockquote><p>输入：str1 = “LEET”, str2 = “CODE”</p><p>输出：””</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= str1.length &lt;= 1000</p><p>1 &lt;= str2.length &lt;= 1000<br>str1[i] 和 str2[i] 为大写英文字母</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(str1+str2).equals(str2+str1)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">        <span class="comment">//最大公约数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(len1,len2);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (len1%i==<span class="number">0</span> &amp;&amp; len2%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//最大公约数对应子串</span></span><br><span class="line">                String x = str1.substring(<span class="number">0</span>,i);</span><br><span class="line">                <span class="keyword">int</span> lenx = x.length();</span><br><span class="line">                <span class="comment">//判断相加len/lenx次后是否与str1和str2相等</span></span><br><span class="line">                <span class="keyword">int</span> x1 = len1 / lenx;</span><br><span class="line">                <span class="keyword">int</span> x2 = len2 / lenx;</span><br><span class="line">                String temp1 = <span class="string">""</span>;</span><br><span class="line">                String temp2 = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (x1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    temp1 = temp1+ x;</span><br><span class="line">                    x1--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (x2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    temp2 +=x;</span><br><span class="line">                    x2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最大公因子只可能是最大公约数时取得，若相等则返回，否则为空</span></span><br><span class="line">                <span class="keyword">if</span> (temp1.equals(str1) &amp;&amp;temp2.equals(str2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1071-字符串的最大公因子&quot;&gt;&lt;a href=&quot;#Leetcode1071-字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1071.字符串的最大公因子&quot;&gt;&lt;/a&gt;Leetcode1071.字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。&lt;/p&gt;
&lt;p&gt;返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/greatest-common-divisor-of-strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode402.移掉K位数字</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</id>
    <published>2020-03-12T06:26:44.000Z</published>
    <updated>2020-03-14T07:50:53.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode402-移掉K位数字"><a href="#Leetcode402-移掉K位数字" class="headerlink" title="Leetcode402.移掉K位数字"></a>Leetcode402.移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。</p><p>num 不会包含任何前导零。</p><p><a href="https://leetcode-cn.com/problems/remove-k-digits" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1 :</p><blockquote><p>输入: num = “1432219”, k = 3</p><p>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p></blockquote><p>示例 2 :</p><blockquote><p>输入: num = “10200”, k = 1</p><p>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p></blockquote><p>示例 3 :</p><blockquote><p>输入: num = “10”, k = 2</p><p>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:num.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//利用了&amp;&amp;的截断，避免了栈中首个元素peek时为空</span></span><br><span class="line">            <span class="keyword">while</span> (k&gt;<span class="number">0</span>  &amp;&amp; stack.size()&gt;<span class="number">0</span> &amp;&amp; stack.peekLast()&gt;c)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止递增数列情况，除去末尾的大数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;k;i++)&#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//除去前导零</span></span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : stack)&#123;</span><br><span class="line">            <span class="keyword">if</span> (leadingZero &amp;&amp; c==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈为空时返回0</span></span><br><span class="line">        <span class="keyword">if</span> (ret.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>思路</p><p><strong>1. 给定一个数字序列[D1 D2 D3…Dn]，如果数字D2小于其左邻居D1，则我们应该删除左邻居(D1)，以获得最小结果。对于每个数字，如果该数字小于栈顶元素，即该数字的左邻居，则弹出堆栈，即删除左邻居，否则推入堆栈。重复上述步骤，直至堆栈为空或者已经删除K位数字。</strong></p><p><strong>2.但对于某些情况，规则对任意数字都不适用，即单调递增数列，对此我们只需要删除末尾数字即可。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode402-移掉K位数字&quot;&gt;&lt;a href=&quot;#Leetcode402-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;Leetcode402.移掉K位数字&quot;&gt;&lt;/a&gt;Leetcode402.移掉K位数字&lt;/h2&gt;&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;num 的长度小于 10002 且 ≥ k。&lt;/p&gt;
&lt;p&gt;num 不会包含任何前导零。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1047.删除字符串中的所有相邻重复项</title>
    <link href="http://yoursite.com/2020/03/11/Leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2020/03/11/Leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2020-03-11T08:58:54.000Z</published>
    <updated>2020-03-14T07:51:12.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1047-删除字符串中的所有相邻重复项"><a href="#Leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="Leetcode1047.删除字符串中的所有相邻重复项"></a>Leetcode1047.删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p> <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p><p>提示：</p><blockquote><p>1 &lt;= S.length &lt;= 20000</p><p>S 仅由小写英文字母组成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//S为空时</span></span><br><span class="line">        <span class="keyword">if</span> (S.equals(<span class="string">""</span>)||S ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第一个元素入栈，防止出现StackEmpty错误</span></span><br><span class="line">        stack.push(S.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">            <span class="comment">//逐个遍历，与栈顶元素相同则出栈，不同就入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp;c==((<span class="keyword">char</span>)stack.peek()))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转化为String格式</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:stack)&#123;</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1047-删除字符串中的所有相邻重复项&quot;&gt;&lt;a href=&quot;#Leetcode1047-删除字符串中的所有相邻重复项&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1047.删除字符串中的所有相邻重复项&quot;&gt;&lt;/a&gt;Leetcode1047.删除字符串中的所有相邻重复项&lt;/h2&gt;&lt;p&gt;给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。&lt;/p&gt;
&lt;p&gt;在 S 上反复执行重复项删除操作，直到无法继续删除。&lt;/p&gt;
&lt;p&gt;在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
</feed>
