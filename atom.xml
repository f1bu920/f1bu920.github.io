<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flbu blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-18T03:25:14.569Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flbu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode836.矩形重叠</title>
    <link href="http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
    <id>http://yoursite.com/2020/03/18/Leetcode836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</id>
    <published>2020-03-18T03:20:22.000Z</published>
    <updated>2020-03-18T03:25:14.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode836-矩形重叠"><a href="#Leetcode836-矩形重叠" class="headerlink" title="Leetcode836.矩形重叠"></a>Leetcode836.矩形重叠</h2><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p> <a href="https://leetcode-cn.com/problems/rectangle-overlap" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</p><p>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</p><p>输出：false</p></blockquote><p>提示：</p><blockquote><p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</p><p>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p></blockquote><ul><li><p>思路</p><p>判断两个矩形是否重叠只需判断以下几种情况</p><ul><li>矩形1在矩形2上方</li><li>矩形1在矩形2下方</li><li>矩形1在矩形2左边</li><li>矩形1在矩形2右边</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">0</span>]&gt;=rec2[<span class="number">2</span>]||rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>]||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode836-矩形重叠&quot;&gt;&lt;a href=&quot;#Leetcode836-矩形重叠&quot; class=&quot;headerlink&quot; title=&quot;Leetcode836.矩形重叠&quot;&gt;&lt;/a&gt;Leetcode836.矩形重叠&lt;/h2&gt;&lt;p&gt;矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。&lt;/p&gt;
&lt;p&gt;如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。&lt;/p&gt;
&lt;p&gt;给出两个矩形，判断它们是否重叠并返回结果。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rectangle-overlap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode面试题01.06.字符串压缩</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-03-17T07:27:00.000Z</published>
    <updated>2020-03-17T07:59:44.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题01-06-字符串压缩"><a href="#Leetcode面试题01-06-字符串压缩" class="headerlink" title="Leetcode面试题01.06.字符串压缩"></a>Leetcode面试题01.06.字符串压缩</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p><a href="https://leetcode-cn.com/problems/compress-string-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例1:</p><blockquote><p>输入：”aabcccccaaa”</p><p>输出：”a2b1c5a3”</p></blockquote><p>示例2:</p><blockquote><p>输入：”abbccd”</p><p>输出：”abbccd”<br>解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。</p></blockquote><p>提示：</p><blockquote><p>字符串长度在[0, 50000]范围内。</p></blockquote><ul><li><p>思路</p><p>利用双指针可以很快速的得到结果，不能用哈希表，因为会有前后出现一样字母的可能，例<code>aabcccccaaa</code></p><p>使用<code>StringBuilder</code>可以消耗少量内存构建字符串。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenS = S.length();</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; lenS &amp;&amp; S.charAt(i) == S.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(S.charAt(i));</span><br><span class="line">        stringBuilder.append(j - i);</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (lenS &lt;= stringBuilder.length()) ? S : stringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题01-06-字符串压缩&quot;&gt;&lt;a href=&quot;#Leetcode面试题01-06-字符串压缩&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题01.06.字符串压缩&quot;&gt;&lt;/a&gt;Leetcode面试题01.06.字符串压缩&lt;/h2&gt;&lt;p&gt;字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/compress-string-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1160.拼写单词</title>
    <link href="http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/03/17/Leetcode1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</id>
    <published>2020-03-17T07:08:55.000Z</published>
    <updated>2020-03-17T07:19:08.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1160-拼写单词"><a href="#Leetcode1160-拼写单词" class="headerlink" title="Leetcode1160.拼写单词"></a>Leetcode1160.拼写单词</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p> <a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”</p><p>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。</p></blockquote><p>示例 2：</p><blockquote><p>输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”</p><p>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= words.length &lt;= 1000</p><p>1 &lt;= words[i].length, chars.length &lt;= 100<br>所有字符串中都仅包含小写英文字母</p></blockquote><ul><li><p>思路</p><p>很明显可以利用哈希表来做，统计mapChar是否覆盖mapWord。</p><p>也可以统计26个字母出现次数来判断。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">int</span> lenSum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; mapWord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; mapChar = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mapChar.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = mapChar.get(c);</span><br><span class="line">                mapChar.put(c, t + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapChar.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (mapWord.containsKey(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = mapWord.get(c);</span><br><span class="line">                    mapWord.put(c, t + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mapWord.put(c, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : mapWord.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">char</span> ck = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (!(mapChar.containsKey(ck) &amp;&amp; entry.getValue() &lt;= mapChar.get(ck))) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lenSum += (flag == <span class="keyword">true</span>) ? word.length() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//记得每次遍历完一次word后要把mapWord清空</span></span><br><span class="line">            mapWord.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1160-拼写单词&quot;&gt;&lt;a href=&quot;#Leetcode1160-拼写单词&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1160.拼写单词&quot;&gt;&lt;/a&gt;Leetcode1160.拼写单词&lt;/h2&gt;&lt;p&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1013.将数组分成相等的三个部分</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-16T09:05:38.000Z</published>
    <updated>2020-03-16T09:10:30.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1013-将数组分成相等的三个部分"><a href="#Leetcode1013-将数组分成相等的三个部分" class="headerlink" title="Leetcode1013.将数组分成相等的三个部分"></a>Leetcode1013.将数组分成相等的三个部分</h2><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p><p>形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。</p><p> <a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]</p><p>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]</p><p>输出：false</p></blockquote><p>示例 3：</p><blockquote><p>输入：[3,3,6,5,-2,2,5,1,-9,4]</p><p>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p></blockquote><p>提示：</p><blockquote><p>3 &lt;= A.length &lt;= 50000</p><p>-10^4 &lt;= A[i] &lt;= 10^4</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum%<span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">                temp += A[i];</span><br><span class="line">                <span class="keyword">if</span>(temp==target)&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//防止[1,-1,1,-1,1,-1,1,-1]的情况下time&gt;3</span></span><br><span class="line">        <span class="keyword">return</span> time&gt;=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1013-将数组分成相等的三个部分&quot;&gt;&lt;a href=&quot;#Leetcode1013-将数组分成相等的三个部分&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1013.将数组分成相等的三个部分&quot;&gt;&lt;/a&gt;Leetcode1013.将数组分成相等的三个部分&lt;/h2&gt;&lt;p&gt;给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。&lt;/p&gt;
&lt;p&gt;形式上，如果可以找出索引 i+1 &amp;lt; j 且满足 (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1]) 就可以将数组三等分。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode994.腐烂的橘子</title>
    <link href="http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/16/Leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-16T07:57:37.000Z</published>
    <updated>2020-03-16T08:10:49.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode994-腐烂的橘子"><a href="#Leetcode994-腐烂的橘子" class="headerlink" title="Leetcode994.腐烂的橘子"></a>Leetcode994.腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p> <a href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：[[2,1,1],[1,1,0],[0,1,1]]</p><p>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：[[2,1,1],[0,1,1],[1,0,1]]</p><p>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p></blockquote><p>示例 3：</p><blockquote><p>输入：[[0,2]]</p><p>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= grid.length &lt;= 10</p><p>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] 仅为 0、1 或 2</p></blockquote><ul><li><p>思路</p><p>第一天将所有的烂橘子入队列，然后按天数依次腐烂，新腐烂的橘子入队列，记录天数。然后判断是否还有没腐烂的橘子。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照上左下右的顺序腐烂</span></span><br><span class="line">    <span class="keyword">int</span>[] tr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] tc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = grid.length;</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        Queue&lt;Integer&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> C = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//存储天数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; depth = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第0天所有腐烂的橘子入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//转换为单数组</span></span><br><span class="line">                    <span class="keyword">int</span> code = r * C + c;</span><br><span class="line">                    arrayDeque.add(code);</span><br><span class="line">                    depth.put(code, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!arrayDeque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> code = arrayDeque.remove();</span><br><span class="line">            <span class="keyword">int</span> r = code / C, c = code % C;</span><br><span class="line">            <span class="comment">//按上左下右顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = r + tr[k];</span><br><span class="line">                <span class="keyword">int</span> nc = c + tc[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> ncode = nr * C + nc;</span><br><span class="line">                    arrayDeque.add(ncode);</span><br><span class="line">                    depth.put(ncode, depth.get(code) + <span class="number">1</span>);</span><br><span class="line">                    ret = depth.get(ncode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断是否还有新鲜的橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col : row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode994-腐烂的橘子&quot;&gt;&lt;a href=&quot;#Leetcode994-腐烂的橘子&quot; class=&quot;headerlink&quot; title=&quot;Leetcode994.腐烂的橘子&quot;&gt;&lt;/a&gt;Leetcode994.腐烂的橘子&lt;/h2&gt;&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;p&gt;值 0 代表空单元格；&lt;br&gt;值 1 代表新鲜橘子；&lt;br&gt;值 2 代表腐烂的橘子。&lt;br&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p&gt;
&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rotting-oranges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode169.多数元素</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2020-03-15T10:09:55.000Z</published>
    <updated>2020-03-15T10:36:46.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode169-多数元素"><a href="#LeetCode169-多数元素" class="headerlink" title="LeetCode169.多数元素"></a>LeetCode169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><a href="https://leetcode-cn.com/problems/majority-element" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [3,2,3]</p><p>输出: 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: [2,2,1,1,1,2,2]</p><p>输出: 2</p></blockquote><h4 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(num))&#123;</span><br><span class="line">               map.put(num,<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Map.Entry&lt;Integer,Integer&gt; majorityEntry = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">           <span class="keyword">if</span> (majorityEntry == <span class="keyword">null</span>||entry.getValue()&gt;majorityEntry.getValue())&#123;</span><br><span class="line">               majorityEntry = entry;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二：排序"><a href="#解法二：排序" class="headerlink" title="解法二：排序"></a>解法二：排序</h4><p>因为题中说明了众数数目多余n/2，所以排序后n/2处一定为众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="解法三：投票算法"><a href="#解法三：投票算法" class="headerlink" title="解法三：投票算法"></a>解法三：投票算法</h3><ul><li><p>思路</p><p>如果我们把众数记为1，其他数记为-1，全部加起来后，显然和大于0.</p></li><li><p>算法</p><ul><li>我们先维护一个候选众数<code>candidate</code>和它出现的次数<code>count</code>，初始时<code>candidate</code>为任意值，<code>count</code>为0.</li><li>遍历数组元素，对于每个出现的元素<code>num</code>，如果判断<code>num</code>之前，<code>count</code>为0，将<code>num</code>的值赋给<code>candidate</code>。然后进行如下判断：<ul><li>若<code>num</code>与<code>candidate</code>相等，则<code>count++</code></li><li>如果<code>num</code>与<code>candidate</code>不等，则<code>count--</code></li></ul></li><li>遍历完成后，<code>candidate</code>即为众数</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//投票算法</span></span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span> )&#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count+=num==candidate? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode169-多数元素&quot;&gt;&lt;a href=&quot;#LeetCode169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode169.多数元素&quot;&gt;&lt;/a&gt;LeetCode169.多数元素&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode121.买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/03/15/Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/03/15/Leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-03-15T08:00:47.000Z</published>
    <updated>2020-03-15T08:31:34.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode121-买卖股票的最佳时机"><a href="#Leetcode121-买卖股票的最佳时机" class="headerlink" title="Leetcode121.买卖股票的最佳时机"></a>Leetcode121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">题目链接</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">一个非常牛逼的大佬的解法</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [7,1,5,3,6,4]</p><p>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [7,6,4,3,1]</p><p>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录最大利润</span></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&lt;minPrice)&#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i]-minPrice&gt;maxProfit)&#123;</span><br><span class="line">                    maxProfit = prices[i] - minPrice;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#Leetcode121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;Leetcode121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;Leetcode121.买卖股票的最佳时机&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个非常牛逼的大佬的解法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题57-II.和为s的连续正数序列</title>
    <link href="http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9857-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9857-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-14T07:27:59.000Z</published>
    <updated>2020-03-14T07:49:55.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题57-II-和为s的连续正数序列"><a href="#Leetcode面试题57-II-和为s的连续正数序列" class="headerlink" title="Leetcode面试题57-II.和为s的连续正数序列"></a>Leetcode面试题57-II.和为s的连续正数序列</h2><p>输入一个正整数 <code>target</code>，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：target = 9</p><p>输出：[[2,3,4],[4,5]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：target = 15</p><p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote><p>限制：</p><blockquote><p>1 &lt;= target &lt;= 10^5</p></blockquote><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口可以看成数组中框起来的一部分，我们可以用滑动窗口来观察可能的结果，当滑动窗口从数组的左边滑倒了右边，就可以得到所有可能的结果。</p><p>设窗口左边界为i，右边界为j，则滑动窗口是<code>[i,j)</code>，设窗口的和为<code>sum</code>。</p><ul><li>当<code>sum&gt;target</code>时，窗口的和需要减小，所以要缩小窗口，左边界右移，即<code>i++</code></li><li>当<code>sum&lt;target</code>时，窗口的和需要增大，所以要增大窗口，右边界右移，即<code>j++</code></li><li>当<code>sum==target</code>时，记录结果，接下来找<code>i+1</code>开头的序列，所以·<code>sum-=i,i++</code></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">         List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//左窗口</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">//右窗口</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;(target-<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;target)&#123;</span><br><span class="line">                sum-=i;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;<span class="keyword">if</span> (sum&lt;target)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum==target)&#123;</span><br><span class="line">                <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k =i;k&lt;j;k++)&#123;</span><br><span class="line">                    arr[k-i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                sum-=i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题57-II-和为s的连续正数序列&quot;&gt;&lt;a href=&quot;#Leetcode面试题57-II-和为s的连续正数序列&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题57-II.和为s的连续正数序列&quot;&gt;&lt;/a&gt;Leetcode面试题57-II.和为s的连续正数序列&lt;/h2&gt;&lt;p&gt;输入一个正整数 &lt;code&gt;target&lt;/code&gt;，输出所有和为 &lt;code&gt;target&lt;/code&gt; 的连续正整数序列（至少含有两个数）。&lt;/p&gt;
&lt;p&gt;序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题 10.01.合并排序的数组</title>
    <link href="http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/03/14/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%98-10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-03-14T05:00:04.000Z</published>
    <updated>2020-03-14T07:51:53.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题-10-01-合并排序的数组"><a href="#Leetcode面试题-10-01-合并排序的数组" class="headerlink" title="Leetcode面试题 10.01.合并排序的数组"></a>Leetcode面试题 10.01.合并排序的数组</h2><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例:</p><blockquote><p>输入:</p><p>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p></blockquote><p>说明:</p><blockquote><p>A.length == n + m</p></blockquote><p><strong>思路：双指针法，利用数组已经排序的性质，将两个数组看成队列，每次从两个数组头部取出较小的数字放入结果中。代码实现如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x,y为数组A，B的指针</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将A复制到t中</span></span><br><span class="line">        <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            t[j]=A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次从B和t头部取出较小的数字放入A中，直至有一个数组全部取出后将另一个数组接到A的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (x&lt;m||y&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x==m)&#123;</span><br><span class="line">               A[i++] = B[y++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (y==n)&#123;</span><br><span class="line">                  A[i++] = t[x++];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (t[x]&lt;B[y])&#123;</span><br><span class="line">                    A[i++] = t[x++];</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                   A[i++] = B[y++];</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题-10-01-合并排序的数组&quot;&gt;&lt;a href=&quot;#Leetcode面试题-10-01-合并排序的数组&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题 10.01.合并排序的数组&quot;&gt;&lt;/a&gt;Leetcode面试题 10.01.合并排序的数组&lt;/h2&gt;&lt;p&gt;给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。&lt;/p&gt;
&lt;p&gt;初始化 A 和 B 的元素数量分别为 m 和 n。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sorted-merge-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1071.字符串的最大公因子</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</id>
    <published>2020-03-12T08:16:25.000Z</published>
    <updated>2020-03-14T07:51:34.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1071-字符串的最大公因子"><a href="#Leetcode1071-字符串的最大公因子" class="headerlink" title="Leetcode1071.字符串的最大公因子"></a>Leetcode1071.字符串的最大公因子</h2><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：str1 = “ABCABC”, str2 = “ABC”</p><p>输出：”ABC”</p></blockquote><p>示例 2：</p><blockquote><p>输入：str1 = “ABABAB”, str2 = “ABAB”</p><p>输出：”AB”</p></blockquote><p>示例 3：</p><blockquote><p>输入：str1 = “LEET”, str2 = “CODE”</p><p>输出：””</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= str1.length &lt;= 1000</p><p>1 &lt;= str2.length &lt;= 1000<br>str1[i] 和 str2[i] 为大写英文字母</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(str1+str2).equals(str2+str1)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">        <span class="comment">//最大公约数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(len1,len2);i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (len1%i==<span class="number">0</span> &amp;&amp; len2%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//最大公约数对应子串</span></span><br><span class="line">                String x = str1.substring(<span class="number">0</span>,i);</span><br><span class="line">                <span class="keyword">int</span> lenx = x.length();</span><br><span class="line">                <span class="comment">//判断相加len/lenx次后是否与str1和str2相等</span></span><br><span class="line">                <span class="keyword">int</span> x1 = len1 / lenx;</span><br><span class="line">                <span class="keyword">int</span> x2 = len2 / lenx;</span><br><span class="line">                String temp1 = <span class="string">""</span>;</span><br><span class="line">                String temp2 = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (x1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    temp1 = temp1+ x;</span><br><span class="line">                    x1--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (x2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    temp2 +=x;</span><br><span class="line">                    x2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最大公因子只可能是最大公约数时取得，若相等则返回，否则为空</span></span><br><span class="line">                <span class="keyword">if</span> (temp1.equals(str1) &amp;&amp;temp2.equals(str2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1071-字符串的最大公因子&quot;&gt;&lt;a href=&quot;#Leetcode1071-字符串的最大公因子&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1071.字符串的最大公因子&quot;&gt;&lt;/a&gt;Leetcode1071.字符串的最大公因子&lt;/h2&gt;&lt;p&gt;对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。&lt;/p&gt;
&lt;p&gt;返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/greatest-common-divisor-of-strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode402.移掉K位数字</title>
    <link href="http://yoursite.com/2020/03/12/Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/12/Leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</id>
    <published>2020-03-12T06:26:44.000Z</published>
    <updated>2020-03-14T07:50:53.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode402-移掉K位数字"><a href="#Leetcode402-移掉K位数字" class="headerlink" title="Leetcode402.移掉K位数字"></a>Leetcode402.移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。</p><p>num 不会包含任何前导零。</p><p><a href="https://leetcode-cn.com/problems/remove-k-digits" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1 :</p><blockquote><p>输入: num = “1432219”, k = 3</p><p>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p></blockquote><p>示例 2 :</p><blockquote><p>输入: num = “10200”, k = 1</p><p>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p></blockquote><p>示例 3 :</p><blockquote><p>输入: num = “10”, k = 2</p><p>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:num.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//利用了&amp;&amp;的截断，避免了栈中首个元素peek时为空</span></span><br><span class="line">            <span class="keyword">while</span> (k&gt;<span class="number">0</span>  &amp;&amp; stack.size()&gt;<span class="number">0</span> &amp;&amp; stack.peekLast()&gt;c)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止递增数列情况，除去末尾的大数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;k;i++)&#123;</span><br><span class="line">            stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//除去前导零</span></span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : stack)&#123;</span><br><span class="line">            <span class="keyword">if</span> (leadingZero &amp;&amp; c==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈为空时返回0</span></span><br><span class="line">        <span class="keyword">if</span> (ret.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>思路</p><p><strong>1. 给定一个数字序列[D1 D2 D3…Dn]，如果数字D2小于其左邻居D1，则我们应该删除左邻居(D1)，以获得最小结果。对于每个数字，如果该数字小于栈顶元素，即该数字的左邻居，则弹出堆栈，即删除左邻居，否则推入堆栈。重复上述步骤，直至堆栈为空或者已经删除K位数字。</strong></p><p><strong>2.但对于某些情况，规则对任意数字都不适用，即单调递增数列，对此我们只需要删除末尾数字即可。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode402-移掉K位数字&quot;&gt;&lt;a href=&quot;#Leetcode402-移掉K位数字&quot; class=&quot;headerlink&quot; title=&quot;Leetcode402.移掉K位数字&quot;&gt;&lt;/a&gt;Leetcode402.移掉K位数字&lt;/h2&gt;&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;num 的长度小于 10002 且 ≥ k。&lt;/p&gt;
&lt;p&gt;num 不会包含任何前导零。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-k-digits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode1047.删除字符串中的所有相邻重复项</title>
    <link href="http://yoursite.com/2020/03/11/Leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2020/03/11/Leetcode1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2020-03-11T08:58:54.000Z</published>
    <updated>2020-03-14T07:51:12.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode1047-删除字符串中的所有相邻重复项"><a href="#Leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="Leetcode1047.删除字符串中的所有相邻重复项"></a>Leetcode1047.删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p> <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p><p>提示：</p><blockquote><p>1 &lt;= S.length &lt;= 20000</p><p>S 仅由小写英文字母组成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//S为空时</span></span><br><span class="line">        <span class="keyword">if</span> (S.equals(<span class="string">""</span>)||S ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第一个元素入栈，防止出现StackEmpty错误</span></span><br><span class="line">        stack.push(S.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">            <span class="comment">//逐个遍历，与栈顶元素相同则出栈，不同就入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp;c==((<span class="keyword">char</span>)stack.peek()))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转化为String格式</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:stack)&#123;</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode1047-删除字符串中的所有相邻重复项&quot;&gt;&lt;a href=&quot;#Leetcode1047-删除字符串中的所有相邻重复项&quot; class=&quot;headerlink&quot; title=&quot;Leetcode1047.删除字符串中的所有相邻重复项&quot;&gt;&lt;/a&gt;Leetcode1047.删除字符串中的所有相邻重复项&lt;/h2&gt;&lt;p&gt;给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。&lt;/p&gt;
&lt;p&gt;在 S 上反复执行重复项删除操作，直到无法继续删除。&lt;/p&gt;
&lt;p&gt;在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>JSP笔记</title>
    <link href="http://yoursite.com/2020/03/11/JSP%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/11/JSP%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-11T07:59:23.000Z</published>
    <updated>2020-03-11T08:01:06.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>jsp是一个简化的Servlet设计，实现了在Java中使用HTML标签。Jsp是一种动态网页技术标准也是javaee的标准。Jsp与Servlet一样，是在服务器端执行的。</p><a id="more"></a><h2 id="Jsp页面元素构成"><a href="#Jsp页面元素构成" class="headerlink" title="Jsp页面元素构成"></a>Jsp页面元素构成</h2><p>静态内容、指令、表达式、小脚本、声明、注释</p><h4 id="Jsp指令"><a href="#Jsp指令" class="headerlink" title="Jsp指令"></a>Jsp指令</h4><ul><li><p>page指令：通常位于jsp页面顶端，同一个页面可以有多个page指令</p><p><strong>page指令语法：&lt;%@ page 属性1=“属性值“ 属性2=”属性值2“ …%&gt;</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">language</td><td align="center">指定JSP页面使用的脚本语言</td><td align="center">java</td></tr><tr><td align="center">import</td><td align="center">通过该属性引用脚本语言中使用到的类文件</td><td align="center">无</td></tr><tr><td align="center">contentType</td><td align="center">用来指定JSP页面所采用的编码方式</td><td align="center">text/html、ISO-8859-1</td></tr></tbody></table></li><li><p>include指令：将一个外部文件嵌入到当前jsp文件中，同时解析这个页面中的jsp语句</p></li><li><p>taglib指令：使用标签库定义新的自定义标签，在JSP页面中启用定制行为</p></li></ul><h4 id="Jsp注释"><a href="#Jsp注释" class="headerlink" title="Jsp注释"></a>Jsp注释</h4><ul><li>html的注释：<!-- html注释-->，客户端可见</li><li>jsp注释：&lt;%– jsp注释–%&gt;，客户端不可见</li><li>jsp脚本注释：// 单行注释，/**/ 多行注释，客户端不可见</li></ul><h4 id="jsp脚本"><a href="#jsp脚本" class="headerlink" title="jsp脚本"></a>jsp脚本</h4><p>在jsp页面中执行的代码</p><p>语法：&lt;% java代码 %&gt;</p><h4 id="jsp声明"><a href="#jsp声明" class="headerlink" title="jsp声明"></a>jsp声明</h4><p>在jsp页面中定义变量和方法</p><p>语法：&lt;%! java代码 %&gt;</p><h4 id="jsp表达式"><a href="#jsp表达式" class="headerlink" title="jsp表达式"></a>jsp表达式</h4><p>在jsp页面中执行的表达式</p><p>语法：&lt;% =表达式 %&gt; <strong>注意：表达式不以分号结束</strong></p><h3 id="jsp页面生命周期"><a href="#jsp页面生命周期" class="headerlink" title="jsp页面生命周期"></a>jsp页面生命周期</h3><p>jspService()方法被调用来处理客户端的请求。对每一个请求，JSP引擎创建一个新的线程来处理该请求。如果有多个客户端同时请求该JSP文件，则JSP引擎会创建多个线程，每个客户端请求对应一个线程。以多线程方式执行可以大大降低对系统的资源要求，提高系统的并发量和响应时间。但也要注意线程的同步问题。</p><h2 id="Jsp内置对象"><a href="#Jsp内置对象" class="headerlink" title="Jsp内置对象"></a>Jsp内置对象</h2><p>九大内置对象：out、request、response、session、application、Page、pageContext、exception、config</p><h4 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a>out对象</h4><p>out对象是JspWriter类的实例，是向客户端输出内容常用的对象，它会通过JSP容器自动转化为java.io.PrintWriter类对象。</p><p>常用方法：</p><ul><li>void println() 向客户端打印字符串</li><li>void clear() 清除缓冲区的内容，如果在flush()之后调用会抛出异常</li><li>void clearBuffer() 清除缓冲区的内容，在flush()之后调用不会抛出异常</li><li>void flush() 将缓冲区内容输出到客户端</li><li>int getBufferSize()，返回返回缓冲区以字节数的大小，如果不设缓冲区则为0</li><li>int getRemaining()，返回缓冲区还剩余多少可用</li><li>boolean isAutoFlush(), 返回缓冲区满时，是自动清空还是抛出异常</li><li>void close()，关闭输出流</li></ul><h4 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h4><p>客户端的请求被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。request对象具有请求域，即在完成客户端的请求之前一直有效。常用方法：</p><ul><li><code>String getParameter(String name)</code>，返回name指定参数的参数值</li><li><code>String[] getParameterValues(String name)</code>，返回包含参数name的所有值的数组</li><li><code>void setAttribute(String,Object)</code>, 存储此请求中的属性</li><li><code>object getAttribute(String name)</code>，返回指定属性的属性值</li><li><code>String getContentType()</code>，得到请求体的MIME类型</li><li><code>String getProtocol()</code>，返回请求用的协议类型和版本号</li><li><code>String getServerName()</code>，返回接受请求的服务器主机名</li><li><code>int getServerPort()</code>，返回服务器接受此请求所用的端口号</li><li><code>String getCharacterEncoding()</code>，返回字节编码方式</li><li><code>void setCharacterEncoding()</code>，设置请求的字节编码方式</li><li><code>int getContentLength()</code>，返回请求体的长度</li><li><code>String getRemoteAddr()</code>，返回发送此请求的客户端IP地址</li><li><code>String getRealPath(String path)</code>，返回一虚拟路径的真实地址</li><li><code>String request.getContextPath</code>，返回上文路径</li></ul><h4 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h4><p>response对象包含了响应客户端请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse的实例。response对象具有页面作用域，即访问一个页面时，该页面内的response对象只能对这次访问有效，其他页面的response对象对当前页面无效。常用方法：</p><ul><li><code>String getCharacterEncoding()</code>，返回响应用的字符编码</li><li><code>void setContentType(String type)</code>，设置响应的MIME类型</li><li><code>PrintWriter getWriter()</code>，返回一个可以向客户端输出字符的一个对象（与内置out对象有区别）<ul><li>PrintWriter类型对象输出总是提前于内置out对象，可以配合flush()方法强制刷新缓冲区</li></ul></li><li><code>sendRedirect(java.lang.String location)</code>，重新定向客户端的请求</li></ul><h4 id="请求转发与请求重定向的区别"><a href="#请求转发与请求重定向的区别" class="headerlink" title="请求转发与请求重定向的区别"></a>请求转发与请求重定向的区别</h4><ul><li>请求重定向：客户端行为，<code>response.sendRedirect(),</code> 从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏url地址会改变</li><li>请求转发：服务器行为，<code>request.getRequestDispatcher().forward(req,resp);</code>是一次请求，转发后请求对象会保存，地址栏的url地址不会改变</li></ul><h3 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a>session对象</h3><p>session对象是一个JSP内置对象，它是HttpSession类的实例。</p><p>session对象在第一个JSP页面被加载时自动创建，完成会话期管理。</p><p>session表示客户端与服务器的一次会话。Web中的session指的是用户在浏览某个网站时从进入网站到浏览器关闭所经过的时间。</p><p>当一个客户访问服务器时，可能在服务器的几个页面之间切换，服务器应当通过某种方法知道是一个客户，就需要session对象。</p><p>在服务器内存中保存着不同用户的session，常见方法：</p><ul><li><code>long getCreationTime()</code>，返回SESSION创建时间</li><li><code>public String getId()</code>，返回session创建时JSP引擎为它创建的唯一id号</li><li><code>public Object setAttribute(String name,Object value)</code>,使用指定名称将对象绑定到此对象</li><li><code>public Object getAttribute(String name)</code>,返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null</li><li><code>String[] getValueNames()</code>,返回一个包含此session中所有可用属性的数组</li><li><code>int getMaxInactiveInterval()</code>, 返回两次请求间隔多长时间此session被取消。</li></ul><h4 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期"></a>session的生命周期</h4><ul><li><p>创建：</p><p>当客户端第一次访问某个JSP或Servlet时，服务器会为当前会话创建一个SessionId，每次客户端向服务端发送请求时，都会将此SessionId带过去，服务端会对此SessionId进行校验</p></li><li><p>活动：</p><ul><li>某次会话中通过超链接打开的新页面属于同一会话</li><li>只要当前会话页面没有全部关闭，重新打开的浏览器窗口访问同一项目资源时属于同一会话</li><li>除非本次会话的所有页面都关闭后重新访问某个Jsp或者Servlet将会创建新的会话</li><li><strong>注意</strong>：<strong>原有会话还存在，只是这个旧的SessionId仍然存在于服务器端，只不过再也没有客户端会携带它交与服务端校验。</strong></li></ul></li><li><p>销毁：</p><p>销毁的三种方式：</p><ol><li>调用了session.invalidate()方法</li><li>Session过期(超时)</li><li>服务器重新启动</li></ol></li><li><p>设置超时时间：</p><p>Tomcat的默认session超时时间为30分钟</p><ol><li><p>session.setMaxInactiveInterval(时间); //秒数</p></li><li><p>在web.xml中设置：</p><blockquote><session-config><session-timeout><p>10</p></session-timeout><p></session-config>  //单位是分钟</p></blockquote></li></ol></li></ul><h4 id="application对象"><a href="#application对象" class="headerlink" title="application对象"></a>application对象</h4><p>application对象实现了用户间数据的共享，可存放全局变量</p><p>application开始于服务器的启动，结束于服务器的关闭</p><p>在用户的前后连接或不同用户的连接中，可以对application对象的同一属性进行操作</p><p>在任何地方对application对象属性的访问都将影响到其他用户对此的访问</p><p>服务器的启动和关闭决定了application对象的生命</p><p>application对象是ServletContext类的实例</p><p>常用方法：</p><ul><li><code>public void setAttribute(String name,Object value)</code>,使用指定名称将对象绑定到此会话</li><li><code>public Object getAttribute(String name)</code>,返回与此会话中指定名称绑定在一起的对象，如果没有则返回null</li><li><code>Enumeration getAttributeNames()</code>，返回所有可用属性名的枚举</li><li><code>String getServerInfo()</code>, 返回JSP引擎名及版本号</li></ul><h4 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a>page对象</h4><p>page对象就是指向当前JSP页面本身，类似类中的this指针，它是java.lang.Object类的实例。常用方法如下：</p><ul><li><code>class getClass()</code>, 返回此Object的类</li><li><code>int hashCode()</code>，返回此Object的hash码</li><li><code>boolean equals(Object obj)</code>，判断此Object与指定的Object是否相等</li><li><code>void copy(Object obj)</code>， 将此Object拷贝到指定的Object中</li><li><code>void clone()</code>，克隆此Object对象</li><li><code>String toString()</code>，将此Object对象转换为String类的对象</li><li><code>void notify()</code>, 唤醒一个等待的线程</li><li><code>void notifyAll()</code>，唤醒所有等待的线程</li><li><code>void wait(int timeout)</code>，使一个线程处于等待直到timeout结束或被唤醒</li><li><code>void wait()</code>，使一个线程处于等待直至被唤醒</li></ul><h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h4><p>pageContext对象提供了对JSP页面内的所有的对象及名字空间的访问</p><p>pageContext可以访问到本页所在的session，也可以取本页面所在的application的某一属性值</p><p>pageContext对象相当于页面中所有功能的集大成者</p><p>pageContext对象的本类名也叫pageContext</p><p>常用方法：</p><ul><li><code>JspWriter getOut()</code>，返回当前客户端响应被使用的JspWriter流（out）</li><li><code>HttpSession getSession()</code>，返回当前页中的HttpSession对象（session）</li><li><code>Object getPage()</code>，返回当前页面的Object对象（page）</li><li><code>ServletRequest getRequest()</code>，返回当前页的ServletRequest对象（request）</li><li><code>ServletResponse getResponse()</code>，返回当前页的ServletResponse对象（response）</li><li><code>void setAttribute(String name,Object attribute)</code>，设置属性及属性值</li><li><code>Object getAttribute(String name,int scope)</code>，在指定范围内取属性值</li><li><code>int getAttributeScope(String name)</code>，返回某属性的作用范围</li><li><code>void forward(String relativeUrLPath)</code>，使当前页面重导到另一页面</li><li><code>void include(String relativeUrlPath)</code>，在当前页面包含另一文件</li></ul><h4 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a>config对象</h4><p>config对象是在一个Servlet初始化时，Jsp引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数(通过属性名和属性值构成)，以及服务器的有关信息(通过传递一个ServletContext对象)，常用方法：</p><ul><li><code>ServletContext getServletContext()</code>, 返回含有服务器信息的ServletContext对象</li><li><code>String getInitParameter(String name)</code>，返回初始化参数的值</li><li><code>Enumeration getInitParameterNames()</code>，返回Servlet初始化所需所有参数的枚举</li></ul><h4 id="exception对象"><a href="#exception对象" class="headerlink" title="exception对象"></a>exception对象</h4><p>exception对象是一个异常对象，当一个页面在运行过程中出现了异常，就产生这个对象。如果一个Jsp页面要引用此对象，就必须把isErrorPage设为true，否则无法编译。实际上是java.lang.Throwable的对象，常用方法：</p><ul><li><code>String getMessage()</code>，返回描述异常的信息</li><li><code>String toString()</code>，返回关于异常的简短描述信息</li><li><code>void printStackTrace()</code>，显示异常及其栈轨迹</li><li><code>Throwable FillInStackTrace()</code>，重写异常的执行栈轨迹</li></ul><h2 id="JavaBean技术"><a href="#JavaBean技术" class="headerlink" title="JavaBean技术"></a>JavaBean技术</h2><h4 id="JavaBean简介及设计原则"><a href="#JavaBean简介及设计原则" class="headerlink" title="JavaBean简介及设计原则"></a>JavaBean简介及设计原则</h4><ul><li>JavaBeans就是符合某种特定规范的java类。使用JavaBeans的好处是解决代码重复编写，减少代码冗余，功能区分明确，提高了代码可维护性。</li><li>设计原则<ol><li>公有类</li><li>无参的共有构造方法</li><li>属性私有</li><li>getter和setter方法</li></ol></li></ul><h4 id="Jsp动作"><a href="#Jsp动作" class="headerlink" title="Jsp动作"></a>Jsp动作</h4><p>Jsp动作元素为请求处理阶段提供信息。动作元素遵循xml元素的语法，有一个包含元素名的开始标签，可以有属性、可选的内容、与开始标签相匹配的结束标签。</p><ul><li><p>第一类是与存取JavaBean有关的：</p><p><code>&lt;jsp:useBean&gt;、&lt;jsp:setProperty&gt;、&lt;jsp:getProperty&gt;</code></p></li><li><p>第二类是6个基本元素：</p><p><code>&lt;jsp:include&gt;、&lt;jsp:forward&gt;、&lt;jsp:param&gt;、&lt;jsp:plugin&gt;、&lt;jsp:params&gt;、&lt;jsp:fallback&gt;</code></p></li><li><p>第三类是与JSP Document有关的：</p><p><code>&lt;jsp:root&gt;、&lt;jsp:declaration&gt;、&lt;jsp:scriptlet&gt;、&lt;jsp:expression&gt;、&lt;jsp:text&gt;、&lt;jsp:output&gt;</code></p></li><li><p>第四类是用来动态生成XML元素标签的值</p><p><code>&lt;jsp:attribute&gt;、&lt;jsp:body&gt;、&lt;jsp:element&gt;</code></p></li><li><p>第五类主要用在Tag File中:</p><p><code>&lt;jsp:invoke&gt;、&lt;jsp:dobody&gt;</code></p></li></ul><h4 id="在Jsp页面中使用JavaBeans"><a href="#在Jsp页面中使用JavaBeans" class="headerlink" title="在Jsp页面中使用JavaBeans"></a>在Jsp页面中使用JavaBeans</h4><ol><li><p>像使用普通java类一样，创建javabean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Users user = <span class="keyword">new</span> Users();</span><br></pre></td></tr></table></figure></li><li><p>在Jsp页面中使用Jsp动作标签使用JavaBean</p><ul><li><p>useBeans动作</p><p>作用：在jsp页面实例化或者在指定范围内使用javabean：</p><p><code>&lt;jsp:useBean id=&quot;标识符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt;</code></p></li><li><p>setProperty动作</p><p>作用：给已经实例化的JavaBeans对象的属性赋值</p><ol><li><code>&lt;jsp:setProperty name=&quot;JavaBean实例名&quot; property=&quot;*&quot;/&gt;</code>(跟表单关联)</li><li><code>&lt;jsp:setProperty name=&quot;JavaBean实例名&quot; property=&quot;JavaBean属性名&quot;/&gt;</code>(跟表单关联)</li><li><code>&lt;jsp:setProperty name=&quot;JavaBean实例名&quot; property=&quot;JavaBean属性名&quot; value=&quot;BeanValue&quot;/&gt;</code>(手工设置)</li><li><code>&lt;jsp:setProperty name=&quot;JavaBean实例名&quot; property=&quot;propertyName&quot; param=&quot;request对象中的参数名&quot;/&gt;</code>(跟request参数相关联)</li></ol></li><li><p>getProperty动作</p><p>作用：获取指定JavaBean对象的属性值</p><p><code>&lt;jsp:getProperty name=&quot;JavaBean实例名&quot; property=&quot;属性名&quot;/&gt;</code></p></li></ul></li></ol><h4 id="JavaBean的四个作用域范围"><a href="#JavaBean的四个作用域范围" class="headerlink" title="JavaBean的四个作用域范围"></a>JavaBean的四个作用域范围</h4><p>说明：<strong>使用useBean的scope属性指定JavaBean的作用范围</strong></p><ul><li>page：只在当前页面有效</li><li>request：可以通过HttpRequest.getAttribute()方法取得JavaBean对象</li><li>session：可以通过HttpSession.getAttribute()方法获得JavaBean对象</li><li>application: 可以通过application.getAttribute()方法取得JavaBean对象</li></ul><h2 id="Jsp状态管理"><a href="#Jsp状态管理" class="headerlink" title="Jsp状态管理"></a>Jsp状态管理</h2><h4 id="http协议无状态性"><a href="#http协议无状态性" class="headerlink" title="http协议无状态性"></a>http协议无状态性</h4><p>无状态是指,当浏览器发送请求给服务器时,服务器响应客户端请求,但当同一个浏览器再次发送请求给服务器时,服务器不知道是刚才的浏览器,这就是无状态协议.</p><h4 id="保存用户状态的两大机制"><a href="#保存用户状态的两大机制" class="headerlink" title="保存用户状态的两大机制"></a>保存用户状态的两大机制</h4><ul><li>Session</li><li>Cookie</li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是Web服务器保存在客户端的文本信息</p><p>Cookie的作用：        </p><ul><li>对特定对象的追踪</li><li>保存用户网页浏览记录与习惯</li><li>简化登录</li></ul><h3 id="JSP中创建与使用Cookie"><a href="#JSP中创建与使用Cookie" class="headerlink" title="JSP中创建与使用Cookie"></a>JSP中创建与使用Cookie</h3><p>创建Cookie对象：</p><p><code>Cookie newCookie = new Cookie(String key,Object value)</code>;</p><p>写入Cookie对象：</p><p><code>response.addCookie(newCookie);</code></p><p>读取Cookie对象：</p><p><code>Cookie[] cookies = request.getCookies();</code></p><ul><li><p>常用方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void setMaxAge(int expiry)</td><td align="center">设置Cookie有效期，以秒为单位</td></tr><tr><td align="center">void setValue(String value)</td><td align="center">Cookie创建后，对其赋值</td></tr><tr><td align="center">String getName()</td><td align="center">获取Cookie名称</td></tr><tr><td align="center">String getValue()</td><td align="center">获取Cookie的值</td></tr><tr><td align="center">int getMaxAge()</td><td align="center">获取Cookie有效时间</td></tr></tbody></table></li></ul><h3 id="Session与Cookie对比"><a href="#Session与Cookie对比" class="headerlink" title="Session与Cookie对比"></a>Session与Cookie对比</h3><table><thead><tr><th align="center">session</th><th align="center">cookie</th></tr></thead><tbody><tr><td align="center">在服务器端保存用户信息</td><td align="center">在客户端保存用户信息</td></tr><tr><td align="center">session中保存的是Object类型</td><td align="center">cookie保存的是String类型</td></tr><tr><td align="center">随会话的结束而将存储的数据销毁</td><td align="center">cookie可以长期保存在客户端</td></tr><tr><td align="center">保存重要的信息</td><td align="center">保存不重要的信息</td></tr></tbody></table><h2 id="指令与动作"><a href="#指令与动作" class="headerlink" title="指令与动作"></a>指令与动作</h2><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><ul><li>语法：&lt;%@ include file=”URL” %&gt;</li></ul><h4 id="include动作"><a href="#include动作" class="headerlink" title="include动作"></a>include动作</h4><ul><li>语法：&lt;jsp:include page=”URL” flush=”true|false”  /&gt;<ul><li>page：要包含的页面</li><li>flush：被包含的页面是否从缓冲区读取</li></ul></li></ul><h4 id="include指令与include动作的区别"><a href="#include指令与include动作的区别" class="headerlink" title="include指令与include动作的区别"></a>include指令与include动作的区别</h4><table><thead><tr><th align="center"></th><th align="center">include指令</th><th align="center">include动作</th></tr></thead><tbody><tr><td align="center">语法格式</td><td align="center">&lt;%@ include file=””%&gt;</td><td align="center">&lt;jsp:include page=”…” flush=”true|false” /&gt;</td></tr><tr><td align="center">发生作用的时间</td><td align="center">页面转换期间</td><td align="center">请求期间</td></tr><tr><td align="center">包含的内容</td><td align="center">文件的实际内容</td><td align="center">页面的输出</td></tr><tr><td align="center">转换成的Servlet</td><td align="center">主页面和包含页面转换成一个Servlet</td><td align="center">主页面和包含页面转换成独立的Servlet</td></tr><tr><td align="center">编译时间</td><td align="center">较慢—资源必须被解析</td><td align="center">较快</td></tr><tr><td align="center">执行时间</td><td align="center">稍快</td><td align="center">稍慢—每次资源必须被解析</td></tr></tbody></table><h4 id="forward动作"><a href="#forward动作" class="headerlink" title="forward动作"></a>forward动作</h4><ul><li><p>语法</p><p><code>&lt;jsp:forword page=&quot;url&quot;/&gt;</code></p><p>等同于：<code>request.getRequestDispatcher(&quot;/url&quot;).forward(request,response);</code></p></li></ul><h4 id="param动作"><a href="#param动作" class="headerlink" title="param动作"></a>param动作</h4><ul><li><p>语法：</p><p><code>&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;</code></p><p>常与&lt;jsp: forward&gt;连用，作为其子标签</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; title=&quot;JSP&quot;&gt;&lt;/a&gt;JSP&lt;/h1&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;jsp是一个简化的Servlet设计，实现了在Java中使用HTML标签。Jsp是一种动态网页技术标准也是javaee的标准。Jsp与Servlet一样，是在服务器端执行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jsp" scheme="http://yoursite.com/categories/Jsp/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode20.有效的括号</title>
    <link href="http://yoursite.com/2020/03/11/Leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2020/03/11/Leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</id>
    <published>2020-03-11T07:21:57.000Z</published>
    <updated>2020-03-14T07:49:25.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode20-有效的括号"><a href="#Leetcode20-有效的括号" class="headerlink" title="Leetcode20.有效的括号"></a>Leetcode20.有效的括号</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目链接</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p>示例 1:</p><p>输入: </p><blockquote><p>“()”</p></blockquote><p>输出: </p><blockquote><p>true</p></blockquote><p>示例 2:</p><p>输入: </p><blockquote><p>“()[]{}”</p></blockquote><p>输出:</p><blockquote><p>true</p></blockquote><p>示例 3:</p><p>输入:</p><blockquote><p>“(]”</p></blockquote><p>输出:</p><blockquote><p>false</p></blockquote><p>示例 4:</p><p>输入:</p><blockquote><p>“([)]”</p></blockquote><p>输出:</p><blockquote><p>false</p></blockquote><p>示例 5:</p><p>输入: </p><blockquote><p>“{[]}”</p></blockquote><p>输出:</p><blockquote><p>true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>)||s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造栈</span></span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>||c==<span class="string">'['</span>||c==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右括号</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//排除右括号入栈时栈空情况，例："]"</span></span><br><span class="line">                 <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">')'</span>&amp;&amp;((Character)stack.pop())!=<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">']'</span>&amp;&amp;((Character)stack.pop())!=<span class="string">'['</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">'&#125;'</span>&amp;&amp;((Character)stack.pop())!=<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后栈空则匹配</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode20-有效的括号&quot;&gt;&lt;a href=&quot;#Leetcode20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;Leetcode20.有效的括号&quot;&gt;&lt;/a&gt;Leetcode20.有效的括号&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;p&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leecode118.杨辉三角</title>
    <link href="http://yoursite.com/2020/03/10/Leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>http://yoursite.com/2020/03/10/Leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2020-03-10T04:29:30.000Z</published>
    <updated>2020-03-11T07:39:11.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leetcode118-杨辉三角"><a href="#Leetcode118-杨辉三角" class="headerlink" title="Leetcode118. 杨辉三角"></a>Leetcode118. 杨辉三角</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><a href="https://leetcode-cn.com/problems/pascals-triangle" target="_blank" rel="noopener">杨辉三角</a>.</p><a id="more"></a><p>示例:</p><p>输入:</p><blockquote><p>5</p></blockquote><p>输出:</p><blockquote><p>[</p><p>​      [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//numRows</span></span><br><span class="line">        <span class="keyword">if</span>(numRows&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行一定为1</span></span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        result.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//rowNum=1，即从第二行开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rowNum = <span class="number">1</span> ; rowNum &lt; numRows ; rowNum++)&#123;</span><br><span class="line">            <span class="comment">//本行</span></span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//上一行</span></span><br><span class="line">            List&lt;Integer&gt; preRow = result.get(rowNum-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//一行中第一个为1</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;rowNum;j++)&#123;</span><br><span class="line">                row.add(preRow.get(j-<span class="number">1</span>)+preRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一行中最后一个为1</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            result.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Leetcode118-杨辉三角&quot;&gt;&lt;a href=&quot;#Leetcode118-杨辉三角&quot; class=&quot;headerlink&quot; title=&quot;Leetcode118. 杨辉三角&quot;&gt;&lt;/a&gt;Leetcode118. 杨辉三角&lt;/h3&gt;&lt;p&gt;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。&lt;/p&gt;
&lt;p&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/pascals-triangle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;杨辉三角&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Leecode66.加一</title>
    <link href="http://yoursite.com/2019/11/27/Leetcode66-%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/11/27/Leetcode66-%E5%8A%A0%E4%B8%80/</id>
    <published>2019-11-27T11:36:30.000Z</published>
    <updated>2020-03-14T07:50:26.051Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Leecode题解66-加一"><a href="#Leecode题解66-加一" class="headerlink" title="Leecode题解66.加一"></a>Leecode题解66.加一</h3><p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">Leecode 66.加一</a></p><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [1,2,3]</p><p>输出: [1,2,4]</p><p>解释: 输入数组表示数字 123。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,3,2,1]</p><p>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321.</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i]%=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]!=<span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路:</p><p><strong>加一的所以有可能的情况就只有两种：</strong></p><p><strong>除 99 之外的数字加一；</strong><br><strong>数字 99。</strong><br><strong>加一得十进一位个位数为 00 加法运算如不出现进位就运算结束了且进位只会是一。</strong></p><p><strong>所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 11 个位数置为 00，如此循环直到判断没有再进位就退出循环返回结果。</strong></p><p><strong>然后还有一些特殊情况就是当出现 9999、999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Leecode题解66-加一&quot;&gt;&lt;a href=&quot;#Leecode题解66-加一&quot; class=&quot;headerlink&quot; title=&quot;Leecode题解66.加一&quot;&gt;&lt;/a&gt;Leecode题解66.加一&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/plus-one/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leecode 66.加一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;/p&gt;
&lt;p&gt;你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="http://yoursite.com/2019/11/24/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/24/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-11-24T12:18:48.000Z</published>
    <updated>2020-03-14T08:00:06.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h3 id="格式：参数-gt-表达式"><a href="#格式：参数-gt-表达式" class="headerlink" title="格式：参数 -&gt; (表达式)"></a>格式：参数 -&gt; (表达式)</h3><p>如果代码要完成的计算无法放在一个表达式中，可以把代码放在{}中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(str, (String first,String second) -&gt; (<span class="keyword">return</span> (first.length()-second.length()))</span><br></pre></td></tr></table></figure><p>即使<code>lambda</code>无参数，也要提供空括号.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure><p>如果可以推导出一个<code>lambda</code>的参数类型，则可以忽略参数类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(friends,(first,second) -&gt; (first.length()-second.length()));<span class="comment">//friends是一个字符串数组</span></span><br></pre></td></tr></table></figure><p>无需指定lambda的返回值类型，返回值类型会由上下文推导得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String str1,String str2) -&gt; str1.length()-str2.length();</span><br></pre></td></tr></table></figure><a id="more"></a> <h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个<code>lambda</code>，这种接口叫做函数式接口。</p><p><strong>lambda可以转换为函数式接口</strong>，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, (first,second)-&gt;first.length()-second.length());</span><br><span class="line">people.removeIf(person -&gt; (person.getName().length()&gt;<span class="number">3</span>)); <span class="comment">//removeIf接受一个Predicate参数，这个接口专门用来传递lambda表达式</span></span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>可以<code>::</code>分隔方法名与对象或类名。主要有3种情况。</p><ol><li><code>object::instanceMethod</code></li><li><code>Class::staticMethod</code></li><li><code>Class:;instanceMethod</code></li></ol><p>前2种情况下，方法引用等价于提供方法参数的lambda表达式。</p><blockquote><p>System.out::println等价于x -&gt; System.out.println(x);</p><p>Math::power等价于(x,y) -&gt; (Math.power(x,y));</p></blockquote><p>  第三种情况下，第一个参数会成为方法的目标。</p><blockquote><p>String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y);</p></blockquote><p>方法引用中也可以使用<code>this</code>和<code>super</code>，如``super::instanceMethod`.</p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用用法与方法引用类似，只不过方法名为new。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> []::<span class="keyword">new</span>  <span class="comment">//等价于 x -&gt; new int[x],x是数组的长度</span></span><br><span class="line">Perosn [] people = stream.toArray(Person::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>通常会使用<code>lambda</code>访问外围方法或类中的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">repeatMessage(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>这里str就是一个自由变量。我们说它被lambda捕获。</p><p><code>lambda</code>表达式有3个部分：</p><ol><li>一个代码块</li><li>参数</li><li>自由变量的值，这里指非参数而且不在代码中定义的变量。</li></ol><p><strong>在Java中，<code>lambda</code>就是闭包</strong>。</p><p><strong><code>lambda</code>只能捕获值不变的变量</strong>，指变量初始化后就不会再为它赋新值。</p><h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>使用<code>lambda</code>的重点是延迟执行，例如</p><ol><li>在一个单独的线程中运行代码</li><li>多次运行代码</li><li>在算法的合适位置运行代码(例如，排序中的比较操作)</li><li>发生某种情况时执行代码(如，点击了某个按钮，数据到达等)</li><li>只在必要时运行代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, IntConsumer action)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">action.accept(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Student.repeat(<span class="number">10</span>,i-&gt; System.out.println(<span class="string">"CountDown:"</span>+(<span class="number">9</span>-i)));<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><h3 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h3><p><code>Comparator</code>接口包含很多的静态方法来创建构造器，这些方法可用于lambda表达式或方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(people,Comparator.comparing(Person::getName));<span class="comment">//按名字对people进行排序</span></span><br><span class="line">Arrays.sort(people,Comparator.comparing(Person::getLastName).thencomparing(Person::getFirstName));<span class="comment">//如果两人的姓一致则比较名；</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/h2&gt;&lt;h3 id=&quot;格式：参数-gt-表达式&quot;&gt;&lt;a href=&quot;#格式：参数-gt-表达式&quot; class=&quot;headerlink&quot; title=&quot;格式：参数 -&amp;gt; (表达式)&quot;&gt;&lt;/a&gt;格式：参数 -&amp;gt; (表达式)&lt;/h3&gt;&lt;p&gt;如果代码要完成的计算无法放在一个表达式中，可以把代码放在{}中。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort(str, (String first,String second) -&amp;gt; (&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (first.length()-second.length()))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;即使&lt;code&gt;lambda&lt;/code&gt;无参数，也要提供空括号.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;()-&amp;gt; &amp;#123;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++) System.out.println(i);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果可以推导出一个&lt;code&gt;lambda&lt;/code&gt;的参数类型，则可以忽略参数类型&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort(friends,(first,second) -&amp;gt; (first.length()-second.length()));&lt;span class=&quot;comment&quot;&gt;//friends是一个字符串数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;无需指定lambda的返回值类型，返回值类型会由上下文推导得到&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(String str1,String str2) -&amp;gt; str1.length()-str2.length();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="lambda" scheme="http://yoursite.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://yoursite.com/2019/11/23/Git%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/23/Git%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-23T09:47:42.000Z</published>
    <updated>2020-03-14T07:59:19.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载与安装Git"><a href="#下载与安装Git" class="headerlink" title="下载与安装Git"></a>下载与安装Git</h3><p><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">Git下载</a>，在git Bash下执行<code>git --version</code>，返回Git版本。</p><a id="more"></a> <h3 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h3><h4 id="配置user信息"><a href="#配置user信息" class="headerlink" title="配置user信息"></a>配置user信息</h4><ul><li><p>配置user.name和user.email：</p><blockquote><p>git conﬁg –global  user.name ‘your_name’</p><p>git conﬁg –global  user.email ‘<a href="mailto:your_email@domain.com" target="_blank" rel="noopener">your_email@domain.com</a>‘</p></blockquote></li></ul><h4 id="config的三个作用域"><a href="#config的三个作用域" class="headerlink" title="config的三个作用域"></a>config的三个作用域</h4><ul><li>缺省默认为local</li></ul><blockquote><p>git config –local：只对本地仓库生效</p><p>git config –global：对登录用户所有仓库生效</p><p>git config –system：对系统所有用户生效</p></blockquote><ul><li><p>显示config的配置，加上<code>--list</code></p><blockquote><p> git conﬁg –list –local  </p><p> git conﬁg –list –global </p><p> git conﬁg –list –system</p></blockquote></li><li><p>清除，加上 <code>--unset</code></p><blockquote><p>​git conﬁg –unset –local user.name  </p><p>git conﬁg –unset –global user.name </p><p>git conﬁg –unset –system user.name</p></blockquote></li><li><p>优先级：local&gt;global&gt;system</p></li></ul><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>两种方式创建</p><ol><li><p>Git之前已有代码</p><blockquote><p>cd 文件夹</p><p>git init</p></blockquote></li><li><p>Git之前没有项目代码</p><blockquote><p>cd 文件夹</p><p>git init your_project_name</p><p>cd your_project_name</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载与安装Git&quot;&gt;&lt;a href=&quot;#下载与安装Git&quot; class=&quot;headerlink&quot; title=&quot;下载与安装Git&quot;&gt;&lt;/a&gt;下载与安装Git&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Installing-Git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git下载&lt;/a&gt;，在git Bash下执行&lt;code&gt;git --version&lt;/code&gt;，返回Git版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="http://yoursite.com/2019/11/22/Django%E6%A8%A1%E5%9E%8B%E5%B1%82_%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2019/11/22/Django%E6%A8%A1%E5%9E%8B%E5%B1%82_%E6%9F%A5%E8%AF%A2/</id>
    <published>2019-11-22T14:26:19.000Z</published>
    <updated>2019-11-23T08:55:08.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h2><p>创建数据模型后，Django自动提供了一套API来实现数据库的增删改查，模型代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)</span><br><span class="line">    headline = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    body_text = models.TextField()</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    mod_date = models.DateField()</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    n_comments = models.IntegerField()</span><br><span class="line">    n_pingbacks = models.IntegerField()</span><br><span class="line">    rating = models.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.headline</span><br></pre></td></tr></table></figure><a id="more"></a> <ul><li><p>创建对象</p><p>Django中一个模型就代表数据库中的一张表，模型类的实例代表数据库表中的一行记录。</p><p>创建一个对象进行初始化后，可调用save()保存到数据库中 ，可重写save()方法实现自定义保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> blog.models <span class="keyword">import</span> Blog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Blog(name=<span class="string">'Beatles Blog'</span>, tagline=<span class="string">'All the latest Beatles news.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.save()</span><br></pre></td></tr></table></figure></li><li><p>修改对象</p><p>修改后调用save()方法保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b5.name = <span class="string">'New name'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b5.save()</span><br></pre></td></tr></table></figure><ul><li><p>保存ForeignKey和ManyToManyField字段</p><p>更新ForeignKey字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> blog.models <span class="keyword">import</span> Blog, Entry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry = Entry.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheese_blog = Blog.objects.get(name=<span class="string">"Cheddar Talk"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry.blog = cheese_blog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry.save()</span><br></pre></td></tr></table></figure><p>更新ManyToManyField字段要调用add()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> blog.models <span class="keyword">import</span> Author</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Author.objects.create(name=<span class="string">"Joe"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry.authors.add(joe)</span><br></pre></td></tr></table></figure><p>add()方法可一次传入多个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry.authors.add(john, paul, george, ringo)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检索对象</p><p>通过模型类的Manager来构建queryset，每个模型至少有一个Manager，默认名称是objects</p><ul><li><p>检索全部对象</p><p>all()方法返回全部对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_entries = Entry.objects.all()</span><br></pre></td></tr></table></figure></li><li><p>通过过滤器检索指导对象</p><p><code>filter(**kwargs)</code></p><p>返回一个新的 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet" target="_blank" rel="noopener"><code>QuerySet</code></a>，包含的对象满足给定查询参数。</p><p><code>exclude(**kwargs)</code></p><p>返回一个新的 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet" target="_blank" rel="noopener"><code>QuerySet</code></a>，包含的对象不满足给定查询参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__year=<span class="number">2006</span>) <span class="comment"># 筛选出满足条件的对象</span></span><br><span class="line">Entry.objects.exclude(pub_date__year=<span class="number">2006</span>) <span class="comment"># 筛选出不满足条件的对象</span></span><br></pre></td></tr></table></figure><ul><li><p>链式过滤器</p><p>queryset的结果还是返回一个新的queryset，所以可链式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(</span><br><span class="line"><span class="meta">... </span>    headline__startswith=<span class="string">'What'</span></span><br><span class="line"><span class="meta">... </span>).exclude(</span><br><span class="line"><span class="meta">... </span>    pub_date__gte=datetime.date.today()</span><br><span class="line"><span class="meta">... </span>).filter(</span><br><span class="line"><span class="meta">... </span>    pub_date__gte=datetime.date(<span class="number">2005</span>, <span class="number">1</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">... </span>)</span><br></pre></td></tr></table></figure><ul><li><p>queryset都是惰性的</p><p>创建 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet" target="_blank" rel="noopener"><code>QuerySet</code></a> 并不会引发任何数据库活动。你可以将一整天的过滤器都堆积在一起，Django 只会在 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet" target="_blank" rel="noopener"><code>QuerySet</code></a> 被 计算 时执行查询操作 。</p></li></ul></li></ul></li><li><p>用get()获得单个对象</p><p>不同于filter()总是返回一个queryset，get()只会返回单个对象，当返回多个对象时Django 会抛出 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/exceptions/#django.core.exceptions.MultipleObjectsReturned" target="_blank" rel="noopener"><code>MultipleObjectsReturned</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_entry = Entry.objects.get(pk=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>限制queryset条目数</p><p>利用python切片语法将queryset切成指定长度，等价于 SQL 的 <code>LIMIT</code> 和 <code>OFFSET</code> 子句 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回前5个对象</span></span><br><span class="line">Entry.objects.all()[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 返回第6到10个对象</span></span><br><span class="line">Entry.objects.all()[<span class="number">5</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure></li><li><p>字段查询</p><p>字段查询即你如何制定 SQL <code>WHERE</code> 子句。 它们以关键字参数的形式传递给 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet" target="_blank" rel="noopener"><code>QuerySet</code></a> 方法 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet.filter" target="_blank" rel="noopener"><code>filter()</code></a>， <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet.exclude" target="_blank" rel="noopener"><code>exclude()</code></a> 和 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/querysets/#django.db.models.query.QuerySet.get" target="_blank" rel="noopener"><code>get()</code></a>。 </p><p>*<em>基本的查询关键字参数遵照 <code>field__lookuptype=value</code> *</em>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__lte=<span class="string">'2018-09-20'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>| 转化成SQL语句大致是：</p><p>   SELECT * FROM blog_entry WHERE pub_date &lt;= ‘2018-09-20’;</p></blockquote></li><li><p>跨关系查询</p><p>要跨越关系，只需跨模型使用关联字段名，字段名由双下划线分割，直到拿到想要的字段。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objecst.filter(blog__name=<span class="string">'flbu blog'</span>)</span><br></pre></td></tr></table></figure><p>反向操作也能行。要指向一个“反向的”关联关系，只需使用模型名的小写。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.filter(entry__headline__contains=<span class="string">'Lennon'</span>)</span><br></pre></td></tr></table></figure></li><li><p>过滤器为模型指定字段</p><p>将模型字段与同一模型的另一字段作比较。</p><ul><li><p>F表达式</p><p>F()的实例充当查询字段的引用，这些引用可以实现在同一模型实例中比较不同的字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">Entry.objects.filter(number_of_comments__gt=F(<span class="string">'number_of_pingbacks'</span>))</span><br></pre></td></tr></table></figure><p>Django支持对<code>F()</code>对象进行加减乘除求余和次方等数学运算，另一操作数既可以是常量，也可是另一F()对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(number_of_comments__gt=F(<span class="string">'number_of_pingbacks'</span>) * <span class="number">2</span>)</span><br><span class="line">Entry.objects.filter(rating__lt=F(<span class="string">'number_of_comments'</span>) + F(<span class="string">'number_of_pingbacks'</span>))</span><br></pre></td></tr></table></figure><p><strong>也可以用双下划线在<code>F()</code>对象中进行跨关系查询</strong>，带有双下划线的 <code>F()</code> 对象将引入访问关联对象所需的任何连接 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(authors__name=F(<span class="string">'blog__name'</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>主键(pk)查询快捷方式</p><p><code>pk</code> 表示主键 “primary key” 。</p><p>在示例Blog模型中，主键是id，所以以下查询等价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.get(id__exact=<span class="number">14</span>) <span class="comment"># Explicit form</span></span><br><span class="line">Blog.objects.get(id=<span class="number">14</span>) <span class="comment"># __exact is implied</span></span><br><span class="line">Blog.objects.get(pk=<span class="number">14</span>) <span class="comment"># pk implies id__exact</span></span><br></pre></td></tr></table></figure><p><code>pk</code>的查询并不局限于<code>__exact</code>，任何的查询项都能接在<code>pk</code>的后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get blogs entries with id 1, 4 and 7</span></span><br><span class="line"> Blog.objects.filter(pk__in=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all blog entries with id &gt; 14</span></span><br><span class="line"> Blog.objects.filter(pk__gt=<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><code>pk</code>也支持跨连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(blog__id__exact=<span class="number">3</span>) <span class="comment"># Explicit form</span></span><br><span class="line">Entry.objects.filter(blog__id=<span class="number">3</span>)        <span class="comment"># __exact is implied</span></span><br><span class="line">Entry.objects.filter(blog__pk=<span class="number">3</span>)        <span class="comment"># __pk implies __id__exact</span></span><br></pre></td></tr></table></figure></li><li><p>通过Q对象完成复杂查询</p><p>在<code>filter()</code>中，查询使用的关键字参数使用AND连接，如果要执行更加复杂的查询，可以使用<code>Q</code>对象</p><p><code>Q</code> 对象能通过 <code>&amp;</code> 和 <code>|</code> 操作符连接起来。当操作符被用于两个 <code>Q</code> 对象之间时会生成一个新的 <code>Q</code> 对象。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">Q(question__startswith=<span class="string">'Who'</span>) | Q(question__startswith=<span class="string">'What'</span>)</span><br><span class="line"><span class="comment"># 等价于SQL WHERE 语句：WHERE question LIKE 'Who%' OR question LIKE 'What%'</span></span><br></pre></td></tr></table></figure><p><code>Q</code>对象可通过<code>~</code>反转，代表NOT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q(question__startswith=<span class="string">'Who'</span>) | ~Q(pub_date__year=<span class="number">2005</span>)</span><br></pre></td></tr></table></figure><p>每个查询函数可接受一个或多个<code>Q</code>对象作为位置参数，若提供了多个<code>Q</code>对象参数，这些参数会通过 “AND” 连接 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Poll.objects.get(</span><br><span class="line">    Q(question__startswith=<span class="string">'Who'</span>),</span><br><span class="line">    Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">2</span>)) | Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询函数可混合使用 <code>Q</code> 对象和关键字参数 ，均通过 “AND” 连接 。但<strong><code>Q</code> 对象必须位于所有关键字参数之前</strong>。 </p></li><li><p>比较对象总会使用主键值</p></li><li><p>删除对象</p><p>通过调用<code>delete()</code>方法删除对象，也可以通过<code>QuerySet</code>批量删除对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.delete()</span><br><span class="line"><span class="comment"># 返回被删除的对象数量和一个包含了每个被删除对象类型的数量的字典</span></span><br><span class="line">(<span class="number">1</span>, &#123;<span class="string">'weblog.Entry'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment"># 删除QuerySet中的所有成员</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(pub_date__year=<span class="number">2005</span>).delete()</span><br><span class="line">(<span class="number">5</span>, &#123;<span class="string">'webapp.Entry'</span>: <span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>批量修改对象</p><p>可通过<code>update()</code>修改<code>QuerySet</code>中所有对象的一个字段，仅能用此方法设置非关联字段和 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ForeignKey" target="_blank" rel="noopener"><code>ForeignKey</code></a> 字段 </p><p>调用更新方法时也可以使用<code>F</code>表达式，但只能引用被更新模型的内部字段 。若在更新方法中使用 <code>F()</code> 对象的同时使用 join ，会抛出一个 <code>FieldError()</code> </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.all().update(number_of_pingbacks=F(<span class="string">'number_of_pingbacks'</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will raise a FieldError</span></span><br><span class="line"> Entry.objects.update(headline=F(<span class="string">'blog__name'</span>))</span><br></pre></td></tr></table></figure></li><li><p>关联对象</p><p>一个 <code>Entry</code> 对象 <code>e</code> 通过 <code>blog</code> 属性可以获取其关联的 <code>Blog</code> 对象： <code>e.blog</code> ，一个 <code>Blog</code> 对象 <code>b</code> 能通过 <code>entry_set</code> 属性 <code>b.entry_set.all()</code> 访问包含所有关联 <code>Entry</code> 对象的列表 。</p><ul><li><p>一对多关联</p><ul><li><p>正向访问</p><p>对外键的修改直到你调用 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/instances/#django.db.models.Model.save" target="_blank" rel="noopener"><code>save()</code></a> 后才会被存入数据库 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e = Entry.objects.get(id=<span class="number">2</span>)</span><br><span class="line">e.blog <span class="comment"># Returns the related Blog object</span></span><br><span class="line"></span><br><span class="line">e = Entry.objects.get(id=<span class="number">2</span>)</span><br><span class="line">e.blog = some_blog</span><br><span class="line">e.save()</span><br></pre></td></tr></table></figure></li><li><p>反向关联</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = Blog,objects.get(pk=<span class="number">1</span>)</span><br><span class="line">b.entry_set.all()</span><br></pre></td></tr></table></figure><p>可以在定义 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ForeignKey" target="_blank" rel="noopener"><code>ForeignKey</code></a> 时设置 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ForeignKey.related_name" target="_blank" rel="noopener"><code>related_name</code></a> 参数重写这个 <code>FOO_set</code> 名。例如，若修改 <code>Entry</code> 模型为 <code>blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=&#39;entries&#39;)</code>，前文示例代码会看起来像这样 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Blog.objects.get(id=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.entries.all() <span class="comment"># Returns all Entry objects related to Blog.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b.entries is a Manager that returns QuerySets.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.entries.filter(headline__contains=<span class="string">'Lennon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.entries.count()</span><br></pre></td></tr></table></figure></li><li><p>管理关联对象的方法</p><ol><li><p><code>add(obj1, obj2, ...)</code></p><p>将特定的模型对象加入关联对象集合。</p></li><li><p><code>create(**kwargs)</code></p><p>创建一个新对象，保存，并将其放入关联对象集合中。返回新创建的对象。</p></li><li><p><code>remove(obj1, obj2, ...)</code></p><p>从关联对象集合删除指定模型对象.</p></li><li><p><code>clear()</code></p><p>从关联对象集合删除所有对象。</p></li><li><p><code>set(objs)</code></p><p>替换关联对象集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = Blog.objects.get(id=<span class="number">1</span>)</span><br><span class="line">b.entry_set.set([e1, e2])</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>多对多关联</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e = Entry.objects.get(id=<span class="number">3</span>)</span><br><span class="line">e.authors.all() <span class="comment"># Returns all Author objects for this Entry.</span></span><br><span class="line">e.authors.count()</span><br><span class="line">e.authors.filter(name__contains=<span class="string">'John'</span>)</span><br><span class="line"></span><br><span class="line">a = Author.objects.get(id=<span class="number">5</span>)</span><br><span class="line">a.entry_set.all() <span class="comment"># Returns all Entry objects for this Author.</span></span><br></pre></td></tr></table></figure><p>和 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ForeignKey" target="_blank" rel="noopener"><code>ForeignKey</code></a> 一样， <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ManyToManyField" target="_blank" rel="noopener"><code>ManyToManyField</code></a> 能指定 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ManyToManyField.related_name" target="_blank" rel="noopener"><code>related_name</code></a>。在上面的例子中，若 <code>Entry</code> 中的 <a href="https://docs.djangoproject.com/zh-hans/2.2/ref/models/fields/#django.db.models.ManyToManyField" target="_blank" rel="noopener"><code>ManyToManyField</code></a> 已指定了 <code>related_name=&#39;entries&#39;</code>，随后每个 <code>Author</code> 实例会拥有一个 <code>entries</code> 属性，而不是 <code>entry_set</code>。 </p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;执行查询&quot;&gt;&lt;a href=&quot;#执行查询&quot; class=&quot;headerlink&quot; title=&quot;执行查询&quot;&gt;&lt;/a&gt;执行查询&lt;/h2&gt;&lt;p&gt;创建数据模型后，Django自动提供了一套API来实现数据库的增删改查，模型代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; models&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Blog&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tagline = models.TextField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    email = models.EmailField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(models.Model)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    headline = models.CharField(max_length=&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body_text = models.TextField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pub_date = models.DateField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mod_date = models.DateField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    authors = models.ManyToManyField(Author)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n_comments = models.IntegerField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n_pingbacks = models.IntegerField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rating = models.IntegerField()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.headline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Django model" scheme="http://yoursite.com/tags/Django-model/"/>
    
  </entry>
  
</feed>
