<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flbu blog</title>
  
  <subtitle>记录学习历程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-20T08:59:49.611Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flbu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秒杀系统设计</title>
    <link href="http://yoursite.com/2021/11/04/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2021/11/04/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-04T06:23:07.000Z</published>
    <updated>2021-11-20T08:59:49.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><p>秒杀系统是一种应用广泛的高并发读写场景，秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易的过程，对高性能、一致性、高可用要求较高，本文主要记录个人学习秒杀系统设计的收获与思考。</p><p>秒杀系统主要就是解决两个问题，<strong>一个高并发读，一个高并发写</strong>。并发读的优化思路就是尽量减少用户到服务端来读数据，或者读更少的数据；并发写的优化思路也是一样，同时还需要针对系统设计一些保护措施和兜底方案。从架构上就是要保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少、避免单点。</p><ul><li><strong>高性能</strong>。秒杀设计大量的读写操作，对性能要求极高。可以从数据的动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务的优化等角度考虑。</li><li><strong>一致性</strong>。一致性主要体现在秒杀场景中的库存控制方面，既不能多卖也不能少卖。</li><li><strong>高可用</strong>。高可用主要是保证系统在异常情况时的可用性和正确性，需要设计异常处理和兜底方案。</li></ul><a id="more"></a><h3 id="秒杀设计原则"><a href="#秒杀设计原则" class="headerlink" title="秒杀设计原则"></a>秒杀设计原则</h3><ul><li>请求数据尽量少。数据在网络中传输需要时间，服务端在处理数据时需要做压缩和字符编码，并且系统间调用RPC会涉及序列化与反序列化，增大对CPU的压力。</li><li>请求数尽量少。建立连接需要做三次握手，前端渲染需要串行加载，请求的域名不同的话还需要进行DNS解析，耗时更久。</li><li>路径尽量短。路径指的是请求经过的节点数，每经过一个节点都需要建立一次Socket连接，并且节点越多，不确定性越大。缩短路径不仅可以增加可用性，还可以提升性能（减少序列化和反序列化、减少网络传输延时）。可以把强依赖的服务合并将RPC请求变成本地方法调用。</li><li>依赖尽量少。对系统进行分级，秒杀页面对商品信息、用户信息是强依赖，但对优惠券、成交列表等是弱依赖，对低依赖的系统必要时可以降级。</li><li>避免单点。尽量将服务无状态化，避免将服务与机器进行绑定。对于存储服务这种与机器绑定的情况，可以通过冗余备份的方式来解决单点问题。</li></ul><p>可以将秒杀系统独立成一个服务,  方便做针对性优化, 且秒杀系统可以独立部署, 不会影响正常商品的集群负载.   热点数据可以放到缓存中,  提高读取性能.  </p><p>对页面动静分离, 用户刷新时不重新加载整个页面;  对秒杀商品进本地缓存, 不需要再去Redis集群中读取,  这种情况不适用秒杀商品特别多的场景;  增加系统限流.</p><h3 id="数据的动静分离"><a href="#数据的动静分离" class="headerlink" title="数据的动静分离"></a>数据的动静分离</h3><h5 id="动静数据的划分"><a href="#动静数据的划分" class="headerlink" title="动静数据的划分"></a>动静数据的划分</h5><p>动静分离就是指把用户请求的数据划分为动态数据和静态数据，主要区别就是看页面中的数据是否与访问者的个性化数据相关。例如媒体网站首页无论谁访问看到的内容都是一样的，这就是典型的静态数据，而淘宝的首页每个人看到的内容都是不同的这就是动态数据。<strong>分离了动静数据，就可以对分离出来的静态数据做缓存，提高静态数据的访问效率。</strong></p><h5 id="静态数据的存储"><a href="#静态数据的存储" class="headerlink" title="静态数据的存储"></a>静态数据的存储</h5><p>缓存静态数据，可以<strong>把静态数据缓存在离用户最近的地方，如用户浏览器、CDN或者服务的Cache中；静态化改造直接缓存HTTP连接而不是仅仅缓存数据，利用Web代理服务器根据请求的url直接取出HTTP响应头和响应体后直接返回；不同语言写的Cache层缓存效率不同，如Java不擅长处理大量连接的请求，因为每个连接一个线程消耗内存较高，可以把缓存放在Web服务器上（如Nginx、Apache）。</strong></p><h5 id="动静分离的架构方案"><a href="#动静分离的架构方案" class="headerlink" title="动静分离的架构方案"></a>动静分离的架构方案</h5><ul><li><p><strong>实体机单机部署</strong></p><p>将虚拟机改为实体机，增大Cache容量，并且用一致性Hash增大命中率。设置多个Cache组，达到命中率和访问热点的平衡。</p><p>实体机单机部署<strong>没有网络瓶颈且能够使用大内存，但会造成CPU的浪费</strong>，因为单个Java进程很难用完整个实体机的CPU。另一个缺点就是<strong>运维复杂度高，一个实体机上既部署了Java应用又部署了缓存</strong>。</p></li><li><p><strong>统一Cache层</strong></p><p>统一Cache指的是将单机的Cache统一分离成单独的Cache集群。    Cache层统一管理降低了运维复杂度，可以降低多个应用接入的成本，最大化利用内存。但因为缓存更加集中，网络可能会成为瓶颈。</p></li><li><p><strong>上CDN</strong></p><p>CDN距离用户最近效果最好，但需要考虑缓存的失效问题，当数据发生变更或者系统发布更新后，需要有一个高效的CDN失效系统，并且有问题时快速回滚和方便排除问题。</p><p>CDN化部署方案可以把静态数据都缓存在用户端或CDN上，真正秒杀时，实际有效的请求只是抢购按钮，系统只向服务端请求很少的有效数据，而不需要请求大量重复静态数据。</p></li></ul><h3 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h3><p>秒杀场景中存在很多的热点数据，它们在短时间内被大量用户执行访问、添加购物车、下单等操作，这些热点请求会大量占用服务器处理资源，所以我们要对热点做针对性优化。</p><h5 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h5><ul><li><p>发现静态热点数据</p><p>静态热点数据可以通过商业手段筛选，如让商家报名参加秒杀等，利用运营系统把参加秒杀的商品打标，再进行预热。或者利用大数据计算出每天用户访问的Top N商品，这些可以认为是热点数据。</p></li><li><p>发现动态热点数据</p><p>可以构建一个异步系统，收集交易链路上各个环节中的中间件的热点key（Nginx、Cache、RPC框架等），（如Nginx自带热点统计模块），把上游的热点透传给下游系统，然后做热点保护。</p></li></ul><h5 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h5><p><strong>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离</strong>。</p><p><strong>优化</strong>。缓存热点数据，管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用 LRU 淘汰算法替换。</p><p><strong>限制</strong>。限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。</p><p><strong>隔离</strong>。将热点数据隔离，防止影响其他商品售卖。可以在三个层次上进行隔离。</p><ul><li>业务隔离。卖家参与秒杀需要报名，提前做好预热。</li><li>系统隔离。做单独的秒杀系统，让请求落到不同的集群中</li><li>数据隔离。启用单独的集群来存放热点数据。</li></ul><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。流量削峰的一些操作思路：排队、答题、分层过滤.</p><ul><li><p>排队。用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p></li><li><p>答题。目的是防止部分买家使用秒杀器在参加秒杀时作弊和延缓请求，基于时间分片起到对请求流量进行削峰的作用</p></li><li><p>分层过滤。对请求进行分层过滤，从而过滤掉一些无效的请求。按照“漏斗”式设计来处理请求。</p><ul><li>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读</li><li>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题</li><li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求</li><li>对写请求做限流保护，将超出系统承载能力的请求过滤掉；</li><li>对写数据进行强一致性校验，只保留最后有效的数据。</li></ul><p>在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。</p></li></ul><h3 id="减库存"><a href="#减库存" class="headerlink" title="减库存"></a>减库存</h3><p>减库存场景的要求是既不超卖也不少卖，用户的购买分为两个部分：下单和付款，但并不是下了单后就一定付款。所以减库存操作可以在三个环节进行。</p><ul><li><strong>下单减库存。</strong>用户下单后直接利用数据库的事务机制在商品总库存中扣减，这是控制最精确的一种，一定不会出现超卖的现象。但存在下单后不付款的情况。</li><li><strong>付款减库存。</strong>用户下单后不扣减库存，而是等到用户付款后才真正扣减库存，否则保留给其他买家。所以存在并发较高时，买家下单后付不了款的情况，用户体验不好。</li><li><strong>预扣库存。</strong>用户下单后，库存为其保留一段时间（如15分钟），超出这个时间，库存自动释放，其他买家继续购买。买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</li></ul><p>上面三种方式都有局限性，<strong>下单减库存可能导致恶意下单，影响商品销售；付款减库存容易造成大面积下单成功但无法付款；预扣库存只能在一定程度上缓解这些问题，还是要靠安全和反作弊进行次数限制。如给经常下单但不付款的用户打标，限制最大购买件数、对重复下单不付款的次数进行限制等。</strong></p><p>在电商场景中，最常见的就是预扣库存方案，一定时间后未付款直接释放库存。但对于秒杀商品，成功下单后不付款的情况较少，所以采用下单扣库存方案更加合理。</p><p>交易场景中，库存是个热点数据，所以可以把库存数据放到缓存（Redis）中，大大提高读性能。如果扣减库存的逻辑单一，完全可以用缓存，但如果涉及复杂的减库存逻辑，还是要用数据库事务来完成。</p><p>如果用MySQL的方案，同一个商品数据对应MySQL中的一行，因此会有大量的线程来竞争行锁，造成TPS下降，RT上升，从而影响整个数据库的吞吐量。对于并发锁的问题，可以做<strong>应用层或者数据库层的排队</strong>。应用层按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。应用层只能做到单机排队，数据库层可以做到全局排队。</p><h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><p>系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时。</p><ol><li><strong>架构阶段</strong>：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</li><li><strong>编码阶段</strong>：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。</li><li><strong>测试阶段</strong>：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</li><li><strong>发布阶段</strong>：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。</li><li><strong>运行阶段</strong>：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</li><li><strong>故障发生</strong>：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</li></ol><h5 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h5><p><strong>降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务</strong>。执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验。</p><h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。<strong>限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</strong></p><p>限流既可以在客户端限流，也可以在服务端限流。限流的实现方式既要支持 URL 以及方法级别的限流，也要支持<strong>基于 QPS 和线程的限流</strong>。</p><ul><li><strong>客户端限流</strong>，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</li><li><strong>服务端限流</strong>，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</li></ul><h5 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h5><p>如果限流还不能解决问题，最后一招就是直接拒绝服务了。当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。</p><p><strong>高可用建设是基础，可以说要深入到各个环节，更要长期规划并进行体系化建设，要在预防（建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测）、管控（做好线上运行时的降级、限流和兜底保护）、监控（建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警）和恢复体系（遇到故障要及时止损，并提供快速的数据订正工具等）等这些地方加强建设。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;秒杀系统设计&quot;&gt;&lt;a href=&quot;#秒杀系统设计&quot; class=&quot;headerlink&quot; title=&quot;秒杀系统设计&quot;&gt;&lt;/a&gt;秒杀系统设计&lt;/h1&gt;&lt;p&gt;秒杀系统是一种应用广泛的高并发读写场景，秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易的过程，对高性能、一致性、高可用要求较高，本文主要记录个人学习秒杀系统设计的收获与思考。&lt;/p&gt;
&lt;p&gt;秒杀系统主要就是解决两个问题，&lt;strong&gt;一个高并发读，一个高并发写&lt;/strong&gt;。并发读的优化思路就是尽量减少用户到服务端来读数据，或者读更少的数据；并发写的优化思路也是一样，同时还需要针对系统设计一些保护措施和兜底方案。从架构上就是要保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少、避免单点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;。秒杀设计大量的读写操作，对性能要求极高。可以从数据的动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务的优化等角度考虑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;。一致性主要体现在秒杀场景中的库存控制方面，既不能多卖也不能少卖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用&lt;/strong&gt;。高可用主要是保证系统在异常情况时的可用性和正确性，需要设计异常处理和兜底方案。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="系统设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码学习</title>
    <link href="http://yoursite.com/2020/09/13/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/09/13/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-09-13T07:53:34.000Z</published>
    <updated>2020-09-13T09:46:40.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不安全的HashMap"><a href="#不安全的HashMap" class="headerlink" title="不安全的HashMap"></a>不安全的HashMap</h2><p>总所周知，<code>HashMap</code>是非线程安全的，体现在rehash时的死循环，使用迭代器时的fast-fail和多线程环境下put操作出现丢失数据等。</p><p>虽然JDK也提供了一个安全版本的<code>HashMap</code>：<code>Collections.SynchronizedMap</code>，但因为其使用的是全局锁，并发性能较差。</p><p>因此，juc包下提供了线程安全且锁粒度较小的<code>ConcurrentHashMap</code>。</p><h2 id="ConcurrentHashMap的结构与实现原理"><a href="#ConcurrentHashMap的结构与实现原理" class="headerlink" title="ConcurrentHashMap的结构与实现原理"></a>ConcurrentHashMap的结构与实现原理</h2><p><code>ConcurrentHashMap</code>在JDK1.7和JDK1.8中有者不同的实现。</p><a id="more"></a><h3 id="1-7下的ConcurrentHashMap"><a href="#1-7下的ConcurrentHashMap" class="headerlink" title="1.7下的ConcurrentHashMap"></a>1.7下的ConcurrentHashMap</h3><p>JDK1.7下的<code>ConcurrentHashMap</code>使用分段锁来提高并发访问效率，每把锁锁容器内的一部分数据，当多线程访问容器里不同数据段的数据时，就不会出现锁竞争。</p><p><img src="https://f1bu920.github.io/images/ConcurrentHashMap1.7.png" alt=""></p><p>1.7中<code>ConcurrentHashMap</code>是<strong>由<code>Segment</code>数组和<code>HashEntry</code>数组组成。<code>Segment</code>是一种可重入锁<code>ReentrantLock</code>，扮演锁的角色；<code>HashEntry</code>则用于存储键值对。一个<code>ConcurrentHashMap</code>中包含一个<code>Segment</code>数组。<code>Segment</code>的结构和<code>HashMap</code>类似，都是数组+链表结构。一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>HashEntry</code>是一个链表结构的元素，每个<code>Segment</code>元素锁着对应的<code>HashEntry</code>数组里的元素。想要修改<code>HashEntry</code>数组中的元素时，必须先获得对应的<code>Segment</code>锁。</strong></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>ConcurrentHashMap</code>初始化时，计算出<code>Segment</code>数组的大小<code>ssize</code>和每个<code>Segment</code>中<code>HashEntry</code>数组的大小<code>cap</code>，并初始化<code>Segment</code>数组的第一个元素；其中<code>ssize</code>大小为2的幂次方，默认为16，<code>cap</code>大小是2的幂次方或1，最终结果根据根据初始化容量<code>initialCapacity</code>进行计算。 </p><h4 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h4><p><code>ConcurrentHashMap</code>使用分段锁来保护不同段的数据，那么在插入、获取数据的时候，必须先定位到<code>Segment</code>。</p><p><code>ConcurrentHashMap</code>首先会对key的hashCode()使用<code>hash()</code>方法进行再散列，目的是减少哈希冲突，使元素能够均匀的分布在不同的<code>Segment</code>上。</p><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>get操作只需要将再散列得到的散列值通过散列运算定位到具体的<code>Segment</code>上，再通过一次<code>Hash</code>定位到具体的元素上。</p><p><strong>整个get操作都不需要加锁，除非读到的是空值才需要加锁重读。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</strong></p><p><strong>定位HashEntry和定位Segment的算法都是数组长度减一和哈希值相与，但定位Segment使用的是元素的hashCode通过再散列后的散列值的高位，而定位HashEntry使用的是再散列后的值。这样是为了避免两次散列后的值一样，没有同时在Segment和HashEntry中散列开。</strong></p><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>put操作是写操作，虽然HashEntry中的value用了volatile修饰，但并不能保证原子性，必须要加锁。</p><p><strong>put操作首先定位到Segment，然后定位插入位置，执行插入操作。插入分为两步：</strong></p><ul><li><p>判断是否需要扩容</p><p>插入元素前会判断Segment里的HashEntry数组是否超过容量，如果超过阈值，则对数组进行扩容。</p></li><li><p>扩容过程</p><p>扩容时，首先创建一个容量是原来两倍的数组，将原数组中的元素再散列后插入到新数组中。<code>ConcurrentHashMap</code>不会对整个容器进行扩容，只会对某个<code>Segment</code>进行扩容。</p></li></ul><h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>size操作需要遍历所有的Segment才能计算出整个容器的大小，最简单的方案是锁住整个<code>ConcurrentHashMap</code>，但这样十分低效。</p><p><strong><code>ConcurrentHashMap</code>的做法是先尝试两次通过不锁住<code>Segment</code>的方式来统计各个<code>Segment</code>的大小，如果统计的时候容器的<code>count</code>发生了变化，再采用加锁的方式统计Segment的大小。每个<code>Segment</code>都通过变量<code>modCount</code>来记录修改次数，比较size前后<code>modCount</code>是否发生变化就可以得知容器的大小是否发生变化。如果两次的<code>modCount</code>都相等，则说明<code>size()</code>期间无更新操作，可直接作为结果返回。</strong></p><h3 id="1-8下的ConcurrentHashMap"><a href="#1-8下的ConcurrentHashMap" class="headerlink" title="1.8下的ConcurrentHashMap"></a>1.8下的ConcurrentHashMap</h3><p>1.8的<code>ConcurrentHashMap</code>取消了分段锁设计，而是采用<strong>CAS+synchronized来保证线程安全。</strong></p><p>数据结构和<code>HashMap</code>类似，都是<strong>数组+链表/红黑树</strong>。</p><p><img src="https://f1bu920.github.io/images/ConcurrentHashMap1.8.JPG" alt=""></p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它重新定义了哈希方法计算得到Key的最终哈希值。</p><h4 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h4><p>同1.7，get操作也不需要加锁。</p><p><strong>由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V val;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h4><p>当执行put操作时，先根据key的哈希值在Node数组中找到对应的位置。</p><ul><li><strong>如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</strong></li><li><strong>如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。</strong></li><li><strong>如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</strong></li></ul><h4 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h4><p>1.8中使用一个<code>volatile</code>类型的变量<code>baseCount</code>记录元素的个数，当插入新数据或则删除数据时，会通过<code>addCount()</code>方法更新<code>baseCount</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不安全的HashMap&quot;&gt;&lt;a href=&quot;#不安全的HashMap&quot; class=&quot;headerlink&quot; title=&quot;不安全的HashMap&quot;&gt;&lt;/a&gt;不安全的HashMap&lt;/h2&gt;&lt;p&gt;总所周知，&lt;code&gt;HashMap&lt;/code&gt;是非线程安全的，体现在rehash时的死循环，使用迭代器时的fast-fail和多线程环境下put操作出现丢失数据等。&lt;/p&gt;
&lt;p&gt;虽然JDK也提供了一个安全版本的&lt;code&gt;HashMap&lt;/code&gt;：&lt;code&gt;Collections.SynchronizedMap&lt;/code&gt;，但因为其使用的是全局锁，并发性能较差。&lt;/p&gt;
&lt;p&gt;因此，juc包下提供了线程安全且锁粒度较小的&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;ConcurrentHashMap的结构与实现原理&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap的结构与实现原理&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap的结构与实现原理&quot;&gt;&lt;/a&gt;ConcurrentHashMap的结构与实现原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;在JDK1.7和JDK1.8中有者不同的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码学习" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-锁</title>
    <link href="http://yoursite.com/2020/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/"/>
    <id>http://yoursite.com/2020/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/</id>
    <published>2020-09-10T08:57:52.000Z</published>
    <updated>2020-09-12T05:50:12.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><p>本篇文章主要介绍juc包下与锁相关的API和组件，包括<strong><code>Lock</code>接口、<code>AQS</code>抽象队列同步器、重入锁、读写锁和<code>Condition</code>接口。</strong></p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>锁是用来控制多个线程访问资源的方式，除了<code>synchronized</code>之外，juc包下还提供了<code>Lock</code>接口来实现锁功能。其提供了与<code>synchronized</code>类似的同步功能，但<strong>需要显示的获取、释放锁</strong>，并且提供了更加强大的功能，如<strong>可中断的获取锁和超时获取锁等</strong>。</p><p><code>Lock</code>接口提供了<code>synchronized</code>关键字不具备的特性：</p><table><thead><tr><th align="center">特性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">尝试非阻塞的获取锁</td><td align="center">当前线程尝试获取锁，如果锁这一时刻没有被其他线程获取到，则成功获取并持有锁</td></tr><tr><td align="center">可中断的获取锁</td><td align="center">获取到锁的线程能响应中断，拥有锁的线程被中断时，会抛出中断异常并释放锁</td></tr><tr><td align="center">超时获取锁</td><td align="center">在指定时间内获取锁，如果超时仍未获取锁，则返回</td></tr></tbody></table><p><code>Lock</code>接口的默认实现类为<code>ReentrantLock</code>，<code>部分API如下：</code></p><table><thead><tr><th align="center">void lock()</th><th align="center">获取锁，调用该方法的线程尝试获取锁，获取成功后返回</th></tr></thead><tbody><tr><td align="center">void lockInterruptibly() throws InterruptedException</td><td align="center">可中断的获取锁</td></tr><tr><td align="center">boolean tryLock()</td><td align="center">尝试非阻塞的获取锁，调用此方法后立即返回</td></tr><tr><td align="center">boolean tryLock(long var1, TimeUnit var3) throws InterruptedException</td><td align="center">超时获取锁，有三种可能会返回：超时、成功获取锁、被中断</td></tr><tr><td align="center">void unlock()</td><td align="center">释放锁</td></tr><tr><td align="center">Condition newCondition()</td><td align="center">获取等待通知组件，该组件和当前的锁绑定，只有获取了锁才能调用此方法，并且调用后释放锁</td></tr></tbody></table><a id="more"></a><h2 id="抽象队列同步器AQS"><a href="#抽象队列同步器AQS" class="headerlink" title="抽象队列同步器AQS"></a>抽象队列同步器AQS</h2><p><strong>抽象队列同步器是用来构造锁和其他同步组件的基础框架，其使用了一个<code>private volatile int</code>类型的成员变量<code>state</code>表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队。</strong></p><p><strong>同步器是基于模板方法设计的，子类通过继承<code>AbstractQueuedSynchronizer</code>并实现它的同步方法来管理同步状态。同步器提供了三个安全的方法来对同步状态进行更改：<code>getState</code>、<code>setState</code>、<code>compareAndSetState(int expect,int update)</code>。</strong>子类推荐被定义为同步组件的一个静态内部类，其定义了一些获取和释放同步状态的方法。<strong>同步器既可以支持独占式获取同步状态，也可以支持共享式获取同步状态，这样可以实现不同的同步组件，如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>等</strong>。</p><p><strong>同步器是实现锁的关键，利用同步器来实现锁的语义。锁是面向使用者的，定义了锁与使用者交互的接口，隐藏了实现细节；同步器是面向锁的实现者的，简化了锁的实现方式，屏蔽了同步状态管理、线程排队、等待与唤醒等底层操作。</strong></p><h3 id="队列同步器的接口"><a href="#队列同步器的接口" class="headerlink" title="队列同步器的接口"></a>队列同步器的接口</h3><p>同步器是基于模板方法设计的，所以<strong>通过继承同步器并重写指定的方法，将同步器子类组合在自定义同步组件中，并调用同步器所提供的模板方法，就会调用我们重写的方法，从而实现自定义同步组件的逻辑</strong>。</p><p>重写指定的方法时，需要使用下面三个方法对同步状态进行访问和修改：</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState(int expect,int update)</li></ul><p>同步器可供重写的方法如下：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean tryAcquire(int arg)</td><td align="center">独占式的获取同步状态。实现该方法需要查询当前状态并判断当前状态是否符合预期，在进行CAS设置同步状态</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占式的释放同步状态</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享式的获取同步状态，返回大于等于0的值，获取成功，否则获取失败</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">当前同步器是否在独占式状态下被线程占用</td></tr></tbody></table><p>实现自定义同步组件时，会调用同步器的模板方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public final void acquire(int arg)</td><td align="center">独占式获取锁。如果获取成功，则返回；否则进入同步队列等待。会调用重写的tryAcquire()方法</td></tr><tr><td align="center">public final void acquireInterruptibly(int arg)</td><td align="center">与acquire()方法相同，但响应中断。</td></tr><tr><td align="center">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</td><td align="center">在acquireInterruptibly(int arg)基础上增加了超时限制</td></tr><tr><td align="center">public final boolean release(int arg)</td><td align="center">独占式释放同步状态，在释放后会唤醒同步队列中下一个节点</td></tr><tr><td align="center">public final void acquireShared(int arg)</td><td align="center">共享式获取同步状态，如果未获取到，则进入同步队列等待</td></tr><tr><td align="center">public final void acquireSharedInterruptibly(int arg)</td><td align="center">在acquireShared(int arg)基础上可响应中断</td></tr><tr><td align="center">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td><td align="center">在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td></tr><tr><td align="center">public final boolean releaseShared(int arg)</td><td align="center">共享式释放同步状态</td></tr><tr><td align="center">public final Thread getFirstQueuedThread()</td><td align="center">获取同步队列上下一个等待线程</td></tr></tbody></table><p>同步器提供的模板方法可以分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中等待线程情况。通过这些模板方法，自定义同步组件可以实现自己的语义。</p><h3 id="队列同步器的实现"><a href="#队列同步器的实现" class="headerlink" title="队列同步器的实现"></a>队列同步器的实现</h3><p>队列同步器的实现主要分为<strong>同步队列、独占式同步状态的获取与释放、共享式同步状态的获取与释放以及超时获取同步状态</strong></p><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p><strong>同步器依赖内部的一个FIFO的双向队列来完成线程的排队。当前线程获取同步状态失败时，同步器将当前线程和等待状态等信息构造成一个<code>Node</code>节点加入到同步队列中，并阻塞当前线程。当释放同步状态时，会唤醒同步队列首节点线程，使其再次尝试获取同步状态。</strong></p><p><img src="https://f1bu920.github.io/images/AQS%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.jpg" alt=""></p><p>节点时构成同步队列的基础，同步器记录首节点(head)和尾节点(tail)，没有成功获取同步状态的线程会被构造出节点添加到同步队列的尾部。<strong>同步器提供了一个基于CAS的安全设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，设置成功后，当前节点才会与之前的尾节点建立关联。</strong></p><p><img src="https://f1bu920.github.io/images/AQS%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE%E5%B0%BE%E8%8A%82%E7%82%B9.jpg" alt=""></p><p>同步队列遵循FIFO规则，释放同步状态时，会唤醒后继节点，而<strong>后继节点在获取同步状态后会把自己设置为首节点，注意因为只有一个线程能成功获取同步状态，所以不需要通过CAS来保证安全性</strong>。</p><h4 id="独占式获取和释放同步状态"><a href="#独占式获取和释放同步状态" class="headerlink" title="独占式获取和释放同步状态"></a>独占式获取和释放同步状态</h4><p>通过调用同步器的<code>acquire()</code>方法来独占式的获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.tryAcquire(arg) &amp;&amp; <span class="keyword">this</span>.acquireQueued(<span class="keyword">this</span>.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用自定义的<code>tryAcquire()</code>方法尝试获取同步状态，如果同步状态获取失败，则构造成<code>Node</code>节点并通过<code>addWaiter()</code>方法添加到同步队列尾部，最后通过<code>acquireQueued</code>方法使得该<strong>节点以“死循环”的方式尝试获取同步状态，如果获取不到则阻塞当前线程。而被阻塞线程的唤醒主要靠前驱节点出队和阻塞线程被中断来实现。</strong></p><p><img src="https://f1bu920.github.io/images/AQS%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8A%82%E7%82%B9%E8%87%AA%E6%97%8B%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt=""></p><p><strong>节点进入同步队列后，就进入一个自旋的过程，不断检查前驱节点是否是头节点，如果是，则尝试获取前驱节点，否则处于等待状态。</strong></p><p><img src="https://f1bu920.github.io/images/AQS%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B.png" alt=""></p><p>总结：</p><p><strong>在获取同步状态时，同步器维护一个同步状态，获取同步状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点是头节点并且成功获取了同步状态。在释放同步状态时，调用<code>tryRelease()</code>方法释放同步状态，然后唤醒头节点的后继节点。</strong></p><h4 id="共享式获取和释放同步状态"><a href="#共享式获取和释放同步状态" class="headerlink" title="共享式获取和释放同步状态"></a>共享式获取和释放同步状态</h4><p>共享式获取和独占式获取的区别在于同一时刻能否有多个线程同时获取到同步状态。</p><p><strong>共享式访问资源时，其他共享式访问均被允许，而独占式访问被阻塞；独占式访问资源时，同一时刻其他访问均被阻塞。通过调用同步器的<code>acquireShared()</code>方法可以共享式的获取同步状态。</strong></p><p>在<code>acquireShared()</code>方法中，同步器调用<code>tryAcquiredShared()</code>方法尝试获取同步状态，当返回值大于等于0时，成功获取同步状态；否则失败进入自旋。在自旋过程中，如果当前节点的前驱节点为头节点，尝试获取同步状态，获取成功则退出自旋。</p><p>共享式通过调用<code>releaseShared()</code>方法释放同步状态，释放同步状态后，会唤醒后续在等待的节点，<strong>共享式释放必须保证同步状态安全释放，因为释放同步状态的操作可能同时来自多个线程，一般通过循环和CAS来保证。</strong></p><h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>同步器通过调用<code>doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException</code>方法可以超时获取同步状态。此方法在可响应中断的基础上，增加了超时获取特性。</p><p>该方法在自选过程中，当前节点的前驱节点为头节点时，尝试获取同步状态，获取成功则从方法返回。<strong>如果获取失败，则判断是否超时，如果没有超时，重新计算超时间隔<code>nanosTimeout</code>，然后使当前线程等待<code>nanosTimeout</code>纳秒。如果<code>nanosTimeout</code>小于等于1000纳秒，将不会使线程进入超市等待，而是进行自旋。因为超时非常短的情况下，进入超时等待会变得不精确。</strong></p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁<code>ReentrantLock</code>，表示该锁能够支持对一个资源重复加锁，此外，<code>ReentrantLock</code>还支持公平锁和非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sync = (ReentrantLock.Sync)(fair ? <span class="keyword">new</span> ReentrantLock.FairSync() : <span class="keyword">new</span> ReentrantLock.NonfairSync());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重进入"><a href="#重进入" class="headerlink" title="重进入"></a>重进入</h3><p>与<code>synchronized</code>隐式支持重进入不同，<strong><code>ReentrantLock</code>再次获取同步状态时，会判断当前线程是否是获取锁的线程，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取成功。</strong></p><p><strong><code>ReentrantLock</code>在释放同步状态时，会减少同步状态值。如果该锁被获取了n次，那么前n-1次释放都会返回false，只有同步状态值为0时，才会返回true，表示释放成功。</strong></p><h3 id="公平性与非公平性"><a href="#公平性与非公平性" class="headerlink" title="公平性与非公平性"></a>公平性与非公平性</h3><p>公平性指的是锁的获取顺序与请求的时间顺序，也就是FIFO。</p><p><strong>对于非公平锁，只要CAS设置同步状态成功，即表示成功获取了锁；而对于非公平锁，在同步队列中时，会判断是否有前驱节点，如果有前驱节点，则需要先等待前驱节点获取锁之后才能尝试获取锁。</strong></p><p><strong>一般情况下，非公平锁性能会比公平锁更好。公平锁保证了锁的获取按照FIFO原则，而代价是大量的线程切换；非公平锁虽然可能会造成线程饥饿，但极少的线程切换保证了更大的吞吐量。</strong></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>读写锁<code>ReentrantReadWriteLock</code>在同一时刻允许多个读线程访问，但在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性能相比排它锁有很大的提升。</strong></p><p><code>ReentrantReadWriteLock</code>特性：</p><table><thead><tr><th align="center">特性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">公平性选择</td><td align="center">支持非公平（默认）和公平的锁获取模式，吞吐量还是非公平优于公平</td></tr><tr><td align="center">重入性</td><td align="center">该锁支持重入锁，以读写线程为例：读线程在获取读锁之后，能够再次读取读锁，而写线程在获取写锁之后可以同时再次获取读锁和写锁</td></tr><tr><td align="center">锁降级</td><td align="center">遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级为读锁</td></tr></tbody></table><h3 id="读写锁接口"><a href="#读写锁接口" class="headerlink" title="读写锁接口"></a>读写锁接口</h3><p><code>ReadWriteLock</code>接口定义了获取读锁和获取写锁的方法，即<code>readLock()</code>方法和<code>writeLock</code>方法。而<code>ReentrantReadWriteLock</code>还定义了一些监控内部工作状态的方法。</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int getReadLockCount()</td><td align="center">返回当前读锁被获取的次数，不等于获取读锁的线程数</td></tr><tr><td align="center">int getReadHoldCount()</td><td align="center">返回当前线程获取读锁的次数，使用ThreadLocal保存</td></tr><tr><td align="center">boolean isWriteLocked()</td><td align="center">判断写锁是否被获取</td></tr><tr><td align="center">int getWriteHoldCount()</td><td align="center">返回当前写锁被获取的次数</td></tr></tbody></table><h3 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h3><p><code>ReentrantReadWriteLock</code>的 实现主要包括<strong>读写状态的设计、写锁的获取与释放、读锁的获取与释放、锁降级。</strong></p><h4 id="读写状态的设计"><a href="#读写状态的设计" class="headerlink" title="读写状态的设计"></a>读写状态的设计</h4><p>读写锁的的读写状态就是同步器的同步状态，需要在一个变量<code>private int volatile state</code>上维护多个读线程和一个写线程的状态，所以需要按位切割使用这个变量。</p><p><strong>读写锁将一个32位变量分为两个部分，高16位表示读，低16位表示写。读写锁通过位运算迅速确定读和写各自的状态，当同步状态不为0，写状态(高16位)为0时，代表读锁被获取。</strong></p><h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><p><strong>写锁是一个支持重进入的排它锁。如果当前线程获取写锁，则增加写状态。如果当前线程在获取写锁时，读锁已被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待</strong>。</p><p>写锁的释放与<code>ReentrantLock</code>一致，每次释放时减少写状态，当写状态为0时代表写锁已被释放，从而等待的读写线程能够继续访问读写锁。</p><h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><p><strong>读锁是一个支持重进入的共享锁，能够被多个读线程获取，并线程安全的增加读状态。如果当前线程已获取读锁，则增加读状态；如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待；如果当前线程获取了写锁或写锁未获取，则当前线程(CAS)增加读状态，成功获取读锁。</strong></p><p>读锁的释放每次均线程安全的减少读状态。</p><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>锁降级指的是写锁降级为读锁，具体就是把持当前拥有的写锁，再获取到读锁，随后释放写锁的过程。</p><p>锁降级中读锁的获取是必须的，是为了保证数据的可见性。如果不获取读锁而直接释放写锁，那么其他写线程可能会获取写锁修改数据。如果获取了读锁，那么其他写线程就会被阻塞。 </p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>任意一个Java对象都有一套方法<code>wait()、notify()、notifyAll()</code>等，可以与<code>synchronized</code>配合实现等待/通知模式。Condition接口也提供了类似的方法来配合Lock接口实现等待/通知模式。</p><h3 id="Condition接口方法"><a href="#Condition接口方法" class="headerlink" title="Condition接口方法"></a>Condition接口方法</h3><p>Condition对象是通过<code>Lock</code>接口的<code>newCondition()</code>方法构造出来的，所以Condition对象依赖<code>Lock</code>对象。</p><p>当前线程调用<code>await()</code>方法后，会释放锁并等待；其他线程调用<code>signal()</code>方法通知当前线程后，当前线程才会从<code>await()</code>方法返回，并且在返回前已经获得了锁。</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void await() throws InterruptedException</td><td align="center">当前线程进入等待状态直到被通知或者被中断，返回时代表已经获得了Condition对象对应的锁</td></tr><tr><td align="center">void awaitUninterruptibly()</td><td align="center">当前线程进入等待直到被通知，不响应中断</td></tr><tr><td align="center">long awaitNanos(long var1) throws InterruptedException</td><td align="center">当前线程进入等待状态直到被通知、中断、超时</td></tr><tr><td align="center">boolean awaitUntil(Date var1) throws InterruptedException</td><td align="center">当前线程进入等待状态直到被通知、中断或者到达某个时间</td></tr><tr><td align="center">void signal()</td><td align="center">唤醒一个等待在Condition上的线程，返回前必须获得与Condition关联的锁</td></tr><tr><td align="center">void signalAll()</td><td align="center">唤醒所有等待在Condition上的线程</td></tr></tbody></table><h3 id="Condition实现"><a href="#Condition实现" class="headerlink" title="Condition实现"></a>Condition实现</h3><p><code>ConditionObject</code>是AQS的内部类，每个Condition对象都有一个队列，该队列是实现等待/通知的关键。Condition的实现主要包括：<strong>等待队列、等待和通知。</strong></p><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>等待队列和同步队列中的节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。<strong>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，这个线程就是等待在Condition上的线程，如果一个线程调用了<code>await()</code>方法，那么该线程就会释放锁、构造成节点并加入等待队列。</strong></p><p><strong>一个Condition包含一个等待队列，其记录了等待队列的首尾节点。</strong></p><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>调用<code>await()</code>方法，会使当前线程进入等待队列并释放锁，<strong>相当于同步队列的首节点移动到等待队列的尾节点处。</strong></p><p><img src="https://f1bu920.github.io/images/Condition%E7%AD%89%E5%BE%85.png" alt=""></p><p>调用<code>await()</code>方法的线程会被构造成节点并添加到等待队列的尾部，然后释放同步状态，唤醒后续节点。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>调用<code>signal()</code>方法，将会唤醒等待队列的首节点，并将节点移到同步队列中去。</p><p><img src="https://f1bu920.github.io/images/Condition%E9%80%9A%E7%9F%A5.png" alt=""></p><p>节点加入到同步队列中去后，进而调用同步器的方法开始竞争同步状态，成功获取同步状态后，被唤醒的线程将从之前的<code>await()</code>处返回，此时已经成功获取了锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java中的锁&quot;&gt;&lt;a href=&quot;#Java中的锁&quot; class=&quot;headerlink&quot; title=&quot;Java中的锁&quot;&gt;&lt;/a&gt;Java中的锁&lt;/h1&gt;&lt;p&gt;本篇文章主要介绍juc包下与锁相关的API和组件，包括&lt;strong&gt;&lt;code&gt;Lock&lt;/code&gt;接口、&lt;code&gt;AQS&lt;/code&gt;抽象队列同步器、重入锁、读写锁和&lt;code&gt;Condition&lt;/code&gt;接口。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock接口&quot;&gt;&lt;a href=&quot;#Lock接口&quot; class=&quot;headerlink&quot; title=&quot;Lock接口&quot;&gt;&lt;/a&gt;Lock接口&lt;/h2&gt;&lt;p&gt;锁是用来控制多个线程访问资源的方式，除了&lt;code&gt;synchronized&lt;/code&gt;之外，juc包下还提供了&lt;code&gt;Lock&lt;/code&gt;接口来实现锁功能。其提供了与&lt;code&gt;synchronized&lt;/code&gt;类似的同步功能，但&lt;strong&gt;需要显示的获取、释放锁&lt;/strong&gt;，并且提供了更加强大的功能，如&lt;strong&gt;可中断的获取锁和超时获取锁等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt;接口提供了&lt;code&gt;synchronized&lt;/code&gt;关键字不具备的特性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;特性&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;尝试非阻塞的获取锁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;当前线程尝试获取锁，如果锁这一时刻没有被其他线程获取到，则成功获取并持有锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;可中断的获取锁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;获取到锁的线程能响应中断，拥有锁的线程被中断时，会抛出中断异常并释放锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;超时获取锁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在指定时间内获取锁，如果超时仍未获取锁，则返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt;接口的默认实现类为&lt;code&gt;ReentrantLock&lt;/code&gt;，&lt;code&gt;部分API如下：&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;void lock()&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;获取锁，调用该方法的线程尝试获取锁，获取成功后返回&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;void lockInterruptibly() throws InterruptedException&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;可中断的获取锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;boolean tryLock()&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;尝试非阻塞的获取锁，调用此方法后立即返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;boolean tryLock(long var1, TimeUnit var3) throws InterruptedException&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;超时获取锁，有三种可能会返回：超时、成功获取锁、被中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;void unlock()&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;释放锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Condition newCondition()&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;获取等待通知组件，该组件和当前的锁绑定，只有获取了锁才能调用此方法，并且调用后释放锁&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://yoursite.com/2020/09/08/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/09/08/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-08T03:23:13.000Z</published>
    <updated>2021-03-14T15:14:46.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可被虚拟机直接使用的Java类型，这个过程就叫虚拟机的类加载机制。Java中的加载、连接和初始化都是在运行期间完成的。类是在第一次使用时动态加载的，而不是一次性加载所有类。</p><a id="more"></a><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://f1bu920.github.io/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.JPG" alt=""></p><p>一个类型从被加载进虚拟机内存开始，到卸载出内存为止，整个生命周期会经历<strong>加载、验证、准备、解析、初始化</strong>、使用、卸载七个阶段。其中，验证、准备、解析称为连接。</p><h3 id="类加载的场景"><a href="#类加载的场景" class="headerlink" title="类加载的场景"></a>类加载的场景</h3><ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时</li><li>使用反射包的方法对类型进行反射调用时，如果类未加载，则需要先加载</li><li>初始化类时，其父类未初始化</li><li>虚拟机启动时会初始化入口类</li><li>…</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类加载过程包含<strong>加载、验证、准备、解析、初始化</strong>五个阶段</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载过程需要完成三件事：</p><ol><li>通过一个类的全限定名获取定义该类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个该类的Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其中二进制字节流可以通过以下方式获取：</p><ul><li>从ZIP压缩包中获取</li><li>从网络中获取</li><li>运行时计算生成</li><li>由其他文件生成</li><li>…</li></ul><p>注意：<strong>数组类型不通过类加载器创建，而是由虚拟机直接创建。</strong></p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p> 确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全.</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>为类中定义的类变量(被static修饰的变量)分配内存并设置类变量初始值, 使用的是方法区的内存.</p><p>注意：实例变量不会在此时分配，而是在对象实例化时随着对象一起分配在堆中。</p><p>初始化一般为零值，如<code>private static int value = 123;</code>初始化后值为0；</p><p>如果类变量是常量，那么将初始化为表达式定义的值，如·<code>private static final int value = 123;</code>初始化后值为123.</p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p><p>为了支持Java的动态绑定，解析步骤可以在初始化后再开始。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段才开始执行类中静态变量定义的初始化代码。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任何一个类，都必须由他的类加载器和类本身共同确定其在虚拟机中的唯一性，两个类相等，需要类本身相等并且使用同一个类加载器加载。</p><p>三个类加载器不是继承关系，而是组合关系</p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ul><li><p>启动类加载器(Bootstrap Class Loader)</p><p>最顶层的加载类，属于虚拟机的一部分，负责加载<JAVA_HOME>\lib目录下，或者被-Xbootclasspath参数指定的路径中存放的类。</p></li><li><p>扩展类加载器(Extension Class Loader)</p><p>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量指定的路径中的类库。</p></li><li><p>应用程序加载器(Application Class Loader)</p><p>负责加载用户路径下的所有类库。如果程序中没有自定义类加载器，一般情况下就是默认的类加载器。</p></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>应用程序由上面三种类加载器共同配合实现类加载，此外还可以定义自己的类加载器。</p><p><img src="https://f1bu920.github.io/images/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.JPG" alt=""></p><p>上图展示了类加载器间的层次关系，称为双亲委派模型。<strong>除了顶层的启动类加载器外，其他加载器都要有自己的父类加载器。</strong>这里的父子关系一般通过组合关系实现，而不是继承关系。</p><ul><li><p>工作过程</p><p><strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，所以类加载请求会传递给顶层的启动类加载器，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</strong></p></li><li><p>好处</p><p><strong>Java中的类随着他的类加载器具备一种带有优先级的层次关系，从而使得基础类得到同一。</strong></p><p>例如，如果我们自己编写一个名为<code>java.lang.Object</code>类，那么加载得到的仍然是系统自带的类，我们自己编写的类可以编译通过，但永远无法得到加载。</p></li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了<code>BootstrapClassLoader</code>，其它类加载器均由Java实现，且全部继承自<code>java.lang.ClassLoader</code>。因此自定义类加载器需要继承<code>java.lang.ClassLoader</code>。</p><p>破坏双亲委派模型：重写ClassLoader类的loadClass()方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM类加载机制&quot;&gt;&lt;a href=&quot;#JVM类加载机制&quot; class=&quot;headerlink&quot; title=&quot;JVM类加载机制&quot;&gt;&lt;/a&gt;JVM类加载机制&lt;/h1&gt;&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可被虚拟机直接使用的Java类型，这个过程就叫虚拟机的类加载机制。Java中的加载、连接和初始化都是在运行期间完成的。类是在第一次使用时动态加载的，而不是一次性加载所有类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java虚拟机" scheme="http://yoursite.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Java类加载" scheme="http://yoursite.com/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集器与内存分配策略</title>
    <link href="http://yoursite.com/2020/09/04/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/09/04/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2020-09-04T06:16:00.000Z</published>
    <updated>2021-03-07T05:55:48.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾收集器与内存分配策略"><a href="#JVM-垃圾收集器与内存分配策略" class="headerlink" title="JVM 垃圾收集器与内存分配策略"></a>JVM 垃圾收集器与内存分配策略</h1><p>Java是自动内存管理的，但了解相关的内存分配与回收机制仍然很重要。</p><p>在Java运行时数据区域中，程序计数器、虚拟机栈和本地方法栈都随着线程创建而创建，随着线程消亡而消亡，栈中的栈帧也随着方法的进入和退出而入栈和出栈，这部分的内存回收在编译后就是确定的。而<strong>堆和方法区中则有明显的不确定性，只有在运行时才能确定，内存的分配和回收都是动态的</strong>。通常意义上的垃圾回收都是指的对堆和方法区的回收。</p><a id="more"></a><h2 id="判断对象可回收"><a href="#判断对象可回收" class="headerlink" title="判断对象可回收"></a>判断对象可回收</h2><p>垃圾回收前首先要确定哪些对象是可回收的。主要有两种方法：</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>即在对象中添加一个引用计数器，每有一个对象引用它，引用计数器就加一；当引用失效时，计数器就减一。引用计数器为0的对象就是可回收的。</p><p>引用计数法虽然使用了一些额外的内存空间，但原理简单、效率也高，但Java并没有使用这种方法。因为这种方法要配合大量的额外处理才能正确工作，如当初的计数引用就无法解决相互循环引用的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过将一系列称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点通过引用关系向下搜索，搜索路径称为<strong>引用链</strong>，如果从<code>GC Root</code>到一个对象没有一条引用链相连，即从<code>GC Root</code>到这个对象不可达，则这个对象是可回收的。</p><p>可作为<code>GC Roots</code>的对象有：</p><ol><li>在虚拟机栈中引用的对象</li><li>在方法区中类静态属性对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li><li>Java虚拟机内部应用</li><li>所有被<code>synchronized</code>持有的对象</li></ol><h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>Java中将引用分为四种：<strong>强引用、软引用、弱引用、虚引用。</strong></p><ul><li><p>强引用</p><p><strong>强引用指的是程序代码中最常见的引用赋值，即<code>Object obj = new Object()</code>，无论何时，只要有强引用关系存在，垃圾收集器永远不会回收被引用的对象</strong>。</p></li><li><p>软引用</p><p><strong>软引用用来描述一些还有用但非必需的对象。只被软引用关联的对象，在将要发生内存溢出前会被回收。JDK提供了<code>SoftReference</code>类来实现软引用。</strong></p><p>场景：实现内存敏感的缓存，当有空闲内存时会暂时保留，当内存不足时被清理</p></li><li><p>弱引用</p><p><strong>弱引用也用来描述非必须的对象，但强度比软引用跟弱一些，被弱引用关联的对象只能生存到下次垃圾回收时。当垃圾回收开始时，无论内存是否足够，都会回收只被弱引用关联的对象。JDK提供了<code>WeakReference</code>类来实现弱引用</strong>。</p><p>场景：内存敏感的缓存</p></li><li><p>虚引用</p><p><strong>虚引用是最弱的一种引用关系，一个对象是否有虚引用不会对其生命周期造成影响，也无法通过虚引用获得对象实例。设置虚引用只是为了对象被回收时收到一个通知。JDK提供了<code>PhantomReference</code>类来实现虚引用。</strong></p><p>场景：可用来跟踪对象被垃圾回收的活动，当一个被虚引用关联的对象被回收时会收到一条系统通知</p></li></ul><h3 id="回收类"><a href="#回收类" class="headerlink" title="回收类"></a>回收类</h3><p>回收一个实例相对简单，但回收一个类型条件比较苛刻，需要同时满足下面三个条件：</p><ul><li><strong>该类的所有实例都已经被回收</strong>。</li><li><strong>该类的类加载器已经被回收</strong>。</li><li><strong>该类的类对象，即Class对象没有在其他地方被引用</strong>。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>即：<strong>收集器将Java堆分为不同的区域，根据对象的年龄分配到不同的区域中存储。</strong>一般分为<strong>新生代</strong>和<strong>老年代</strong>两个区域。</p><p>Java堆被划分为不同区域后，垃圾收集器可以每次只回收其中一个或几个区域，才有了<code>Minor Gc</code>、<code>Major GC</code>和<code>Full GC</code>，才可以根据不同的区域采用不同的垃圾回收算法：<strong>标记-清除、标记-复制、标记-整理。</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">部分收集<span class="comment">(Partial GC)</span>: 指不是完整收集整个Java堆的垃圾收集，又分为</span><br><span class="line">新生代收集<span class="comment">(Minor GC)</span></span><br><span class="line">老年代收集<span class="comment">(Major GC)</span>: 只有CMS收集器会有单独收集老年代的行为</span><br><span class="line"></span><br><span class="line">整堆收集<span class="comment">(Full GC)</span>：收集整个Java堆和方法区的垃圾收集</span><br></pre></td></tr></table></figure><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>标记-清除算法分为标记和清除两个部分，首先标记出所有要回收的对象，再统一回收被标记的对象。</strong></p><p>其主要有两个缺点：</p><ol><li><strong>执行效率不稳定：如果堆中包含大量要被回收的对象，就必须要进行大量的标记和清除的动作，导致标记和清除的效率随对象数量的增长而降低；</strong></li><li><strong>产生大量内存碎片：标记、清除后会产生大量的内存碎片，可能会导致没有足够的连续内存分配，从而触发另一次垃圾回收。</strong></li></ol><p><img src="https://f1bu920.github.io/images/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt=""></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>  <strong>标记-复制算法将内存按容量分为大小相等的两块，每次只使用其中一块，当一块内存用完了，就将还存活的对象复制到另一块内存中，然后把已使用的一块内存清除。</strong></p><p><strong>如果内存中大部分对象都是存活的，复制算法会产生大量的复制对象的开销；如果存活对象很少，复制算法开销就较小。而且因为每次都是回收整个半区，所以不会产生内存碎片。但是，可用内存缩小为原来的一半，空间浪费严重！</strong></p><p>因为新生代存活对象很少的特点，还有一种优化的复制分区策略：</p><p><strong>将新生代分为一块较大的<code>Eden</code>区和两块较小的<code>Survivor</code>空间。每次分配内存只使用<code>Eden</code>和一块<code>Survivor</code>空间。当发生垃圾回收时，将存活的对象复制到另一块<code>Survivor</code>上，直接清理掉Eden和已使用的那块<code>Survivor</code>空间。</strong></p><p><strong>当然，上面这种策略需要使用老年代的内存空间作为内存分配担保，当另一块<code>Survivor</code>空间不足时，直接将存活对象复制到老年代。</strong></p><p><img src="https://f1bu920.github.io/images/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt=""></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-复制算法在对象存活率较高时需要复制大量对象，效率较低，并且如果不想浪费一半空间，需要使用额外空间进行担保，所以老年代一般不会使用这种方法。</p><p><strong>标记-整理算法在标记后，不是直接将可回收对象清除，而是让所有存活对象向一端移动，然后直接清理边界以外的内存。</strong></p><p><img src="https://f1bu920.github.io/images/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt=""></p><p>移动存活对象并更新所有引用这些对象的引用，尤其是老年代这种存活率较高的区域，需要暂停所有的用户程序，开销较大。但如果像标记-清除算法那样不移动对象，又会产生内存碎片，要依赖更复杂的内存分配机制和内存访问机制。</p><p>移动则内存回收更复杂，不移动则内存分配更复杂。这就需要根据不同的场景进行权衡。</p><p>另一种综合的方法是让<strong>多数时间内采用标记-清除算法，直到内存的碎片化程度影响对象分配时，再采用标记-整理算法收集。</strong>这也是CMS垃圾收集器采用的策略。</p><h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><p><img src="https://f1bu920.github.io/images/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.JPG" alt=""></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://f1bu920.github.io/images/Serial%E6%94%B6%E9%9B%86%E5%99%A8.JPG" alt=""></p><p><code>Serial</code>收集器是单线程工作的收集器，在它进行垃圾收集时，必须暂停其他所有工作线程，直到收集完成。</p><p>它是Client场景下的默认新生代收集器，在该场景下内存不会太大，延时可以可以接受。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="https://f1bu920.github.io/images/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.JPG" alt=""></p><p><code>ParNew</code>收集器可以看成是<code>Serial</code>收集器的多线程版本。</p><p>它是Server场景下默认的新生代收集器，并且只有它能与CMS收集器配合使用。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>与<code>ParNew</code>一样是多线程收集器，其他收集器是为了缩短收集时用户线程的停顿时间，而它是为了提高吞吐量。这里吞吐量是指CPU用于用户线程的时间与总时间之比。</p><p><code>Parallel Scavenge</code>收集器可以通过一个参数打开GC自适应的调节策略，不需要手动设置新生代的大小、Eden与Survivor的比例、晋升老年代的年龄等参数，虚拟机会自动根据系统的运行情况收集监控信息，动态调整以获得最大的吞吐量。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>![](<a href="https://f1bu920.github.io/images/Serial" target="_blank" rel="noopener">https://f1bu920.github.io/images/Serial</a> Old收集器.JPG)</p><p>是Serial的老年代版本，主要供客户端模式下的虚拟机使用。</p><p>如果在服务端模式下，主要有两种用途：</p><ol><li>在JDK5之前版本中与Parallel Scavenge收集器配合使用；</li><li><strong>作为CMS收集器发生<code>Concurrent Mode Failure</code>时的后备预案。</strong></li></ol><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>![](<a href="https://f1bu920.github.io/images/Parallel" target="_blank" rel="noopener">https://f1bu920.github.io/images/Parallel</a> Old收集器.JPG)</p><p>是Parallel Scavenge收集器的老年代版本。</p><p>在注重吞吐量的场景下，优先考虑<code>Parallel Scavenge</code>加上<code>Parallel Old</code>收集器的组合。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><img src="https://f1bu920.github.io/images/CMS%E6%94%B6%E9%9B%86%E5%99%A8.JPG" alt=""></p><p>CMS：Concurrent Mark Sweep，使用的是标记-清除算法。分为四个流程：</p><ol><li><strong>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿</strong>；</li><li><strong>并发标记：从GC Roots直接关联的对象开始遍历整个对象图的过程，耗时较长但不需要停顿；</strong></li><li><strong>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿；</strong></li><li><strong>并发清除：清理标记阶段被判定已经死亡的对象，不需要停顿。</strong></li></ol><p>CMS收集器追求的是低停顿，举有以下缺点：</p><ul><li>吞吐量低：低停顿是以牺牲吞吐量为代价的，导致CPU利用率不高</li><li><strong>无法处理浮动垃圾：在并发标记和并发清除期间，用户程序继续运行，就会产生垃圾对象，而这部分垃圾只能到下一次垃圾收集时才能清理，这就叫做浮动垃圾。因为浮动垃圾的存在，需要预留一部分内存，不能像其他垃圾收集器一样等到老年代快满时再回收，如果预留的内存空间不足，就会导致<code>Concurrent Mode Failure</code>，冻结用户程序，临时采用<code>Serial Old</code>收集器来重新进行老年代的收集。</strong></li><li><strong>标记-清除算法导致的内存碎片：当找不到足够的内存来分配大对象时，就会提前触发一次<code>Full GC</code>。</strong></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器的主要关注点在于达到可控的停顿时间并在这基础上尽可能提高吞吐量。G1收集器开创了收集器面向局部收集的思路和基于<code>Region</code>的内存布局形式，是一款面向服务端的垃圾收集器，可用于整堆收集。</p><p><img src="https://f1bu920.github.io/images/Hotspot%E5%A0%86%E7%BB%93%E6%9E%84.JPG" alt="Hotspot堆布局"></p><p>其他收集器都是收集整个新生代或者老年代，而G1可以对整个新生代和老年代一起回收。</p><p><img src="https://f1bu920.github.io/images/G1%E5%A0%86%E7%BB%93%E6%9E%84.JPG" alt=""></p><p><strong>G1把堆分为许多大小相等的独立区域(Region)</strong>，新生代和老年代不再隔离。</p><p><strong>G1通过Region把内存分为了一块块的小空间，每块小空间都可以进行单独内存回收。G1收集器跟踪每个Region里面垃圾堆积的价值大小，即回收所获得空间大小与回收时间的比值，然后维护一个优先级列表，每次根据用户设定允许的收集停顿时间(-XX:MaxGCPasueMills)优先处理收益最高的Region</strong>。</p><p>G1会比CMS消耗更多的内存，因为每个Region都有一个<code>RememberedSet</code>，用来记录该Region对象的引用对象所在的Region，在可达性分析时就可以避免全表扫描。</p><p><img src="https://f1bu920.github.io/images/G1%E6%94%B6%E9%9B%86%E5%99%A8.JPG" alt=""></p><p>G1收集器的运行可分为4个步骤：</p><ol><li><strong>初始标记：标记GC Roots能直接关联到的对象，需要停顿但耗时短</strong></li><li><strong>并发标记：从GC Roots开始进行可达性分析，递归扫描整个堆中的对象图，耗时较长但不需要停顿</strong></li><li><strong>最终标记：修正在并发标记期间因程序继续运行而标记产生变动的那部分记录，需要停顿但可并行执行</strong></li><li><strong>筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望停顿时间来制定回收计划。把回收那一部分的Region中的存活对象复制到空的Region中，再清除旧的Region的全部空间，需要暂停用户线程但可并行执行。</strong></li></ol><p>特点：</p><ul><li><strong>空间整合：整体上是基于标记-整理算法实现的，但局部(两个Region之间)上看是基于标记-复制算法的，这代表着不会有内存碎片。</strong></li><li><strong>可预测的停顿：用户可设置不同的期望停顿时间来取得吞吐量和延迟的最佳平衡。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-垃圾收集器与内存分配策略&quot;&gt;&lt;a href=&quot;#JVM-垃圾收集器与内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾收集器与内存分配策略&quot;&gt;&lt;/a&gt;JVM 垃圾收集器与内存分配策略&lt;/h1&gt;&lt;p&gt;Java是自动内存管理的，但了解相关的内存分配与回收机制仍然很重要。&lt;/p&gt;
&lt;p&gt;在Java运行时数据区域中，程序计数器、虚拟机栈和本地方法栈都随着线程创建而创建，随着线程消亡而消亡，栈中的栈帧也随着方法的进入和退出而入栈和出栈，这部分的内存回收在编译后就是确定的。而&lt;strong&gt;堆和方法区中则有明显的不确定性，只有在运行时才能确定，内存的分配和回收都是动态的&lt;/strong&gt;。通常意义上的垃圾回收都是指的对堆和方法区的回收。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java虚拟机" scheme="http://yoursite.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://yoursite.com/2020/07/21/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/07/21/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-07-21T02:51:31.000Z</published>
    <updated>2020-11-04T14:16:56.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>与C++不同，在虚拟机自动内存管理机制下，对象不需要手动的delete/free，不容易出现内存泄露和内存溢出。但了解Java运行时数据区域仍然非常重要。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行程序时会把内存分为若干个不同的数据区域，每个数据区域都有各自的用途以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有的区域则是依赖用户线程的启动和结束而建立和销毁。</p><p>JDK1.8之前：</p><p><img src="https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F1.6.JPG" alt="图源JavaGuide"></p><p>JDK1.8:</p><p><img src="https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F1.8.JPG" alt="图源JavaGuide"></p><p>其中，<strong>堆、方法区和直接内存(非运行时数据区)是线程共享的，程序计数器、虚拟机栈和本地方法栈是线程私有的。</strong></p><a id="more"></a><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><strong>程序计数器是一块较小的内存区间，其可以看成当前线程所执行的字节码的行号指示器。字节码指示器通过改变程序计数器的值来完成流程控制、异常处理和线程恢复等功能。</strong></p><p>现代处理器是通过cpu时间片轮转的方式进行线程调度，每次上下文切换为了能恢复到正确的执行位置，每个线程都需要有一个自己私有的程序计数器，各个线程间的程序计数器互不影响，相互独立。</p><p>程序计数器可以看成是“线程私有”的内存，且这是唯一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，虚拟机栈也是线程私有的，其生命周期与线程相同。<strong>每个Java方法被执行时，虚拟机都会创建一个栈帧用于存储局部变量表、操作数表、动态连接、方法出口等信息。每个方法被调用到执行完毕对应了一个栈帧从入栈到出栈的过程。</strong></p><p>如果线程请求的栈深度大于虚拟机允许的深度，就会跑出<code>StackOverflowException</code>；</p><p>如果栈扩展到无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈类似，虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。</p><p>同样，本地方法栈也会抛出<code>StackOverflowException</code>和<code>OutOfMemoryError</code>。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h4><p><strong>Java堆是垃圾收集器管理的内存区域，也叫“GC堆”，是几乎所有对象实例分配内存的地方，被所有线程所共享，在虚拟机启动时创建。</strong></p><p>由于现代垃圾收集器采用分代收集算法，所以堆又被分为“新生代”和“老年代”。其中，新生代中采用复制算法，又分为一个eden区和两个survivor区。</p><p>Java堆是可扩展的，可通过参数<code>-Xms</code>和<code>-Xmx</code>设置。如果堆中内存不够完成对象分配又无法扩展时会抛出<code>OOM</code>异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区与堆一样，是线程共享的内存区域，用于存储已加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p>在Java8以前，方法区是用永久代实现的，这样收集器的分代设计就可以扩展至方法区。但是这种策略容易造成内存溢出，所以到Java8后，就改成了用本地内存来实现方法区，完全废弃了永久代的概念，直接用在本地内存上实现的元空间来替代。</p><p>方法区如果无法满足新的内存分配需求，也会抛出<code>OOM</code>异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。</p><h3 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li><p><strong>类加载检查</strong></p><p>当虚拟机遇到一条<code>new</code>指令后，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，则执行类加载过程。</p></li><li><p><strong>分配内存</strong></p><p>通过类加载检查后，对象所需的内存大小即可确定，接下来为新生对象分配内存。分配内存分为<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种形式。</p><ul><li>前者堆中内存是规整的，即被使用过的内存放在一边，空闲内存放在另一边，中间使用一个指针作为分界点的指示器，分配内存时就是将指针向空闲内存方向移动对象大小的距离。</li><li>后者堆中内存不是规整的，已被使用的内存和空闲内存交错在一起，虚拟机维护一个列表记录那些内存块是可用的，在分配内存时从列表中找到一块足够大的空间划分给对象，并更新列表的记录。</li></ul><p><strong>内存分配方式由Java堆是否规整决定，而堆是否规整则是由垃圾收集器采用的回收算法决定。</strong></p><p><strong>分配内存的线程安全问题解决</strong>：</p><p>在多线程环境下，可能出现正在给对象A分配内存，指针还未修改，对象B又使用了原来的指针来进行分配内存的情况。有两种解决方案：</p><ul><li>对分配内存动作进行同步操作，采用CAS加上失败重试来保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在堆中预先分配一小块内存，称为本地线程分配缓冲：TLAB，线程在自己的本地缓冲区中分配内存，当本地缓冲区用完了再触发同步操作。可通过虚拟机参数：-XX:+/-UserTLAB参数来指定是否使用。</li></ul></li><li><p><strong>初始化零值</strong></p><p>内存分配完成后，需要将分配到的内存空间(不包括对象头)进行初始化零值。这保证了Java代码可以不赋初值就可以使用。</p></li><li><p><strong>对象头设置</strong></p><p>接下来对对象进行必要的设置，如对象对应类的元数据信息、对象的哈希码、对象的GC分代年龄、是否启用偏向锁等。</p></li><li><p><strong>进行初始化</strong></p><p>最后进行构造函数的初始化，即执行Class文件中的<code>&lt;init&gt;()</code>方法，一个对象就构造完成。</p></li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在堆中的内存布局可分为三个部分：对象头、实例数据和对齐填充。</p><ul><li>对象头分为两部分信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标记、线程持有的锁、偏向线程ID、偏向时间戳等，被称为“<code>Mark Word</code>”。第二类是类型指针，通过这个指针来确定该对象是哪个类的实例。如果是数组，还必须有一块用于记录数组长度的空间。</li><li>示例数据是对象真正存储的有效信息。</li><li>对齐填充则是起到占位符的作用，JVM的自动内存管理系统要求对象起始地址必须是8的整数倍，即任何对象的大小都为8字节的整数倍。</li></ul><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>Java程序通过栈上的<code>reference</code>数据来操作堆上的对象，这个引用有两种实现方式：</p><ul><li>句柄访问，Java堆中划分出一块内存作为句柄池，reference中存储对象的句柄地址，而句柄中包含了对象示例数据与类型数据各自具体的地址信息。</li><li>直接指针访问，reference中保存的是对象地址，但必须要考虑如何访问类型数据的相关信息。</li></ul><p>使用句柄访问的优势是reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄池中的实例数据指针，而reference本身不需要修改。</p><p>使用直接指针的好处就是速度更快，节省了一次指针定位的时间开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h2&gt;&lt;p&gt;与C++不同，在虚拟机自动内存管理机制下，对象不需要手动的delete/free，不容易出现内存泄露和内存溢出。但了解Java运行时数据区域仍然非常重要。&lt;/p&gt;
&lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;Java虚拟机在执行程序时会把内存分为若干个不同的数据区域，每个数据区域都有各自的用途以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有的区域则是依赖用户线程的启动和结束而建立和销毁。&lt;/p&gt;
&lt;p&gt;JDK1.8之前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F1.6.JPG&quot; alt=&quot;图源JavaGuide&quot;&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F1.8.JPG&quot; alt=&quot;图源JavaGuide&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;堆、方法区和直接内存(非运行时数据区)是线程共享的，程序计数器、虚拟机栈和本地方法栈是线程私有的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java虚拟机" scheme="http://yoursite.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Java运行时数据区" scheme="http://yoursite.com/tags/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://yoursite.com/2020/07/12/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/12/Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-07-12T03:45:56.000Z</published>
    <updated>2020-07-13T09:26:31.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p>泛型的意思就是<strong>参数化类型</strong>。在没有引入泛型机制前，需要针对不同的数据类型重复编写相同的代码，而引入泛型后就可以<strong>将数据类型与代码逻辑分离开，提高了程序的简洁性和可读性，同时也提供了编译时的类型转换安全检测功能。</strong></p><p>泛型可以将类型参数化，参数一旦确定，如果类型不匹配，就无法通过编译。</p><a id="more"></a><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型的使用可以分为：</p><ul><li>泛型类</li><li>泛型方法</li><li>泛型接口</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>对于任意一个类型，可以用字母来表示泛型类型，如<code>List&lt;T&gt;</code>，这种是确定的类型，而使用通配符<code>&lt;?&gt;</code>则可以指定泛型中的类型范围。</p><ol><li><code>&lt;?&gt;</code> 是无限定的通配符；</li><li><code>&lt;? extends A&gt;</code>是有上界的通配符，限定类<code>A</code>和<code>A</code>的子类；</li><li><code>&lt;? super A&gt;</code>是有下界的通配符，限定<code>A</code>和<code>A</code>的父类。</li></ol><p><strong>即便容器的类型之间存在继承关系，但容器间是不构成继承关系的。所以需要将容器类型设置为<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>来让容器间存在继承关系。</strong></p><p><img src="https://f1bu920.github.io/images/Java%E6%B3%9B%E5%9E%8Bextends.png" alt=""></p><p>对于上界<code>&lt;? extends T&gt;</code>类型，在编译期，只知道要存放<code>T</code>和<code>T</code>的子类，具体类型不知道，所以往容器内插入数据不被允许。但读数据时，可以隐式的转化为基类或者Object，所以读操作没有影响。</p><p><img src="https://f1bu920.github.io/images/Java%E6%B3%9B%E5%9E%8Bsuper.png" alt=""></p><p>对于下界<code>&lt;? super T&gt;</code>类型，规定了元素的最小粒度，必须是<code>T</code>或其父类，所以往里添加<code>T</code>或其子类都是可以的，因为可以隐式的转化为T类型。而读时无法转化为任意类型，只能用Object类存储。</p><p>注意：</p><ul><li><strong>上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取，适合频繁往外面读取内容的场景。</strong></li><li><strong>下界<code>&lt;? super T&gt;</code>不影响往里存，但往外取只能放在Object数组中，适合经常往里面插入数据的场景</strong>。</li></ul><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>泛型信息只存在于编译阶段，在进入JVM前，所有的泛型信息都会被擦除，这就是类型擦除。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list1.getClass()==list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果输出为true</span></span><br></pre></td></tr></table></figure><p>上面举例中编译后<code>list1</code>和<code>list2</code>的类型都为<code>List.class</code>，泛型信息被擦除了。</p><p>在泛型类被类型擦除后，如果泛型类中没有指定上界，如<code>&lt;T&gt;</code>，就会被转译为<code>Object</code>类型；如果指定了上界，就会被转译为上界类型。</p><p>类型擦除保证了能与JDK5之前的代码兼容，但也带来了一些局限性，比如可以通过反射来绕过泛型。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"String"</span>);</span><br><span class="line">        Class&lt;? extends List&gt; aClass = list.getClass();</span><br><span class="line">        Method add = aClass.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        add.invoke(list, <span class="number">777</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为[String, 777]</span></span><br></pre></td></tr></table></figure><p>可以看到利用反射可以向指定了类型为<code>String</code>的集合中添加非<code>String</code>类型的元素。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://juejin.im/post/5b614848e51d45355d51f792" target="_blank" rel="noopener">深入理解Java泛型</a></p><p><a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">Java泛型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java泛型&quot;&gt;&lt;a href=&quot;#Java泛型&quot; class=&quot;headerlink&quot; title=&quot;Java泛型&quot;&gt;&lt;/a&gt;Java泛型&lt;/h2&gt;&lt;p&gt;泛型的意思就是&lt;strong&gt;参数化类型&lt;/strong&gt;。在没有引入泛型机制前，需要针对不同的数据类型重复编写相同的代码，而引入泛型后就可以&lt;strong&gt;将数据类型与代码逻辑分离开，提高了程序的简洁性和可读性，同时也提供了编译时的类型转换安全检测功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;泛型可以将类型参数化，参数一旦确定，如果类型不匹配，就无法通过编译。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java泛型" scheme="http://yoursite.com/tags/Java%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2020/07/08/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/08/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-07-08T02:03:18.000Z</published>
    <updated>2020-07-08T03:09:02.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><blockquote><p>Java 反射机制在程序<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>Java 的反射机制</strong>。</p></blockquote><blockquote><p>反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 <code>.class</code> 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 <code>.class</code> 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p></blockquote><p>反射可以实现在运行时知道一个类的属性和方法。</p><p><img src="https://f1bu920.github.io/images/Javareflect.png" alt=""></p><a id="more"></a><h3 id="Java反射的优缺点"><a href="#Java反射的优缺点" class="headerlink" title="Java反射的优缺点"></a>Java反射的优缺点</h3><ul><li><p>优点</p><p>可以实现动态的创建对象和编译，有很大的灵活性。</p></li><li><p>缺点</p><p>反射是一种解释操作，对性能有影响，如使用反射来创建对象效率比不上直接使用<code>new</code>关键字，因为要先查找类资源，再使用类加载器创建。</p></li></ul><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p><code>Class</code>类是实现反射的基础。<code>Class</code>类的构造器是私有的，这意味着只有JVM才能创建一个<code>Class</code>类型的对象，而不可以直接使用<code>new</code>关键字。共有三种方法来获得一个<code>Class</code>对象：</p><ol><li><code>Class.forName(&quot;类路径&quot;)</code>：通过调用<code>forName</code>方法，通过一个类的全量限定名来获得。</li><li><code>类名.class</code>：任何一个类都有一个隐藏的成员变量<code>class</code>，通过类的静态成员变量来获得</li><li><code>对象名.getClass()</code>：通过一个类的对象的<code>getClass</code>方法获得。</li></ol><h3 id="Java反射API"><a href="#Java反射API" class="headerlink" title="Java反射API"></a>Java反射API</h3><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ol><li><code>Class</code> 类：反射的核心类，可以获取类的属性，方法等信息。</li><li><code>Field</code>类：Java.lang.reflec包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li><code>Method</code> 类： Java.lang.reflec包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li><code>Constructor</code> 类： Java.lang.reflec 包中的类，表示类的构造方法。</li></ol><p><strong>使用反射需要先获取操作类的<code>Class</code>对象，通过<code>Class</code>对象可以获取类的信息和方法属性。</strong></p><ul><li>获取<code>public</code>的变量信息<code>getFields()</code>。</li><li>获取变量信息<code>getDeclaredFields()</code>。</li><li>获取<code>public</code>的方法信息<code>getMethods()</code></li><li>获取方法信息<code>getMethods()</code>。</li><li>获得方法访问权限<code>getModifiers()</code></li><li>获得方法返回类型<code>getReturnType()</code></li><li>获得方法参数<code>getParameters()</code></li></ul><p><strong>获取到方法后，使用<code>invoke</code>反射调用私有方法。对于私有方法和变量，注意要先获得访问权`setAccessible(</strong>true<strong>)`</strong>。</p><h3 id="利用反射动态创建对象实例"><a href="#利用反射动态创建对象实例" class="headerlink" title="利用反射动态创建对象实例"></a>利用反射动态创建对象实例</h3><ol><li><p>使用 <code>Class</code> 对象的 <code>newInstance()</code>方法来创建该 <code>Class</code> 对象对应类的实例，但是这种方法要求该 <code>Class</code> 对象对应的类有默认的空构造器。 调用 <code>Constructor</code> 对象的 <code>newInstance()</code></p></li><li><p>先使用 <code>Class</code> 对象获取指定的 <code>Constructor</code> 对象，再调用 <code>Constructor</code> 对象的 <code>newInstance()</code>方法来创建 <code>Class</code> 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p></li></ol><p>反射在<code>JavaEE</code>中也有广泛的应用，如<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver.class&quot;)</code>就是用来加载MySQL的驱动类。此外，<code>Spring</code>中也用到了大量的反射。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">Java反射机制</a></p><p><a href="https://juejin.im/post/598ea9116fb9a03c335a99a4" target="_blank" rel="noopener">Java反射由浅入深</a></p><p><a href="https://juejin.im/post/5ea92cbd5188256d9a28cd40" target="_blank" rel="noopener">Java反射高频面试题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java反射&quot;&gt;&lt;a href=&quot;#Java反射&quot; class=&quot;headerlink&quot; title=&quot;Java反射&quot;&gt;&lt;/a&gt;Java反射&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Java 反射机制在程序&lt;strong&gt;运行时&lt;/strong&gt;，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 &lt;strong&gt;动态的获取信息&lt;/strong&gt; 以及 &lt;strong&gt;动态调用对象的方法&lt;/strong&gt; 的功能称为 &lt;strong&gt;Java 的反射机制&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 &lt;code&gt;.class&lt;/code&gt; 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 &lt;code&gt;.class&lt;/code&gt; 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反射可以实现在运行时知道一个类的属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Javareflect.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java异常</title>
    <link href="http://yoursite.com/2020/07/05/Java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2020/07/05/Java%E5%BC%82%E5%B8%B8/</id>
    <published>2020-07-05T03:02:00.000Z</published>
    <updated>2020-07-05T03:49:45.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p>下图是Java异常层次结构图：</p><p><img src="https://f1bu920.github.io/images/Java%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%84.png" alt=""></p><p>在Java中，<strong>所有的异常都有一个公共父类<code>Throwable</code>，其有两个重要的子类<code>Error</code>错误和<code>Exception</code>异常。其中，<code>Error</code>大多是虚拟机层面发生的错误，是程序无法处理的错误；而<code>Exception</code>则是用户程序可以捕获或可以处理的异常。<code>Exception</code>可以分为运行时异常<code>RuntimeException</code>和非运行时异常；又可以分为不受检查异常<code>Unchecked Exception</code>和检查异常<code>Checked Exception</code>。</strong></p> <a id="more"></a><p><code>Exception</code>中有一个重要的子类运行时异常<code>RuntimeException</code>，常见的异常如空指针异常<code>NullPointerException</code>、算数异常<code>ArithmeticException</code>、数组下标越界异常<code>ArrayIndexOutOfBoundsException</code>、丢失资源异常<code>MissingResourceException</code>、找不到类异常<code>ClassNotFoundException</code>和参数异常<code>IllegalArgumentsException</code>等。<strong>这些异常都是不检查异常，程序可以选择捕获处理也可以选择不处理。而<code>RuntimeException</code>之外的异常都是检查异常，必须选择<code>try-catch</code>进行捕获或者<code>throws</code>进行抛出，否则通不过编译。</strong></p><h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><p><strong>Java异常处理本质上是抛出异常和捕获异常。</strong></p><p>运行时异常由Java运行时系统自动抛出，允许程序忽略。而对于所有的检查异常，必须进行捕获处理或者抛出给它的调用者，如<code>IOException</code>。</p><ul><li><p>捕获异常</p><p>通过<code>try-catch-finally</code>语句块进行捕获异常。可能发生异常的代码块放在<code>try</code>中，并使用<code>catch</code>进行捕获发生的异常，可以选择使用<code>finally</code>块进行资源的关闭，因为<code>finally</code>块中的代码一定会被执行。</p><p><strong>注意有多个<code>catch</code>语句时，异常会依次进行检查，直到被匹配。因此异常要先小后大，先子类后父类。</strong></p></li><li><p>抛出异常</p><p>抛出异常分为手动抛出和系统抛出。</p><p>程序中可以使用<code>throw</code>关键字手动抛出异常。对于不受检查异常，系统会自动抛出异常。</p><p>如果在一个方法中可能导致一个异常但不处理，则必须在方法声明处使用<code>throws</code>指出抛出异常的列表。</p><p>*<em>如果是不受检查异常<code>Unchecked Exception</code>，如<code>Error</code>和<code>RuntimeException</code>，那么可以不使用<code>throws</code>关键字来声明抛出的异常，在运行时系统会自动抛出。    *</em></p><p><strong>如果是检查异常<code>Checked Exception</code>，则必须选择进行<code>try-catch</code>捕获处理或者<code>throws</code>抛出。否则无法通过编译。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java异常&quot;&gt;&lt;a href=&quot;#Java异常&quot; class=&quot;headerlink&quot; title=&quot;Java异常&quot;&gt;&lt;/a&gt;Java异常&lt;/h2&gt;&lt;p&gt;下图是Java异常层次结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Java中，&lt;strong&gt;所有的异常都有一个公共父类&lt;code&gt;Throwable&lt;/code&gt;，其有两个重要的子类&lt;code&gt;Error&lt;/code&gt;错误和&lt;code&gt;Exception&lt;/code&gt;异常。其中，&lt;code&gt;Error&lt;/code&gt;大多是虚拟机层面发生的错误，是程序无法处理的错误；而&lt;code&gt;Exception&lt;/code&gt;则是用户程序可以捕获或可以处理的异常。&lt;code&gt;Exception&lt;/code&gt;可以分为运行时异常&lt;code&gt;RuntimeException&lt;/code&gt;和非运行时异常；又可以分为不受检查异常&lt;code&gt;Unchecked Exception&lt;/code&gt;和检查异常&lt;code&gt;Checked Exception&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="http://yoursite.com/2020/06/24/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/24/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-24T02:08:47.000Z</published>
    <updated>2020-10-03T03:02:53.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><h3 id="一-选择排序"><a href="#一-选择排序" class="headerlink" title="一. 选择排序"></a>一. 选择排序</h3><p>在循环中，每次找到剩下数组中最小的元素，并将这个最小的元素与当前元素交换位置。最后，整个数组就是有序的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//k记录最小元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="comment">//在剩下元素中找最小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[k]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小元素不是自己，则交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"selectSort:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序是最稳定的排序算法，哪怕是已经有序的数组进行选择排序的<strong>时间复杂度仍为<code>O(n^2)</code></strong>，其不会利用数组的初始状态。<strong>空间复杂度为<code>O(1)</code></strong>。</p><h3 id="二-插入排序"><a href="#二-插入排序" class="headerlink" title="二. 插入排序"></a>二. 插入排序</h3><p>与选择排序一样，插入排序当前索引左侧的所有元素都是有序的，但他们的最终位置不确定。</p><p>对于当前元素<code>current</code>，取出上一个元素<code>arr[preIndex]</code>，如果上一个元素大于当前元素则将其移动到其下一个位置，重复此过程。这就相当于将<code>current</code>左侧比<code>current</code>大的元素全部右移一位，给<code>current</code>腾出位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前元素</span></span><br><span class="line">        <span class="keyword">int</span> current = arr[i];</span><br><span class="line">        <span class="comment">//如果上一个元素大于当前元素则将其右移一位，重复此过程</span></span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将current插入到该腾出的位置</span></span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"insertSort:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序利用了初始数组部分有序的特点，因此适合于局部有序的情况。</p><p><strong>平均时间复杂度为<code>O(n^2)</code>，对于已经有序的数组，时间复杂度为<code>O(n)</code>。空间复杂度为<code>O(1)</code>。</strong></p><h3 id="三-希尔排序"><a href="#三-希尔排序" class="headerlink" title="三. 希尔排序"></a>三. 希尔排序</h3><p>希尔排序是基于插入排序的改进排序算法。对于大规模乱序数组，插入排序很慢，因为它只会移动相邻的元素。希尔排序为了加快速度改进了插入排序，交换不相邻的元素以对数组进行局部排序，并最终用插入排序对局部有序的数组进行排序。</p><p>设置<code>h</code>作为间隔，对于每个<code>h</code>，用插入排序将<code>h</code>个子数组进行独立的排序，只需将插入排序中移动元素的距离由1改为<code>h</code>即可。</p><p>希尔排序比插入排序高效的原因是其权衡了子数组的规模和有序性。排序之初，子数组都很小，排序后子数组是局部有序的，这都有利于插入排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//h= 1, 4, 13, 40, 121, 364, 1093</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//将数组变为h有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - h;</span><br><span class="line">            <span class="keyword">int</span> current = arr[i];</span><br><span class="line">            <span class="comment">//将当前元素插入到arr[i-h]、arr[i-2*h]....中去</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">                arr[preIndex + h] = arr[preIndex];</span><br><span class="line">                preIndex -= h;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + h] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我个人本地随机数组测试中，当数据规模大于等于10000时，希尔排序比插入排序近似快了一倍，且随着数据规模的扩大，速度差距也跟着扩大。</p><p>希尔排序的平均复杂度为<code>O(n^1.3)</code>，最坏时间复杂度为<code>O(n^2)</code>，最好时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h3 id="四-归并排序"><a href="#四-归并排序" class="headerlink" title="四. 归并排序"></a>四. 归并排序</h3><p>归并排序是建立在归并基础上的排序算法。归并时将元素复制到辅助数组<code>aux</code>中，再把归并结果放回到原数组中。</p><h4 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h4><p>自顶向下的归并排序是分治思想的典型示例。要对子数组<code>arr[left, right]</code>进行排序，先将其分为<code>arr[left...mid]</code>和<code>arr[mid+1...right]</code>两部分，分别通过递归调用将他们单独排序，最后将排序好的子数组归并成最终的排序结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//用到的辅助数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] aux;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.length;</span><br><span class="line">       aux = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> value:arr)&#123;</span><br><span class="line">           System.out.print(value+<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//递归终止条件</span></span><br><span class="line">       <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//将左半部分排序</span></span><br><span class="line">       mergeSort(arr, left, mid);</span><br><span class="line">       <span class="comment">//将右半部分排序</span></span><br><span class="line">       mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">       <span class="comment">//归并</span></span><br><span class="line">       <span class="comment">//当arr[mid] &lt;= arr[mid + 1]时已经有序，可以跳过归并</span></span><br><span class="line">       <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">           merge(arr, left, mid, right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//i,j为两个指针，起始时分别指向两个已经排序序列的起始位置</span></span><br><span class="line">       <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//将需要归并部分复制到辅助数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">           aux[k] = arr[k];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">           <span class="comment">//左半部分用尽，取右半部分元素</span></span><br><span class="line">           <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">               arr[k] = aux[j++];</span><br><span class="line">               <span class="comment">//右半部分用尽，取左半部分元素</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">               arr[k] = aux[i++];</span><br><span class="line">               <span class="comment">//左半部分的当前元素小于右半部分的当前元素</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt; aux[j]) &#123;</span><br><span class="line">               arr[k] = aux[i++];</span><br><span class="line">               <span class="comment">//左半部分的当前元素大于等于右半部分的当前元素</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               arr[k] = aux[j++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h4><p>自底向上的归并排序使用的是迭代的形式，先归并小数组，再成对归并得到的子数组。</p><p>初始时设置步长<code>sz</code>为1，因为是成对归并，所以每次步长长度增长一倍即<code>sz = sz + sz</code>。</p><p>枚举数组左边界<code>lo</code>，<code>lo</code>从0开始，每次增长一对<code>sz</code>的大小，将这一对<code>sz</code>大小的区间进行归并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortIterator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//步长增长一倍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz = sz + sz) &#123;</span><br><span class="line">        <span class="comment">//子数组一对一对的归并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; n - sz; lo = lo + sz + sz) &#123;</span><br><span class="line">            <span class="comment">//注意右边界要小于等于n-1</span></span><br><span class="line">            merge(arr, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将需要归并部分复制到辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        aux[k] = arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        <span class="comment">//左半部分用尽，取右半部分元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            arr[k] = aux[j++];</span><br><span class="line">            <span class="comment">//右半部分用尽，取左半部分元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            arr[k] = aux[i++];</span><br><span class="line">            <span class="comment">//左半部分的当前元素小于右半部分的当前元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt; aux[j]) &#123;</span><br><span class="line">            arr[k] = aux[i++];</span><br><span class="line">            <span class="comment">//左半部分的当前元素大于等于右半部分的当前元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并排序的时间复杂度为<code>O(nlogn)</code>, 空间复杂度为<code>O(n)</code>。</strong></p><p>在归并排序中使用了全局辅助数组<code>aux</code>，更好的做法是把<code>aux</code>作为<code>mergeSort</code>方法的局部变量，并把它作为参数每次传递给<code>merge</code>方法。</p><p><a href="[https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Java](https://zh.wikipedia.org/wiki/归并排序#Java)">Wiki-归并排序</a></p><h3 id="五-快速排序"><a href="#五-快速排序" class="headerlink" title="五. 快速排序"></a>五. 快速排序</h3><p>快速排序也是一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序与归并排序是互补的：归并排序将数组分成两部分分别排序，并将有序的子数组归并来将整个数组排序；而快速排序则是当两个子数组都有序时整个数组就有序了。归并排序的递归调用发生在处理整个数组之前；快速排序的递归调用发生在处理整个数组之后。</p><p>快速排序通过递归调用切分来排序。先排定一个基准元素，一般是<code>arr[left]</code>，然后从数组左端开始扫描直到找到一个比他大的元素，再从数组右端进行扫描直到找到一个比他小的元素。交换他们的位置，直到左右指针相遇，再将基准元素与相遇位置的元素交换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"quickSort:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, j - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, j + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i，j为左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//key为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> key = arr[left];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//向右扫描直到遇到一个大于等于基准的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; key) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向左扫描直到遇到一个小于等于基准的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; key) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == left) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针相遇时结束</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换i，j位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换基准元素与相遇时元素位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的平均时间复杂度为<code>O(nlogn)</code>，最坏时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(nlogn)</code>。</strong></p><h3 id="六-堆排序"><a href="#六-堆排序" class="headerlink" title="六. 堆排序"></a>六. 堆排序</h3><p>堆是一种近似二叉树的结构，一般用一维数组表示，且子节点的键值或索引总小于(或者大于)他的父节点。若按升序排列，则把数组换成最大堆。重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p><p>对于起始索引为0的数组来说，节点索引为<code>i</code>的节点：</p><ul><li>左子节点为<code>2*i+1</code>；</li><li>右子节点为<code>2*i+2</code>;</li><li>父节点为<code>floor((i-1)/2)</code>。</li></ul><p>堆中最大值总是位于根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//将数组堆化， beginIndex为第一个非叶子节点索引，叶子节点可以看成满足堆结构的节点</span></span><br><span class="line">       <span class="keyword">int</span> beginIndex = (arr.length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           maxHeapify(i, len, arr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对堆化数据排序</span></span><br><span class="line">       <span class="comment">//每次都移出最顶层的根节点与最尾部节点进行交换，同时遍历长度减一</span></span><br><span class="line">       <span class="comment">//然后重新整理被交换到根节点的元素进行下沉操作使其满足堆的结构</span></span><br><span class="line">       <span class="comment">//直到未排序堆的长度为0</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">           arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">           arr[i] = temp;</span><br><span class="line">           maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>, arr);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"HeapSort:"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">           System.out.print(value + <span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//调整索引为index处的元素，使其满足堆结构，len为未排序堆的长度</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//左子节点索引</span></span><br><span class="line">       <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//右子节点索引</span></span><br><span class="line">       <span class="keyword">int</span> ri = li + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//左子节点超出计算范围</span></span><br><span class="line">       <span class="keyword">if</span> (li &gt; len) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//子节点最大值索引，初始默认为左节点</span></span><br><span class="line">       <span class="keyword">int</span> maxIndex = li;</span><br><span class="line">       <span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[li] &lt; arr[ri]) &#123;</span><br><span class="line">           maxIndex = ri;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果子节点最大值大于父节点，交换，并继续递归调用直到满足堆结构</span></span><br><span class="line">       <span class="keyword">if</span> (arr[maxIndex] &gt; arr[index]) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">           arr[index] = arr[maxIndex];</span><br><span class="line">           arr[maxIndex] = temp;</span><br><span class="line">           maxHeapify(maxIndex, len - <span class="number">1</span>, arr);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>堆排序的时间复杂度为<code>O(nlogn)</code>。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见排序算法&quot;&gt;&lt;a href=&quot;#常见排序算法&quot; class=&quot;headerlink&quot; title=&quot;常见排序算法&quot;&gt;&lt;/a&gt;常见排序算法&lt;/h2&gt;&lt;h3 id=&quot;一-选择排序&quot;&gt;&lt;a href=&quot;#一-选择排序&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="sort" scheme="http://yoursite.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-并发容器集合</title>
    <link href="http://yoursite.com/2020/05/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/05/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88/</id>
    <published>2020-05-26T09:27:13.000Z</published>
    <updated>2020-05-27T06:02:13.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发容器集合"><a href="#并发容器集合" class="headerlink" title="并发容器集合"></a>并发容器集合</h1><p><code>java.util</code>包下提供了一些容器类，其中<code>vector</code>和<code>HashTable</code>是线程安全的容器类。但这些容器类实现同步的方式是通过对方法加锁(<code>synchronized</code>)来实现的。这样的话读写操作均需要锁操作，造成效率低下。</p><p>因此，Java5之后提供了一些并发容器来在多线程下代替同步容器，提高容器的并发访问性，同时定义了线程安全的复合操作。</p><h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><p><img src="https://f1bu920.github.io/images/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%93%E6%9E%84.png" alt=""></p><a id="more"></a><h3 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h3><h4 id="ConcurrentMap接口"><a href="#ConcurrentMap接口" class="headerlink" title="ConcurrentMap接口"></a>ConcurrentMap接口</h4><p><code>ConcurrentMap</code>接口继承了<code>Map</code>接口，并在<code>Map</code>接口上新定义了几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object var1, Object var2)</span></span>;</span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K var1, V var2, V var3)</span></span>;</span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>putIfAbsent</code>：如果插入的<code>key</code>相同，则不替换原有的<code>value</code>值。</p><p><code>remove</code>：这个<code>remove</code>方法增加了对<code>value</code>的判断，如果要删除的key-value不能与<code>Map</code>中的key-value对应上，则不会删除该元素。</p><p><code>replace(K var1, V var2, V var3)</code>：增加了对<code>value</code>的判断，如果key-oldValue能与<code>Map</code>中原有的key-value对应上，才进行替换操作。</p><p><code>replace(K var1, V var2)</code>：不会对<code>Map</code>中原有的key-value进行比较，如果存在key，则直接替换。</p><h4 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h4><p><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html" target="_blank" rel="noopener">参考链接</a></p><p><code>ConcurrentHashMap</code>类提供了一种粒度更细的加锁机制来实现多线程下的更高性能，这种机制叫做分段锁，分段锁在并发环境下会实现更高的吞吐量，而在单线程环境下只会损失非常小的性能。</p><p><code>ConcurrentHashMap</code>会把数据分成一段段的来存储，然后给每一段数据分配一把锁，当一个线程占用锁访问一个段数据时，其他线程能够访问其他数据段。执行有些需要跨段的方法时，如<code>size()</code>、<code>containsValue()</code>等，可能需要锁定整个表而不仅仅是某个段，这需要按照顺序锁定所有段，操作完毕后，按顺序释放所有段的锁。</p><p><img src="https://f1bu920.github.io/images/ConcurrentHashMap.png" alt=""></p><p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。<code>Segment</code>是一种可重入锁<code>ReentrantLock</code>，在<code>ConcurrentHashMap</code>中扮演锁的角色，<code>HashEntry</code>则用于存储键值对数据。一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组，<code>Segment</code>的结构和<code>HashMap</code>类似，是一种数组和链表结构。一个<code>Segment</code>中包含一个<code>HashEntry</code>数组，每个<code>HashEntry</code>是一个链表结构的元素，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组中的元素，当对<code>HashEntry</code>中的元素进行修改时，必须首先获得它的<code>Segment</code>锁。</p><p>具体的<code>ConcurrentHashMap</code>源码分析会另行学习。</p><h4 id="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"><a href="#ConcurrentNavigableMap接口与ConcurrentSkipListMap类" class="headerlink" title="ConcurrentNavigableMap接口与ConcurrentSkipListMap类"></a>ConcurrentNavigableMap接口与ConcurrentSkipListMap类</h4><p><code>ConcurrentNavigableMap</code>接口继承了<code>NavigableMap</code>接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p><p><code>ConcurrentNavigableMap</code>接口的主要实现类是<code>ConcurrentSkipListMap</code>类。这个类使用的底层数据结构是跳表(SkipList)的数据结构。</p><p>跳表是一种以空间换时间的数据结构，可以使用CAS操作保证并发安全性。详情参考下面链接：</p><p><a href="https://cloud.tencent.com/developer/article/1463023" target="_blank" rel="noopener">什么是跳表</a></p><p><a href="https://blog.csdn.net/sunxianghuang/article/details/52221913" target="_blank" rel="noopener">跳表（SkipList）及ConcurrentSkipListMap源码解析</a></p><h3 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h3><p>JDK并没有提供线程安全的List类，因为对于List来说，实现一个通用并且没有并发瓶颈的线程安全List很难。</p><p>但JDK提供了队列和双端队列的线程安全类：<code>ConcurrentLinkedDeque</code>和<code>ConcurrentLinkedQueue</code>。这两个类是通过CAS来实现线程安全的。</p><h3 id="并发Set"><a href="#并发Set" class="headerlink" title="并发Set"></a>并发Set</h3><p>JDK提供了<code>ConcurrentSkipListSet</code>，是线程安全的有序集合。底层使用<code>ConcurrentSkipMap</code>实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发容器集合&quot;&gt;&lt;a href=&quot;#并发容器集合&quot; class=&quot;headerlink&quot; title=&quot;并发容器集合&quot;&gt;&lt;/a&gt;并发容器集合&lt;/h1&gt;&lt;p&gt;&lt;code&gt;java.util&lt;/code&gt;包下提供了一些容器类，其中&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;HashTable&lt;/code&gt;是线程安全的容器类。但这些容器类实现同步的方式是通过对方法加锁(&lt;code&gt;synchronized&lt;/code&gt;)来实现的。这样的话读写操作均需要锁操作，造成效率低下。&lt;/p&gt;
&lt;p&gt;因此，Java5之后提供了一些并发容器来在多线程下代替同步容器，提高容器的并发访问性，同时定义了线程安全的复合操作。&lt;/p&gt;
&lt;h2 id=&quot;并发容器类&quot;&gt;&lt;a href=&quot;#并发容器类&quot; class=&quot;headerlink&quot; title=&quot;并发容器类&quot;&gt;&lt;/a&gt;并发容器类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%93%E6%9E%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-锁接口和类</title>
    <link href="http://yoursite.com/2020/05/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/05/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</id>
    <published>2020-05-25T06:05:51.000Z</published>
    <updated>2020-06-27T01:21:43.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程-锁接口和类"><a href="#Java多线程-锁接口和类" class="headerlink" title="Java多线程-锁接口和类"></a>Java多线程-锁接口和类</h1><p>Java原生的锁是基于对象的锁，一般是配合<code>synchronized</code>使用的。而在<code>java.util.concurrent</code>包下，还提供了几个关于锁的接口和类。</p><h3 id="synchronized的不足"><a href="#synchronized的不足" class="headerlink" title="synchronized的不足"></a>synchronized的不足</h3><ul><li>使用<code>synchronized</code>，临界区的代码同一时间只有一个线程能执行。即便临界区是只读操作。</li><li><code>synchronized</code>无法知道线程有没有成功获得锁。</li><li>使用<code>synchronized</code>如果临界区因为IO或者<code>sleep</code>等阻塞了，当前线程又没有释放锁，就会导致所有的线程都会等待。</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>锁可以根据不同的方式进行分类。</p><h4 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h4><p>可重入锁就是支持重新进入的锁，也就是支持一个线程对资源重复加锁。</p><p><code>synchronized</code>就是使用的可重入锁。可重入性实际上是基于线程的分配，而不是基于方法调用的分配。</p><p><code>Lock</code>也是一个可重入锁。</p><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>这里的公平指的是先来先执行。如果一个锁对先请求获取的线程先满足，对后请求获取的线程后满足，这个锁就是一个公平锁。</p><p>一般，<strong>非公平锁能提升效率，但非公平锁可能会导致一些线程长时间获取不到锁。</strong></p><p><code>ReentrantLock</code>支持公平锁与非公平锁两种。</p><h4 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h4><p><code>synchronized</code>和<code>ReetrantLock</code>都是排它锁，这些锁在同一时间内只允许一个线程进行访问。</p><p>而读写锁同一时刻允许多个线程访问。Java提供了<code>ReetrantReadAndWriterLock</code>类作为读写锁的默认实现，其内部维护了两个锁：一个读锁、一个写锁。通过分离读锁和写锁，使得读多写少的场景下效率大大提高。使用读写锁时，在写线程启动时，读线程和其他的写线程均被阻塞。</p><h3 id="JDK中关于锁的接口和类"><a href="#JDK中关于锁的接口和类" class="headerlink" title="JDK中关于锁的接口和类"></a>JDK中关于锁的接口和类</h3><h4 id="抽象类AQS-AQLS-AOS"><a href="#抽象类AQS-AQLS-AOS" class="headerlink" title="抽象类AQS/AQLS/AOS"></a>抽象类AQS/AQLS/AOS</h4><p><code>AQS</code>，抽象队列同步器，是JDK提供的一个“队列同步器”的基本功能实现。</p><p><code>AQS</code>中的资源使用一个<code>int</code>类型的数据表示的，如果我们的资源数量超出了<code>int</code>的范围，就可以使用<code>AQLS</code>。<code>AQLS</code>与<code>AQS</code>几乎一样，只是把资源的类型变成了<code>long</code>类型。</p><p><code>AQS</code>和<code>AQLS</code>都继承了一个类<code>AOS</code>：<code>AbstractOwnableSynchronizer</code>，用于表示锁与持有者的关系(独占模式)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3737899427754241961L</span>;</span><br><span class="line">    <span class="comment">//独占模式，锁的持有者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnableSynchronizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置锁持有者</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取锁的持有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口Condition-Lock-ReadWriteLock"><a href="#接口Condition-Lock-ReadWriteLock" class="headerlink" title="接口Condition/Lock/ReadWriteLock"></a>接口Condition/Lock/ReadWriteLock</h4><p><code>java.util.concurrent</code>包下有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReaderWriteLock</code>。其中，<code>Lock</code>和<code>ReadWriteLock</code>分别是锁和读写锁。</p><p><code>ReadWriteLock</code>只有两个方法，分别返回读锁和写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code>接口的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得锁，如果锁被其他线程获取，则等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//通过这个方法获取锁时，如果这个线程正在等待获取锁，则这个线程能够中断等待状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//尝试获得锁，成功返回true，失败返回false。立即返回，拿不到锁时不会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//与tryLock大体相同，但拿不到锁时会等待指定时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁，与synchronized不同，Lock必须手动释放锁，否则会可能陷入死锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//实现类似于Object的wait/notify等待/通知机制</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code>接口中有一个方法可以获得<code>Condition</code>。每个对象都可以利用继承自<code>Object</code>的<code>wait/notify</code>方法来实现等待/通知机制。<code>Condition</code>也提供了类似的方法，通过与<code>Lock</code>的配合来实现等待/通知机制。</p><table><thead><tr><th>对比项</th><th>Object监视器</th><th>Condition</th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象的锁</td><td>调用<code>Lock.lock</code>获取锁，调用<code>Lock.newCondition()</code>获取<code>Condition</code>对象</td></tr><tr><td>调用方式</td><td>直接调用，如<code>object.notify()</code></td><td>直接调用，如<code>condition.await()</code></td></tr><tr><td>等待队列的个数</td><td>一个</td><td>多个</td></tr><tr><td>当前线程释放锁进入等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁进入等待状态，在等待状态中断</td><td>不支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入超市等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁进入等待状态直到将来的某个时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的一个线程</td><td>支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的全部线程</td><td>支持</td><td>支持</td></tr></tbody></table><p><code>Condition</code>与<code>Object</code>的<code>wait/notify</code>基本相似。<code>Condition.await()</code>对应<code>Object.wait()</code>，<code>Condition.signal/signalAll</code>对应<code>Object.notify/notifyAll</code>。</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code>是JDK提供的<code>Lock</code>接口的默认实现，实现了锁的基本功能。其是一个可重入锁，内部有一个抽象类<code>abstract static class Sync extends AbstractQueuedSynchronizer</code>继承了<code>AQS</code>，是自己实现的一个同步器，有两个非抽象类<code>static final class FairSync extends ReentrantLock.Sync</code>和<code>static final class NonfairSync extends ReentrantLock.Sync</code>，分别是公平同步器和非公平同步器，代表着<code>ReentrantLock</code>支持公平锁与非公平锁。</p><p>这两个同步器都调用了<code>AOS</code>的<code>setExclusiveOwnerThread(current);</code>方法，所以<code>ReentrantLock</code>的锁是独占的，也就是说是排他锁，不能共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sync = (ReentrantLock.Sync)(fair ? <span class="keyword">new</span> ReentrantLock.FairSync() : <span class="keyword">new</span> ReentrantLock.NonfairSync());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ReentrantLock</code>的构造方法中，可以传入一个布尔类型的参数<code>fair</code>来指定其是否是公平锁，默认是非公平锁。</p><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p><code>ReentrantReadWriteLock</code>类是<code>ReadWriteLock</code>接口的默认实现。与<code>ReentrantLock</code>类似，都是可重入的，支持公平锁与非公平锁。不同的是其还支持读写锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock.Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法，默认是非公平锁</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (ReentrantReadWriteLock.Sync)(fair ? <span class="keyword">new</span> ReentrantReadWriteLock.FairSync() : <span class="keyword">new</span> ReentrantReadWriteLock.NonfairSync());</span><br><span class="line">        <span class="keyword">this</span>.readerLock = <span class="keyword">new</span> ReentrantReadWriteLock.ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.writerLock = <span class="keyword">new</span> ReentrantReadWriteLock.WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取读锁与写锁的方法</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.writerLock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readerLock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">ReentrantReadWriteLock</span>.<span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">ReentrantReadWriteLock</span>.<span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="comment">//省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读锁与写锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>ReentrantReadWriteLock</code>内部维护了两个同步器和两个<code>Lock</code>的实现类<code>ReadLock</code>和<code>WriteLock</code>。</p><p>实现了读写锁，但在写操作时，其他线程不能读也不能写，存在“写饥饿”。</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p><code>public class StampedLock implements Serializable</code>可以看到，<code>StampedLock</code>并没有实现<code>Lock</code>接口和<code>ReadWriteLock</code>接口，但其实现了“读写锁”的功能，并且性能更好。<code>StampedLock</code>把读锁和写锁分为乐观读锁和悲观读锁两种。</p><p><code>StampedLock</code>避免了写饥饿现象，它的核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方法来获取新的值，而不应该阻塞写操作。这种模式也是典型的无锁编程思想，与CAS自旋的思想一样。</strong><code>StampedLock</code>适合在读多写少的场景下使用，同时避免了写饥饿的产生。官方使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="comment">//写锁的使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">//获取写锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">x += deltaX;</span><br><span class="line">y += deltaY;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">stampedLock.unlockWrite(stamp); <span class="comment">//释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乐观读锁的使用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line"><span class="keyword">double</span> currentX = x;</span><br><span class="line"><span class="keyword">double</span> currentY = y;</span><br><span class="line"><span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">//检查乐观读锁后是否有其他写锁发生，有则返回false</span></span><br><span class="line">stamp = stampedLock.readLock(); <span class="comment">//获取一个悲观读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">currentX = x;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">stampedLock.unlockRead(stamp); <span class="comment">//释放悲观读锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> Math.sqrt(currentX*currentX + currentY*currentY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//悲观读锁以及读锁升级写锁的使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX,<span class="keyword">double</span> newY)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> stamp = stampedLock.readLock(); <span class="comment">//悲观读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> ws = stampedLock.tryConvertToWriteLock(stamp); <span class="comment">//读锁转换为写锁</span></span><br><span class="line"><span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//转换成功</span></span><br><span class="line">stamp = ws; <span class="comment">//票据更新为写锁的</span></span><br><span class="line">x = newX;</span><br><span class="line">y = newY;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stampedLock.unlockRead(stamp); <span class="comment">//转换失败释放读锁</span></span><br><span class="line">stamp = stampedLock.writeLock(); <span class="comment">//强制获取写锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">stampedLock.unlock(stamp); <span class="comment">//释放所有锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观读锁的意思是假定在这个锁获取期间，共享变量不会被改变。在获取乐观读锁后进行了一些操作，然后调用<code>validate</code>方法，这个方法是验证是否有写操作执行过，如果有，则获取一个悲观读锁。</p><p><code>StampedLock</code>获取锁时会返回一个<code>long</code>类型的变量，释放锁时再把这个变量传进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//用于操作state后获取stamp的值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT = <span class="number">128L</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = <span class="number">127L</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = <span class="number">126L</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = <span class="number">255L</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = -<span class="number">128L</span>;</span><br><span class="line"><span class="comment">//初始化state的值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = <span class="number">256L</span>;</span><br><span class="line"><span class="comment">//锁共享变量state</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state = <span class="number">256L</span>;</span><br><span class="line"><span class="comment">//读锁溢出时用来存储多出的读锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code>用<code>long</code>类型变量的前7位(<code>LG_READERS</code>)来表示读锁，每获得一个悲观读锁，就加一(<code>RUNIT</code>)，每释放一个悲观读锁，就减一。而悲观读锁最多只能存储128个（7位限制），所以用一个<code>int</code>类型的变量来存储溢出的悲观读锁。</p><p>写锁用<code>state</code>变量剩下的位来表示，每次获得一个写锁，就加 0000 1000 0000(<code>WBIT</code>)。<strong>每次释放一个写锁，并不是减<code>WBIT</code>，而是再加上<code>WBIT</code>，这样做的目的是让每次写锁都留下痕迹，解决CAS的ABA问题，也为乐观锁见检查变化<code>validate</code>方法提供基础。</strong></p><p>乐观读锁并没有改变<code>state</code>的值，而是在获取锁的时候记录<code>state</code>的状态，在操作完成后检查<code>state</code>的写状态部分是否发生变化，因为每次写锁都会留下痕迹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程-锁接口和类&quot;&gt;&lt;a href=&quot;#Java多线程-锁接口和类&quot; class=&quot;headerlink&quot; title=&quot;Java多线程-锁接口和类&quot;&gt;&lt;/a&gt;Java多线程-锁接口和类&lt;/h1&gt;&lt;p&gt;Java原生的锁是基于对象的锁，一般是配合&lt;code
      
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Lock" scheme="http://yoursite.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程池原理</title>
    <link href="http://yoursite.com/2020/05/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/20/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-20T09:00:03.000Z</published>
    <updated>2020-05-22T05:40:55.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><ol><li>创建/销毁线程会消耗系统资源，线程池可以复用已创建的线程。</li><li>控制并发的数量。线程并发数量过多，会抢占系统资源并造成阻塞。</li><li>可以对线程做一些简单的管理。</li></ol><h2 id="ThreadPoolExecutor的原理"><a href="#ThreadPoolExecutor的原理" class="headerlink" title="ThreadPoolExecutor的原理"></a>ThreadPoolExecutor的原理</h2><p>Java中线程池顶层接口为<code>Executor</code>，<code>ThreadPoolExecutor</code>是其一个具体实现类。</p><a id="more"></a><h4 id="ThreadPoolExecutor的构造方法"><a href="#ThreadPoolExecutor的构造方法" class="headerlink" title="ThreadPoolExecutor的构造方法"></a>ThreadPoolExecutor的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个参数的构造方法    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//六个参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(-<span class="number">536870912</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">this</span>.mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">this</span>.termination = <span class="keyword">this</span>.mainLock.newCondition();</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &gt;= <span class="number">0</span> &amp;&amp; maximumPoolSize &gt; <span class="number">0</span> &amp;&amp; maximumPoolSize &gt;= corePoolSize &amp;&amp; keepAliveTime &gt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue != <span class="keyword">null</span> &amp;&amp; threadFactory != <span class="keyword">null</span> &amp;&amp; handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">                <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">                <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">                <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">                <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">                <span class="keyword">this</span>.handler = handler;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>int corePoolSize</code>：核心线程数量的最大值。</p><p>线程池新建线程时，如果当前线程数量小于<code>corePoolSize</code>，则新建的是核心线程。如果超过<code>corePoolSize</code>，则新建的是非核心线程。默认情况下，核心线程会一直存在于线程池中，即使是处于闲置状态。而非核心线程如果超过指定的时间，就会被销毁。</p></li><li><p><code>int maximumPoolSize</code>：线程总数最大值。</p><p>线程总数=核心线程数+非核心线程数。</p></li><li><p><code>long keepAliveTime</code>：非核心线程闲置超时时长。</p><p>非核心线程闲置超过这个时间就会被销毁。如果设置<code>allowCoreThreadTimeOut=true</code>，就会作用于核心线程。</p></li><li><p><code>TimeUnit unit</code>：keepAliveTime的单位</p><p>一个枚举类型，包括以下属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TimeUnit &#123;</span><br><span class="line">    NANOSECONDS(<span class="number">1L</span>),<span class="comment">//1微毫秒</span></span><br><span class="line">    MICROSECONDS(<span class="number">1000L</span>),<span class="comment">//1微秒</span></span><br><span class="line">    MILLISECONDS(<span class="number">1000000L</span>),<span class="comment">//1毫秒</span></span><br><span class="line">    SECONDS(<span class="number">1000000000L</span>),<span class="comment">//1秒</span></span><br><span class="line">    MINUTES(<span class="number">60000000000L</span>),<span class="comment">//1分钟</span></span><br><span class="line">    HOURS(<span class="number">3600000000000L</span>),<span class="comment">//1小时</span></span><br><span class="line">    DAYS(<span class="number">86400000000000L</span>);<span class="comment">//1天</span></span><br></pre></td></tr></table></figure></li><li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>：任务队列，维护着等待执行的Runnable对象。</p><p>当所有的核心线程都在运行时，新添加的任务就会被添加到这个任务队列中。如果队列满了，就会创建非核心线程执行。有以下常见的任务队列：</p><ol><li><code>SynchronousQueue</code>：同步队列，内部容量为0。接收到任务时，会直接提交给线程处理。如果没有闲置线程，就新建一个线程，所以为了防止出现当前线程数大于<code>maximumPoolSize</code>，一般指定<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>。</li><li><code>LinkedBlockingQueue</code>：链式任务队列，底层数据结构是链表，默认大小为<code>Integer.MAX_VALUE</code>。如果不指定大小，因为任务队列不会满，所以<code>maximumPoolSize</code>会失效，线程数永远不会超过<code>corePoolSize</code>，因此永远不会创建非核心线程。</li><li><code>ArrayBlockingQueue</code>：数组任务队列，底层数据结构为数组，需要指定队列的大小。线程数小于<code>corePoolSize</code>时，新建核心线程；超过<code>corePoolSize</code>但任务队列没满时，将任务入队；任务队列满了，就会创建非核心线程；如果总线程数超过<code>maximumPoolSize</code>，就会执行拒绝处理策略。</li><li><code>DelayQueue</code>：延时队列，内部容量为0，队列内元素必须实现Delayed接口。这个队列接受任务时，入队后只有到达了指定时间才会执行任务。</li></ol></li><li><p><code>ThreadFactory threadFactory</code>：创建线程的工厂，用于批量创建线程，统一在创建线程时设置一些参数，如是否是守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    SecurityManager s = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">this</span>.group = s != <span class="keyword">null</span> ? s.getThreadGroup() :           Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">this</span>.namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>RejectedExecutionHandler handler</code>：就是上面提到的拒绝处理策略。线程数大于<code>maximumPoolSize</code>时会执行，有四种常见的拒绝处理策略。</p><ol><li><code>ThreadPoolExecutor.AbortPolicy</code>：默认拒绝处理策略，丢弃任务并抛出<code>RejectedExecutionException</code>异常。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：丢弃新来任务，不抛出异常。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列头部任务，然后尝试执行程序，如果失败，重复此过程。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理此任务。</li></ol></li></ul><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p>线程池本身有一个调度线程，用于管理布控整个线程池的任务和事务，如创建线程、销毁线程、任务队列管理、线程队列管理等。</p><p><code>ThreadPoolExecutor</code>类中有一个控制线程状态的属性<code>private final AtomicInteger ctl</code>，并且定义了5个线程的状态，分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">536870912</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">536870912</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">1073741824</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">1610612736</span>;</span><br></pre></td></tr></table></figure><ul><li>线程池新建后处于RUNNING状态。</li><li>调用<code>shutdown()</code>方法后处于SHUTDOWN状态，线程池不能接受新的任务，清除一些空闲<code>worker</code>，并等待任务队列中的任务完成。</li><li>调用<code>shutdownNow()</code>方法后处于STOP状态，线程池不能接受新的任务，中断所有线程，丢弃任务队列中的全部任务。<code>poolsize</code>和任务队列的size置为0。</li><li>当所有的任务已终止，<code>ctl</code>记录的任务数量为0，线程就会变为TIDYING状态，接着会执行<code>terminated()</code>方法。</li><li>执行完<code>terminated()</code>方法后，线程池变为TERMINATED状态。</li></ul><h4 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h4><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt=""></p><ol><li>提交一个任务到线程池后，判断核心线程数是否已满，如果未满就新建核心线程；否则进入下一个流程。<strong>注意这里不管核心线程是否有空闲，都会新建一个新的核心线程，为的是让核心线程数快速达到<code>corePoolSize</code></strong>.</li><li>判断任务队列是否已满，未满就将任务添加到任务队列，然后空闲的核心线程就会依次去任务队列中取任务来执行，满了就进入下一个流程。(<strong>线程复用的体现</strong>)</li><li>任务队列满了，就创建非核心线程执行任务，如果线程数大于<code>maximumPoolSize</code>，就执行拒绝处理策略。</li></ol><p>处理任务的核心是<code>execute()</code>方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//获取线程状态</span></span><br><span class="line">           <span class="keyword">int</span> c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">           <span class="comment">//当前线程数小于核心线程最大值，调用addWorker创建核心线程执行任务</span></span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) &lt; <span class="keyword">this</span>.corePoolSize) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//如果不小于corePoolSize，将任务添加进workQueue中</span></span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) &amp;&amp; <span class="keyword">this</span>.workQueue.offer(command)) &#123;</span><br><span class="line">               <span class="keyword">int</span> recheck = <span class="keyword">this</span>.ctl.get</span><br><span class="line">               <span class="comment">//二次检查，防止多线程状态下线程池变为非RUNNING状态</span></span><br><span class="line">               <span class="comment">//如果isRunning返回false，则remove这个任务，并执行拒绝处理策略</span></span><br><span class="line">               <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="keyword">this</span>.remove(command)) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.reject(command);</span><br><span class="line">                   <span class="comment">//线程池处于RUNNING状态，但没有线程则新建线程</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.addWorker((Runnable)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="comment">//如果放入workQueue失败，就创建非核心线程</span></span><br><span class="line">           <span class="comment">//如果创建非核心线程也失败，则执行拒绝处理策略</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">               <span class="keyword">this</span>.reject(command);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里对线程池状态进行了二次检查，入队前进行了一次<code>isRunning()</code>判断，入队后，又进行了一次<code>isRunning()</code>判断。这是因为<strong>在多线程环境下，线程池的状态是时刻发生变化的。判断将<code>command</code>加入<code>workQueue</code>是线程池之前的状态，如果没有二次检查，有可能线程池变为非RUNNING状态，那么<code>command</code>将永远没有机会得到执行。</strong></p><p>写个程序验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.HOURS, queue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> ThreadTest());</span><br><span class="line">            System.out.println(<span class="string">"线程池中活跃的线程数："</span>+ threadPoolExecutor.getActiveCount());</span><br><span class="line">            <span class="keyword">if</span> (queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"任务队列中的线程数："</span>+queue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程池中活跃的线程数：<span class="number">1</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">2</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">3</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">4</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">任务队列中的线程数：<span class="number">1</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">任务队列中的线程数：<span class="number">2</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">任务队列中的线程数：<span class="number">3</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">任务队列中的线程数：<span class="number">4</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">5</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">6</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">7</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">8</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">9</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数：<span class="number">10</span></span><br><span class="line">任务队列中的线程数：<span class="number">5</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: Task ThreadTest@<span class="number">6f</span>539caf rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">79f</span>c0f2f[Running, pool size = <span class="number">10</span>, active threads = <span class="number">10</span>, queued tasks = <span class="number">5</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2055</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">825</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1355</span>)</span><br><span class="line">at ThreadTest.main(ThreadTest.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>新建一个线程池，核心线程数为5，总线程数为10，任务队列容量为5，拒绝执行策略为默认的<code>AbortPolicy</code>，其会在线程数超出15时抛出异常。为了达到效果，调用了<code>sleep()</code>方法。</p><h4 id="线程池的复用"><a href="#线程池的复用" class="headerlink" title="线程池的复用"></a>线程池的复用</h4><p><code>ThreadPoolSize</code>在创建线程时，会将线程封装为工作线程<code>worker</code>，并放入工作线程组中，然后这个<code>worker</code>反复从任务队列中去取任务来执行。新建线程调用<code>addWorker(Runnable firstTask, boolean core)</code>方法，这里<code>core=true</code>代表是核心线程，<code>core=false</code>代表是非核心线程。</p><p><code>addWorker</code>分为两部分，创建<code>worker</code>和启动<code>worker</code>。</p><p>创建<code>worker</code>需要一个全局锁<code>ReentrantLock mainLock</code>。新建核心线程和非核心线程都需要获得全局锁。</p><p>启动<code>worker</code>：<code>t.start();</code></p><p><code>addWorker()</code>方法中创建<code>Worker</code>对象的部分源码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = ThreadPoolExecutor.<span class="keyword">this</span>.getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实现了Runnable接口，所以worker也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。因此调用线程对象的<code>start()</code>方法，会触发Worker类的<code>run()</code>方法。</p><p><code>Worker</code>类的<code>run()</code>方法中，</p><ol><li>通过<code>getTask()</code>方法获取等待执行的任务。</li><li>通过<code>task.run()</code>执行具体的任务。</li><li>只有当所有的任务都执行完毕才会停止运行。</li></ol><p>而<code>getTask()</code>是从线程池中获取的任务。<strong>即所有的任务都放在<code>ThreadPoolExecutor</code>中，线程池启动多个<code>Worker</code>去执行任务，每个<code>worker</code>不停的从<code>ThreadPoolExector</code>的<code>workQueue</code>中取出任务，并执行<code>task.run()</code>方法，直至所有的任务执行完毕。</strong></p><h2 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h2><p><code>Executors</code>类中提供了几个静态方法来创建线程池。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>的执行流程如下：</p><ol><li>提交任务进线程池。</li><li>因为<code>corePoolSize</code>等于0，所以永远不会创建核心线程，线程最大值为<code>Integer.MAX_VALUE</code>。</li><li>尝试将任务添加进<code>SynchronousQueue</code>。</li><li>如果入队成功，等待被当前运行的线程空闲后拉取执行；如果当前没有空闲线程，则创建一个非核心线程从<code>SynchronousQueue</code>中拉取任务执行。</li><li>如果<code>SynchronousQueue</code>中已有任务在等待，则入队操作会阻塞。</li></ol><p><code>CachedThreadPool</code>适用于需要执行很多短时间任务的场景，因为其线程复用率比较高，可以显著提高性能。而且线程60s后回收，也不会占用太多资源。</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>corePoolSize==maximumPoolSize</code>，所以只能创建核心线程，永远不会创建非核心线程。因为<code>LinkedBlockingQueue</code>默认大小为<code>Integer.MAX_VALUE</code>，所以如果核心线程空闲，则交给核心线程处理；如果不空闲则入队等待空闲线程。</p><ul><li>与<code>CachedThreadPool</code>的对比<ul><li><code>FixedThreadPool</code>只会创建核心线程，<code>CacheThreadPool</code>只会创建非核心线程。</li><li>在<code>getTask()</code>方法中，如果队列中没有任务，则会一直阻塞在<code>LinkedBlockingQueue.take()</code>，线程不会被回收，而<code>CachedThreadPool</code>中因为全是非核心线程，所以如果没有任务，线程会在60s后被回收。</li><li>因为不会被回收，所以没有任务时，<code>FixedThreadPool</code>占用资源更多。</li><li>几乎都不会触发拒绝处理策略，但原理不同。<code>FixedThreadPool</code>是因为任务队列很大，而<code>CachedThreadPool</code>则是因为线程池容量很大。</li></ul></li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Executors.FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有且仅有一个核心线程，使用了<code>LinkedBlockingQueue</code>作为任务队列。所以不会创建核心线程，所有任务按照先来先执行的顺序进行。如果唯一的线程不空闲，则新来的任务在任务队列中等待。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, <span class="number">2147483647</span>, <span class="number">10L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ScheduledThreadPoolExecutor.DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个定长线程池，支持定时及周期性任务执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h1&gt;&lt;h2 id=&quot;线程池的优势&quot;&gt;&lt;a href=&quot;#线程池的优势&quot; class=&quot;headerlink&quot; title=&quot;线程池的优势&quot;&gt;&lt;/a&gt;线程池的优势&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建/销毁线程会消耗系统资源，线程池可以复用已创建的线程。&lt;/li&gt;
&lt;li&gt;控制并发的数量。线程并发数量过多，会抢占系统资源并造成阻塞。&lt;/li&gt;
&lt;li&gt;可以对线程做一些简单的管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;ThreadPoolExecutor的原理&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor的原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor的原理&quot;&gt;&lt;/a&gt;ThreadPoolExecutor的原理&lt;/h2&gt;&lt;p&gt;Java中线程池顶层接口为&lt;code&gt;Executor&lt;/code&gt;，&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;是其一个具体实现类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring/SpringBoot常用注解</title>
    <link href="http://yoursite.com/2020/05/04/Spring-SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/04/Spring-SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-04T07:07:41.000Z</published>
    <updated>2020-05-21T03:19:06.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h2><p>这个注解是SpringBoot项目的基石，所有创建的SpringBoot项目都会默认在主类上加上这个注解。</p><p><img src="https://f1bu920.github.io/images/SpringBoot%E6%B3%A8%E8%A7%A3@SpringBootApplication.PNG" alt="SpringBoot注解@SpringBootApplication.PNG"></p><p>我们可以把<code>@SpringBootApplication</code>看成是<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>注解的集合。</p><p><img src="https://f1bu920.github.io/images/SpringBoot%E6%B3%A8%E8%A7%A3@SpringBootApplication%E8%AF%A6%E6%83%85.PNG" alt=""></p><p>这三个注解的作用分别如下：</p><ul><li><code>@EnableAutoConfiguration</code>：启动SpringBoot的自动配置机制。</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code>(<code>@Service</code>、<code>@Controller</code>)注解的Bean，注解会默认扫描该类所在包下的所有类。</li><li><code>@Configuration</code>：允许在Spring上下文中注册额外的Bean或导入其他配置类。</li></ul><a id="more"></a><h2 id="2-Spring-Bean相关"><a href="#2-Spring-Bean相关" class="headerlink" title="2. Spring Bean相关"></a>2. Spring Bean相关</h2><h4 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1 @Autowired"></a>2.1 @Autowired</h4><p>自动导入对象到类中，被注入进的类同样要被Spring容器管理。例如：<code>AdminUserServiceImpl</code>注入到<code>AdminController</code>类中。</p><p><img src="https://f1bu920.github.io/images/Service@Autowired.PNG" alt=""></p><p><img src="https://f1bu920.github.io/images/Controller@Autowired.PNG" alt=""></p><h4 id="2-2-Component、-Repository、-Service、-Controller"><a href="#2-2-Component、-Repository、-Service、-Controller" class="headerlink" title="2.2 @Component、@Repository、@Service、@Controller"></a>2.2 @Component、@Repository、@Service、@Controller</h4><p>我们一般使用<code>@Autowired</code>注解来让Spring容器帮我们自动装配Bean。我们可以使用<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>和<code>@Controller</code>注解将类标记为可用于<code>@Autowired</code>自动装配的类。</p><ul><li><code>@Component</code>：通用的注解，可标记任意类为Spring组件。如果一个类不知道属于那一层，可以使用此注解。</li><li><code>@Reponsitory</code>：对应持久层即DAO层，主要用于数据库相关操作。</li><li><code>@Service</code>：对应服务层。主要负责一些复杂的逻辑，需要用到DAO层。</li><li><code>Controller</code>：对应Spring MVC的控制层。主要用于接受用户请求并调用<code>Service</code>层返回数据给前端。</li></ul><h4 id="2-3-RestController"><a href="#2-3-RestController" class="headerlink" title="2.3 @RestController"></a>2.3 @RestController</h4><p><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>注解的合集，表示这是个控制器Bean，并且将返回值直接填入HTTP的响应体中，是REST风格的控制器。</p><p>单独使用<code>@Controller</code>主要用于返回一个视图，这是传统Spring MVC的应用，属于前后端不分离的场景；使用<code>RestController</code>或者使用<code>@Controller</code>加<code>@ResponseBody</code>返回JSON或XML形式的数据，用于前后端分离的场景。</p><h4 id="2-4-Scope"><a href="#2-4-Scope" class="headerlink" title="2.4 @Scope"></a>2.4 @Scope</h4><p>声明Spring Bean的作用域。如：<code>@Scope(&quot;singleton&quot;)</code>。其有以下作用域：</p><ul><li><code>singleton</code>：唯一Bean实例，Spring中的Bean默认都是单例的。</li><li><code>prototype</code>：每次请求都会创建一个新的Bean实例。</li><li><code>request</code>：每次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP request内有效。</li><li><code>session</code>：每次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP session内有效。</li></ul><h4 id="2-5-Configuration"><a href="#2-5-Configuration" class="headerlink" title="2.5 @Configuration"></a>2.5 @Configuration</h4><p>一般用于声明配置类，可以使用<code>@Component</code>注解代替。</p><p><img src="https://f1bu920.github.io/images/@Configuration%E6%B3%A8%E8%A7%A3.PNG" alt=""></p><h2 id="3-处理常见的HTTP请求类型"><a href="#3-处理常见的HTTP请求类型" class="headerlink" title="3. 处理常见的HTTP请求类型"></a>3. 处理常见的HTTP请求类型</h2><p>常见的有5种请求类型：</p><ul><li><code>GET</code>：请求从服务器获取特定资源。</li><li><code>POST</code>：在服务器上创建一个新的资源。</li><li><code>PUT</code>：更新服务器上的资源。客户端提供更新后的整个资源。</li><li><code>DELETE</code>：删除服务器上的特定资源。</li><li><code>PATCH</code>：更改服务器上上的资源，客户端提供更改的属性，可看成局部更新。</li></ul><h4 id="3-1-GET请求"><a href="#3-1-GET请求" class="headerlink" title="3.1 GET请求"></a>3.1 GET请求</h4><p><code>@GetMapping(&quot;/login&quot;)</code>等价于<code>@RequestMapping(value=&quot;/login&quot;, method=RequestMethod.GET)</code>。</p><p><img src="https://f1bu920.github.io/images/@GetMapping.PNG" alt="@GetMapping.PNG"></p><h4 id="3-2-POST请求"><a href="#3-2-POST请求" class="headerlink" title="3.2 POST请求"></a>3.2 POST请求</h4><p><code>@PostMapping(&quot;/login&quot;)</code>等价于<code>@RequestMapping(value=&quot;/login&quot;, method=RequestMethod.POST)</code>。</p><p><img src="https://f1bu920.github.io/images/@PostMapping.PNG" alt="@PostMapping.PNG"></p><h4 id="3-3-PUT请求"><a href="#3-3-PUT请求" class="headerlink" title="3.3 PUT请求"></a>3.3 PUT请求</h4><p><code>@PostMapping(&quot;/users/{userId}&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;, method=RequestMethod.PUT)</code>。</p><h4 id="3-4-DELETE请求"><a href="#3-4-DELETE请求" class="headerlink" title="3.4 DELETE请求"></a>3.4 DELETE请求</h4><p><code>@DeleteMapping(&quot;/users/{userId}&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/{userId}&quot;, method=RequestMethod.DELETE)</code>。</p><h4 id="3-5-PATCH-请求"><a href="#3-5-PATCH-请求" class="headerlink" title="3.5 PATCH 请求"></a>3.5 PATCH 请求</h4><p><code>@PatchMapping(&quot;/profile&quot;)</code>等价于<code>@RequestMapping(value=&quot;/profile&quot;, method=RequestMethod.PATCH)</code>。</p><h2 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4. 前后端传值"></a>4. 前后端传值</h2><h4 id="4-1-PathVariable和-RequestParam"><a href="#4-1-PathVariable和-RequestParam" class="headerlink" title="4.1 @PathVariable和@RequestParam"></a>4.1 @PathVariable和@RequestParam</h4><p><code>@PathValiable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p><p><img src="https://f1bu920.github.io/images/@PathVariable.PNG" alt=""></p><p>如果我们请求的URL为：<code>/blogs/edit/1</code>，获得的数据就是<code>blogId=1</code>。</p><p><img src="https://f1bu920.github.io/images/@RequestParam.PNG" alt=""></p><p>如果我们请求的URL为：<code>/blogs/save?blogTitle=title</code>，获得的数据就是<code>blogTitle=title</code>。</p><h4 id="4-2-RequestBody"><a href="#4-2-RequestBody" class="headerlink" title="4.2 @RequestBody"></a>4.2 @RequestBody</h4><p>用于读取Request请求的Body部分，并且<code>Content-Type</code>为<code>application/json</code>格式的数据，接收到数据后自动绑定到Java对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的body中的json字符串转换为Java对象。</p><p><img src="https://f1bu920.github.io/images/@RequestBody.PNG" alt=""></p><p><strong>注意：一个请求方法只可以有一个<code>@RequestBody</code>，但可以有多个<code>RequestParam</code>和<code>PathVariable</code>。</strong></p><h2 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5. 读取配置信息"></a>5. 读取配置信息</h2><p>很多时候需要把一些常用的配置信息放在配置文件中，Spring提供了以下方法来读取去这些配置信息。</p><h4 id="5-1-value"><a href="#5-1-value" class="headerlink" title="5.1 @value"></a>5.1 @value</h4><p>使用<code>@value(&quot;${property}&quot;)</code>读取一些简单的配置信息。</p><h4 id="5-2-ConfigurationProperty"><a href="#5-2-ConfigurationProperty" class="headerlink" title="5.2 @ConfigurationProperty"></a>5.2 @ConfigurationProperty</h4><p>通过<code>@ConfigurationProperty</code>读取配置信息并与Bean绑定。</p><p>可以像使用Bean一样，将其注入到类中。</p><h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p><code>@PropertySource</code>指定读取<code>properties</code>文件。</p><h2 id="6-参数校验"><a href="#6-参数校验" class="headerlink" title="6. 参数校验"></a>6. 参数校验</h2><p>在前端已经进行校验的情况下，为了避免一些http工具向后台请求一些违法的数据，还是要对传入后端的数据在进行一遍数据校验。</p><p>JSR就是一套数据校验标准，其定义了很多常用的校验注解，我们可以直接将这些校验注解加在JavaBean的属性上，这样就可以在需要校验时进行校验了。</p><p>校验时使用的是<code>Hibernate Validator</code>框架，SpringBoot的<code>spring-boot-starter-web</code>依赖中已经包含了<code>hibernate-validator</code>包，不需要额外导入。<strong>所有的注解，推荐使用<code>javax.validation.constraints</code>。</strong></p><h4 id="6-1-一些常用的字段验证的注解"><a href="#6-1-一些常用的字段验证的注解" class="headerlink" title="6.1 一些常用的字段验证的注解"></a>6.1 一些常用的字段验证的注解</h4><ul><li><code>@NotEmpty</code>：被注释的字符串不能为<code>null</code>也不能为空。</li><li><code>@NotBlank</code>：被注释的字符串不能为<code>null</code>，且必须包含一个非空字符。</li><li><code>@Null</code>：被注释的元素必须为<code>null</code>。</li><li><code>@NotNull</code>：被注释的元素必须不为<code>null</code>。</li><li><code>@AssertTrue</code>：被注释的元素必须为<code>true</code></li><li><code>@AssertFalse</code>：被注释的元素必须为<code>false</code></li><li><code>@Pattern(regex= ,flag= )</code>：被注释的元素必须符合指定的正则表达式。</li><li><code>@Email</code>：被注释的元素必须符合Email格式。</li><li><code>@Min(value)</code>：被注释的元素必须是一个数字，且必须大于等于指定的<code>value</code></li><li><code>@Max(value)</code>：被注释的元素必须是一个数字，且必须小于等于指定的<code>value</code></li><li><code>@DecimalMin(value)</code>：被注释的元素必须是一个数字，且必须大于等于指定的<code>value</code></li><li><code>@DecimalMax(value)</code>：被注释的元素必须是一个数字，且必须小于等于指定的<code>value</code></li><li><code>@Size(max= ,min= )</code>：被注释的元素的大小必须在指定的范围之内</li><li><code>@Digits(integer, fraction)</code>：被注释的元素必须是一个数字，且必须在可接受的范围之内</li><li><code>@Past</code>：被注释的元素必须是一个过去的日期</li><li><code>@Future</code>：被注释的元素必须是一个未来的日期</li><li>……</li></ul><h4 id="6-2-验证请求体-RequestBody"><a href="#6-2-验证请求体-RequestBody" class="headerlink" title="6.2 验证请求体(RequestBody)"></a>6.2 验证请求体(RequestBody)</h4><p>给需要验证的参数加上<code>@Valid</code>注解，如果验证失败，将抛出<code>MethodArgumentNotValidException</code>。</p><h4 id="6-3-验证请求参数-PathVariable和RequestParam"><a href="#6-3-验证请求参数-PathVariable和RequestParam" class="headerlink" title="6.3 验证请求参数(PathVariable和RequestParam)"></a>6.3 验证请求参数(PathVariable和RequestParam)</h4><p><strong>验证请求参数时，一定要在类上加上<code>@Validated</code>注解，这个注解会告诉Spring去校验方法参数。</strong></p><p><img src="https://f1bu920.github.io/images/@Validated.PNG" alt=""></p><p><img src="https://f1bu920.github.io/images/@Valid.PNG" alt=""></p><h2 id="7-全局处理Controller异常"><a href="#7-全局处理Controller异常" class="headerlink" title="7.全局处理Controller异常"></a>7.全局处理Controller异常</h2><ol><li><code>@ControllerAdvice</code>：注解定义全局异常处理类。</li><li><code>@ExceptionHandler</code>：注解申明异常处理方法。</li></ol><p>例如，对于参数校验时抛出的<code>MethodArgumentNotValidException</code>异常，可以在类上加上<code>@ControllerAdvice</code>注解，在处理方法上加上<code>@ExceptionHandler()</code>并指定处理的异常类。</p><p><img src="https://f1bu920.github.io/images/@ControllerAdvice.PNG" alt=""></p><h2 id="8-JPA相关"><a href="#8-JPA相关" class="headerlink" title="8. JPA相关"></a>8. JPA相关</h2><h4 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1 创建表"></a>8.1 创建表</h4><ol><li><code>@Entity</code>：声明一个类对应一个数据库实体。</li><li><code>Table</code>：设置表名。</li></ol><p><img src="https://f1bu920.github.io/images/JPA%E7%9B%B8%E5%85%B3@Entity.PNG" alt=""></p><h4 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2 创建主键"></a>8.2 创建主键</h4><p>如上图所示，使用<code>@Id</code>将一个字段声明为主键。此外，还需要声明主键的生成策略，在MySQL中一般使用<code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>，主键自动递增。这里<code>GenerationType</code>是枚举类型，其有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> GenerationType &#123;</span><br><span class="line">    <span class="comment">//使用一个特定的数据库表来存储主键，持久化引擎通过关系数据库的一张特定的表格来生成主键</span></span><br><span class="line">    <span class="comment">//好处是不依赖于外部环境和数据库的具体实现，在不同数据库间可以很容易的移植。</span></span><br><span class="line">    TABLE,</span><br><span class="line">    <span class="comment">//在某些数据库中不支持主键自增长，比如Oracle,其提供了一种叫做"序列(sequence)"的机制生成主键。</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line">    <span class="comment">//主键自增长</span></span><br><span class="line">    IDENTITY,</span><br><span class="line">    <span class="comment">//把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成策略中选择其中一种。</span></span><br><span class="line">    <span class="comment">//这也是JPA默认的生成策略</span></span><br><span class="line">    AUTO;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GenerationType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3 设置字段类型"></a>8.3 设置字段类型</h4><p><code>@Column</code>声明字段。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"username"</span>,nullable = <span class="keyword">false</span>,length = <span class="number">225</span>)</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@Column</span>(name = <span class="string">"password"</span>,columnDefinition = <span class="string">"varchar(225) default 123456"</span>)</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><h4 id="8-4-指定不可持久化字段"><a href="#8-4-指定不可持久化字段" class="headerlink" title="8.4 指定不可持久化字段"></a>8.4 指定不可持久化字段</h4><p>利用<code>@Transient</code>声明不需要与数据库映射的字段，在保存时不保存进数据库。</p><p>也可以将属性声明为<code>static</code>、<code>final</code>或直接声明为<code>transient</code>类型。</p><h4 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5 声明大字段"></a>8.5 声明大字段</h4><p><code>@Lob</code>：声明字段为大字段。</p><h4 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6 创建枚举类型的字段"></a>8.6 创建枚举类型的字段</h4><p>使用<code>@Enumerated</code>注解创建枚举类型字段。</p><h4 id="8-7-删除、修改数据"><a href="#8-7-删除、修改数据" class="headerlink" title="8.7 删除、修改数据"></a>8.7 删除、修改数据</h4><p><code>@Modifying</code>注解表示该操作是修改操作，注意一般会与<code>@Transactional</code>配合使用。</p><h4 id="8-8-关联关系"><a href="#8-8-关联关系" class="headerlink" title="8.8 关联关系"></a>8.8 关联关系</h4><ul><li><code>@OneToOne</code>：声明一对一关系</li><li><code>OneToMany</code>：声明一对多关系</li><li><code>ManyToOne</code>：声明多对一关系</li><li><code>ManyToMany</code>：声明多对多关系。</li></ul><h2 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9. 事务@Transactional"></a>9. 事务@Transactional</h2><p>使用<code>@Transactional</code>注解在要开启事务的方法上开启事务。</p><p>注意，在<code>Transactional</code>注解中如果不配置<code>rollbackFor</code>属性，那么只会在遇到<code>RuntimeException</code>时才会回滚。加上<code>rollbackFor=Exception.class</code>后在遇到非运行时异常时也会回滚。</p><p><code>Transactional</code>作用于类上时，表示该类的所有方法都配置了这个事务属性；当类上配置了<code>Transactional</code>，方法上再次配置则会覆盖类上的配置信息。</p><h2 id="10-json数据处理"><a href="#10-json数据处理" class="headerlink" title="10. json数据处理"></a>10. json数据处理</h2><h4 id="10-1-过滤json数据"><a href="#10-1-过滤json数据" class="headerlink" title="10.1 过滤json数据"></a>10.1 过滤json数据</h4><p>使用<code>@JsonIgnoreProperties</code>注解作用于类上来过滤指定的字段不返回或者不解析。</p><p>也可以使用<code>@JsonIgnore</code>作用于类的属性上，作用相同。</p><h4 id="10-2-格式化json数据"><a href="#10-2-格式化json数据" class="headerlink" title="10.2 格式化json数据"></a>10.2 格式化json数据</h4><p>使用<code>@JsonFormat</code>来格式化json数据。</p><h2 id="11-单元测试"><a href="#11-单元测试" class="headerlink" title="11. 单元测试"></a>11. 单元测试</h2><p><code>@ActiveProfiles</code>一般用于测试类上，指定生效的配置文件。</p><p><code>Test</code>声明一个方法为测试方法。</p><p><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据。</p><p><code>WithMockUser</code>，Spring Security提供的用于模拟一个真实用户，并且可以赋予权限。</p><p>平时写SpringBoot单元测试时，需要在类上加上<code>@RunWith(SpringRunner.class)</code>和<code>@SpringBootTest</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AdminUserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AdminUserMapper adminUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-SpringBootApplication&quot;&gt;&lt;a href=&quot;#1-SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;1. @SpringBootApplication&quot;&gt;&lt;/a&gt;1. @SpringBootApplication&lt;/h2&gt;&lt;p&gt;这个注解是SpringBoot项目的基石，所有创建的SpringBoot项目都会默认在主类上加上这个注解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/SpringBoot%E6%B3%A8%E8%A7%A3@SpringBootApplication.PNG&quot; alt=&quot;SpringBoot注解@SpringBootApplication.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以把&lt;code&gt;@SpringBootApplication&lt;/code&gt;看成是&lt;code&gt;@Configuration&lt;/code&gt;、&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;和&lt;code&gt;@ComponentScan&lt;/code&gt;注解的集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/SpringBoot%E6%B3%A8%E8%A7%A3@SpringBootApplication%E8%AF%A6%E6%83%85.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这三个注解的作用分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;：启动SpringBoot的自动配置机制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：扫描被&lt;code&gt;@Component&lt;/code&gt;(&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Controller&lt;/code&gt;)注解的Bean，注解会默认扫描该类所在包下的所有类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;：允许在Spring上下文中注册额外的Bean或导入其他配置类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-synchronized与锁</title>
    <link href="http://yoursite.com/2020/04/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E4%B8%8E%E9%94%81/"/>
    <id>http://yoursite.com/2020/04/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E4%B8%8E%E9%94%81/</id>
    <published>2020-04-22T07:47:46.000Z</published>
    <updated>2020-04-28T07:48:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p><code>synchronized</code>翻译成中文就是同步的意思。我们通常使用<code>synchronized</code>关键字来给一段代码或一个方法上锁。其主要有以下三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//关键字在实例方法上，锁为当前实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instanceLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//code</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关键字在静态方法上，锁为当前Class对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">classLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//code</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关键字在代码块上，锁为括号里面对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Object o = <span class="keyword">new</span> Object();</span><br><span class="line">       <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">           <span class="comment">//code</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>java中的锁都是对象锁，我们常说的类锁也是对象锁。Java类只要一个Class对象，多个实例对象共享这一个Class对象。类锁就是Class对象的锁。</strong></p></blockquote><a id="more"></a><p>Java中临界区指的是某一代码区域同一时刻只能由一个线程执行。<code>synchronized</code>关键字如果加在方法上，那么整个方法都是临界区；如果加载代码块上，临界区就是代码块内部区域。</p><h2 id="偏向锁、轻量级锁与重量级锁"><a href="#偏向锁、轻量级锁与重量级锁" class="headerlink" title="偏向锁、轻量级锁与重量级锁"></a>偏向锁、轻量级锁与重量级锁</h2><p>Java6为了减少获得和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。Java6以前，所有的锁都是重量级锁。</p><p>一个对象有4种锁状态，从低到高分别为：</p><ol><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ol><p>无锁就是没有对资源进行锁定，任何线程都可以去执行。</p><p>几种锁会随着竞争情况逐级升级，锁的升级很容易发生，但降级条件很苛刻。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>每个Java对象都有对象头，如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽存储对象头。32位机器中，一个字宽是32位；64位虚拟机中，一个字宽是64位。对象头的内容如下表：</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64bit</td><td align="center">Mark Word</td><td align="center">存储对象的hashCode或锁信息等</td></tr><tr><td align="center">32/64bit</td><td align="center">Class Metadata Address</td><td align="center">存储到对象类型数据的指针</td></tr><tr><td align="center">32/64bit</td><td align="center">Array length</td><td align="center">数组的长度(如果是数组)</td></tr></tbody></table><p>其中，<code>Mark Word</code>的格式如下：</p><table><thead><tr><th align="center">锁状态</th><th align="center">29或61bit</th><th align="center">1bit是否是偏向锁</th><th align="center">2bit锁标志位</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center"></td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程ID</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">指向互斥量(重量级锁)的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">10</td></tr><tr><td align="center">GC标志</td><td align="center"></td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">11</td></tr></tbody></table><p>当对象状态为偏向锁时，<code>Mark Word</code>中记录的是线程ID；当状态是轻量级锁时，<code>Mark Word</code>中存储的是指向线程栈中<code>Lock Record</code>的指针；当状态是重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，还总是由同一线程多次获得，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个获得锁的线程，如果在接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程永远不会触发同步。也就是，<strong>偏向锁在资源无竞争条件下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><blockquote><p>CAS: Compare And Swap</p><p>比较并设置。</p></blockquote><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>一个线程在第一次进入同步块时，会在对象头和栈帧的锁记录中存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的<code>Mark Word</code>中是否存在自己的线程ID。</p><p>如果是，代表当前线程已获得锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁。</p><p>如果不是，代表有另一个线程来竞争这个偏向锁。这时会尝试用CAS操作来替换<code>Mark Word</code>中的线程ID为新线程的ID，有两种结果：</p><ul><li>如果成功，代表之前的线程不存在了，<code>Mark Word</code>中为新线程的ID，锁不会升级，仍然为偏向锁。</li><li>如果失败，表示之前的线程依然存在。暂停之前的线程，设置锁标识为0，并设置锁标识位为00，升级为轻量级锁，按照轻量级锁的方式竞争锁。</li></ul><p>线程竞争偏向锁的过程如下：</p><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B.JPG" alt="线程竞争偏向锁的过程.JPG"></p><p>图中涉及到了<code>lock record</code>指针指向当前堆栈中最近的一个<code>lock record</code>，是轻量级锁按照先来先服务的模式进行轻量级锁的加锁。</p><h5 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h5><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，只有当其他线程竞争偏向锁时，持有锁的线程才会释放锁。</p><p>偏向锁升级为轻量级锁时，会暂停拥有偏向锁的线程，这个过程的开销是很大的。</p><p>偏向锁的获得和撤销流程如下：</p><p><img src="https://f1bu920.github.io/images/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%8E%B7%E5%BE%97%E5%92%8C%E6%92%A4%E9%94%80%E6%B5%81%E7%A8%8B.png" alt="偏向锁的获得和撤销流程.png"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>多个线程在不同时间段获得同一把锁，不存在锁竞争的情况，也就没有线程阻塞。这种情况下，可以采用轻量级锁来避免线程的阻塞和唤醒。</p><h5 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h5><p>JVM会为每个线程在当前线程的栈帧中创建存储锁记录的空间，称为<code>Displaced Mark Word</code>。如果一个线程获得锁时发现是轻量级锁，会把锁的<code>Mark Word</code>复制到自己的<code>Displaced Mark Word</code>中。</p><p>然后线程尝试把锁的<code>Mark Word</code>更改为指向自己的锁记录的指针。如果成功，当前线程获得锁；如果失败，表示<code>Mark Word</code>已经被替换为其他线程的锁记录，有其他线程正在竞争锁，当前线程则尝试使用适应性自旋来获得锁。</p><p>线程的自旋是会消耗CPU资源的，如果一直处于自选状态就会白白浪费CPU资源，所以JDK采用了适应性自旋的方式，就是如果线程自旋成功了，下次自旋的次数就会更多，如果失败了，自旋的次数就会减少。</p><p>当自旋一定次数后，依然没有获得锁，称为自旋失败，这个线程会阻塞。锁也会升级为重量级锁。</p><h5 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h5><p>释放锁时，当前线程使用CAS操作将<code>Displaced Mark Word</code>中的内容复制回锁的<code>Mark Word</code>中。如果操作成功，即锁的<code>Mark Word</code>没有被其他线程更改，即没有发生竞争。如果有其他线程多次自旋失败导致锁升级为重量级锁，那么CAS操作会失败，此时会释放锁并唤醒阻塞的线程。</p><p>轻量级锁及膨胀流程图如下：</p><p><img src="https://f1bu920.github.io/images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8F%8A%E8%86%A8%E8%83%80%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="轻量级锁及膨胀流程图.png"></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是依赖操作系统的互斥量(mutex)来实现的，而操作系统中线程间状态的转换需要较多的时间，因此重量级锁的效率很低，但被阻塞的线程不会消耗CPU。</p><p>每个对象都可以当做一个锁，当多个线程请求一个对象锁时，对象锁会设置几个状态来区分请求的线程。</p><ul><li><code>Contention List</code>：所有请求锁的线程都会被首先放置到该竞争队列</li><li><code>Entry List</code>：<code>Contention List</code>中那些有资格成为候选人的线程被移到<code>Entry List</code></li><li><code>Wait Set</code>：调用<code>wait</code>方法被阻塞的线程进入<code>Wait Set</code></li><li><code>OnDeck</code>：任何时刻最多只有一个线程在竞争锁，这个线程被称为<code>OnDeck</code></li><li><code>Owner</code>：获得锁的线程被称为<code>Owner</code></li><li><code>!Owner</code>：释放锁的线程</li></ul><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到<code>Contention List</code>的队首，然后调用<code>park</code>函数挂起当前线程。</p><p>当线程释放锁时，会从<code>Contention List</code>或<code>Entry Set</code>中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>，即假定继承人，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定会获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是减少执行操作系统同步操作带来的开销。如果线程自旋不成功在进入等待队列。对于已经在等待队列中的线程来说是不公平的。</p><p>如果线程获得锁后调用<code>Object.wait()</code>方法，则会将线程加入<code>Wait Set</code>中，当被<code>notify</code>唤醒后，会将线程移到<code>Contention List</code>或<code>Entry Set</code>中去。<strong>当调用一个锁对象的<code>wait</code>和<code>notify</code>方法时，如果当前锁的状态是偏向锁或轻量级锁，则会先膨胀为重量级锁。</strong></p><h4 id="锁的升级流程总结"><a href="#锁的升级流程总结" class="headerlink" title="锁的升级流程总结"></a><strong>锁的升级流程总结</strong></h4><ol><li>每一个线程在准备获取共享资源时，第一步先检查<code>Mark Word</code>中存放的是不是自己的<code>ThreadId</code>，如果是，当前线程处于偏向锁。</li><li>如果<code>Mark Word</code>不是自己的<code>ThreadId</code>，锁升级为轻量级锁。这时，采用CAS来执行切换，新的线程利用<code>Mark Word</code>中现有的<code>ThreadId</code>通知之前的线程暂停，之前的线程将<code>Mark Word</code>置为空。</li><li>两个线程都把锁对象的<code>HashCode</code>复制到自己新建的用于存储锁记录的空间，接着通过CAS操作把锁对象的<code>Mark Word</code>修改为指向自己新建的存储锁记录的空间的地址，通过这种方式来竞争锁。</li><li>成功执行CAS的获得锁，失败的进入自旋</li><li>自旋的线程在自旋中成功获得锁(之前获取锁的线程执行完毕并释放了锁)，依然处于轻量级锁的状态，如果多次自旋失败，升级为重量级锁。</li><li>升级为重量级锁后，自旋的线程进入阻塞，等待之前线程执行完毕并唤醒自己。</li></ol><h4 id="各种锁的对比"><a href="#各种锁的对比" class="headerlink" title="各种锁的对比"></a>各种锁的对比</h4><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法的性能差距很小</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步块的情况</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度</td><td align="center">如果始终得不到锁，竞争的线程会消耗CPU资源</td><td align="center">追求响应时间。同步块执行速度非常快</td></tr><tr><td align="center">重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗CPU</td><td align="center">线程阻塞，响应时间慢</td><td align="center">追求吞吐量。同步块执行时间较长</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;synchronized关键字&quot;&gt;&lt;a href=&quot;#synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字&quot;&gt;&lt;/a&gt;synchronized关键字&lt;/h2&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;翻译成中文就是同步的意思。我们通常使用&lt;code&gt;synchronized&lt;/code&gt;关键字来给一段代码或一个方法上锁。其主要有以下三种方式&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//关键字在实例方法上，锁为当前实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;instanceLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//关键字在静态方法上，锁为当前Class对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//关键字在代码块上，锁为括号里面对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;blockLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Object o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (o)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;//code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;java中的锁都是对象锁，我们常说的类锁也是对象锁。Java类只要一个Class对象，多个实例对象共享这一个Class对象。类锁就是Class对象的锁。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-volatile</title>
    <link href="http://yoursite.com/2020/04/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile/"/>
    <id>http://yoursite.com/2020/04/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile/</id>
    <published>2020-04-22T07:16:25.000Z</published>
    <updated>2020-06-27T01:21:58.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>JMM有一个主内存，每个线程都有自己私有的工作线程，工作内存中保留了一些变量在主内存的拷贝。</p><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量后，另一个线程可以读取到这个更改后的值。</strong></p><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>为了优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序。</p><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>是一个给程序员使用的规则，只要遵守<code>happens-before</code>原则，JVM就能保证指令在多线程之间的顺序性符合预期。</p><a id="more"></a><h2 id="volatile的内存语意"><a href="#volatile的内存语意" class="headerlink" title="volatile的内存语意"></a>volatile的内存语意</h2><p>在Java中，<code>volatile</code>主要有两个功能：</p><ul><li><strong>保证内存可见性</strong></li><li><strong>禁止指令重排序</strong></li></ul><h4 id="内存可见性-1"><a href="#内存可见性-1" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>当一个线程对<code>volatile</code>修饰的变量进行写操作后，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存。当一个线程对<code>volatile</code>修饰的变量进行读操作时，JMM会立即把该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</p><p>所以，<strong><code>volatile</code>与锁具有相同的内存效果。<code>volatile</code>的写与锁的释放、<code>volatile</code>的读与锁的获取有相同的内存语意。</strong></p><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p><strong>JMM是通过内存屏障实现的禁止重排序。</strong></p><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><p><code>volatile</code>可以保证内存可见性和禁止重排序。</p><p>在保证内存可见性上，<code>volatile</code>与锁具有相同的语意，所以可以当做轻量级的锁来使用。但是<code>volatile</code>仅仅能保证单个变量的读、写具有原子性，而锁可以保证整个临界区代码具有原子性。所以<strong>锁更强大，<code>volatile</code>性能更有优势。</strong></p><p>在禁止重排序上，<code>volatile</code>也十分有用，例如单例模式有一种实现方式就是“双重锁检查”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述变量声明中不使用<code>volatile</code>关键字，可能会发生错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h4 id=&quot;内存可见性&quot;&gt;&lt;a href=&quot;#内存可见性&quot; class=&quot;headerlink&quot; title=&quot;内存可见性&quot;&gt;&lt;/a&gt;内存可见性&lt;/h4&gt;&lt;p&gt;JMM有一个主内存，每个线程都有自己私有的工作线程，工作内存中保留了一些变量在主内存的拷贝。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量后，另一个线程可以读取到这个更改后的值。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;重排序&quot;&gt;&lt;a href=&quot;#重排序&quot; class=&quot;headerlink&quot; title=&quot;重排序&quot;&gt;&lt;/a&gt;重排序&lt;/h4&gt;&lt;p&gt;为了优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序。&lt;/p&gt;
&lt;h4 id=&quot;happens-before原则&quot;&gt;&lt;a href=&quot;#happens-before原则&quot; class=&quot;headerlink&quot; title=&quot;happens-before原则&quot;&gt;&lt;/a&gt;happens-before原则&lt;/h4&gt;&lt;p&gt;是一个给程序员使用的规则，只要遵守&lt;code&gt;happens-before&lt;/code&gt;原则，JVM就能保证指令在多线程之间的顺序性符合预期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-内存模型</title>
    <link href="http://yoursite.com/2020/04/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/04/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-04-14T05:20:02.000Z</published>
    <updated>2020-04-18T02:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享内存并发模型"><a href="#共享内存并发模型" class="headerlink" title="共享内存并发模型"></a>共享内存并发模型</h2><p>并发编程模型有两个关键问题，即<strong>线程间如何通信，即线程间以何种机制来交换信息；线程间如何同步，即线程以何种机制来控制不同线程间操作发生的相对顺序。</strong></p><p>有两个并发模型</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><table><thead><tr><th align="center"></th><th align="center">如何通信</th><th align="center">如何同步</th></tr></thead><tbody><tr><td align="center">消息传递并发模型</td><td align="center">线程间没有公共状态，必须通过发送消息显示地进行通信</td><td align="center">发送消息总在接受消息之前，同步是隐式的</td></tr><tr><td align="center">共享内存并发模型</td><td align="center">线程间共享程序的公共状态，通过<strong>读-写内存中的公共状态</strong>进行隐式通信</td><td align="center">必须显示指定某段代码需要在线程之间互斥执行，同步是显示的。</td></tr></tbody></table><p><strong>Java中使用的是共享内存并发模型。</strong></p><a id="more"></a><h2 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h2><h4 id="运行时内存的划分"><a href="#运行时内存的划分" class="headerlink" title="运行时内存的划分"></a>运行时内存的划分</h4><p>运行时数据区：</p><p><img src="https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="Java运行时数据区"></p><p>其中，<strong>堆和方法区是所有线程共享的数据区，虚拟机栈、本地方法栈和程序计数器是线程私有的数据区。</strong></p><p>对于每一个线程，栈都是私有的，堆都是共有的。</p><p>在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程间共享，也就不会有内存可见性问题，不受内存模型的影响。而在堆中的变量是共享的，称为共享变量。</p><p><strong>内存可见性针对的是共享变量。</strong></p><h4 id="内存不可见性问题"><a href="#内存不可见性问题" class="headerlink" title="内存不可见性问题"></a>内存不可见性问题</h4><p><strong>线程间的共享变量存在主内存中，每个线程都有一个自己的本地内存，存储了该线程以读、写共享变量的副本</strong>。本地内存是一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器等。</p><p><strong>Java线程间的通信由Java内存模型（JMM）控制，JMM定义了线程与主内存间的抽象关系</strong>。</p><p><img src="https://f1bu920.github.io/images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java内存模型"></p><ol><li>所有的共享变量都在主内存中</li><li>每个线程保留了一份该线程使用到的共享变量的副本</li><li>线程A与线程B要通信的话，必须经过以下步骤：<ol><li>线程A将本地内存A更新过的共享变量刷新到主内存中</li><li>线程B到主内存中去读取已经更新过的共享变量</li></ol></li></ol><p><strong>线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。</strong></p><p>根据JMM规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存读取。</strong></p><p>也就是说，<strong>线程B不能直接去主内存中读取共享变量的值，而是先在本地内存找到这个共享变量，发现这个共享变量已经被更新过了，然后本地内存B去主内存中读取这个共享变量的新值，再拷贝到本地内存B中，最后线程B再读取本地内存B中的共享变量值</strong>。</p><p>至于如何知道共享变量已经被更新过了，就是JMM的作用了。<strong>JMM通过控制主内存与每个线程的本地内存之间的交互来提供内存可见性保证。</strong></p><p><em>Java中<code>volatile</code>关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，<code>synchronized</code>关键字不仅保证了可见性，也保证了原子性。在更底层，JMM通过内存屏障来实现内存的可见性与禁止重排序，并提出了happens-before。</em></p><h4 id="JMM与Java内存区域划分的区别与联系"><a href="#JMM与Java内存区域划分的区别与联系" class="headerlink" title="JMM与Java内存区域划分的区别与联系"></a>JMM与Java内存区域划分的区别与联系</h4><ul><li><p>区别</p><p><strong>JMM是抽象的，用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，时JVM运行Java程序时必要的内存划分。</strong></p></li><li><p>联系</p><p>都存在私有数据区和共享数据区。JMM中的主内存属于共享数据区，包含了堆和方法区；JMM中的本地内存属于私有数据区，包含了虚拟机栈、本地方法栈和程序计数器。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;共享内存并发模型&quot;&gt;&lt;a href=&quot;#共享内存并发模型&quot; class=&quot;headerlink&quot; title=&quot;共享内存并发模型&quot;&gt;&lt;/a&gt;共享内存并发模型&lt;/h2&gt;&lt;p&gt;并发编程模型有两个关键问题，即&lt;strong&gt;线程间如何通信，即线程间以何种机制来交换信息；线程间如何同步，即线程以何种机制来控制不同线程间操作发生的相对顺序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两个并发模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递并发模型&lt;/li&gt;
&lt;li&gt;共享内存并发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;如何通信&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;如何同步&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;消息传递并发模型&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;线程间没有公共状态，必须通过发送消息显示地进行通信&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;发送消息总在接受消息之前，同步是隐式的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;共享内存并发模型&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;线程间共享程序的公共状态，通过&lt;strong&gt;读-写内存中的公共状态&lt;/strong&gt;进行隐式通信&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;必须显示指定某段代码需要在线程之间互斥执行，同步是显示的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Java中使用的是共享内存并发模型。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程间的通信</title>
    <link href="http://yoursite.com/2020/04/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/04/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-13T06:52:18.000Z</published>
    <updated>2020-04-13T08:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一般来讲，线程内部有自己私有的线程上下文，互不干扰。但当我们需要多个线程相互协作时，就需要利用线程间的通信。以下介绍几种常用的通信机制。</p><a id="more"></a><h2 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h2><p>Java中锁的概念是基于对象的，所以又叫对象锁。<strong>一个锁同一时间只能被一个线程持有，也就是说一个锁如果被一个线程持有，其他线程要想获得这个锁只能等待这个锁被释放。</strong></p><p>线程同步就是<strong>线程按照一定的顺序执行</strong>。可以利用锁来实现同步。</p><p>如果我们想让两个线程按顺序打印，可以利用锁来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样线程a启动后首先获得锁，线程b启动后因为锁被线程a持有而一直处于等待状态，直到线程a执行完锁被释放。</p><h2 id="等待通知机制"><a href="#等待通知机制" class="headerlink" title="等待通知机制"></a>等待通知机制</h2><p>如上例基于锁的实现中，线程b会一直尝试去获得锁，如果失败了，再继续去尝试。这可能会很耗费资源。这时可以考虑等待/通知机制。</p><p><strong>等待/通知机制是基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>、<code>notifyAll()</code>方法实现的。<code>notify()</code>会随机唤醒一个等待的线程，<code>notifyAll()</code>会唤醒所有处于等待状态的线程</strong>。</p><p><strong>注意<code>wait()</code>方法会使线程释放锁！</strong></p><p>如果我们想要线程a、b交替打印的话，可以使用等待/通知机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个demo中，线程a、b先打印自己的内容，然后调用<code>notify()</code>方法唤醒另一个在等待的线程，然后调用<code>wait()</code>方法进入等待并释放锁。</p><p><strong>注意等待通知机制使用的是同一个对象锁，如果是使用不同的对象锁，是不能用等待通知机制的。</strong></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>JDK中提供了一个类似地实现了信号量功能的类<code>Semaphore</code>，这里我们利用<code>volatile</code>关键字自己实现信号量通信。</p><p><strong><code>volatile</code>关键字能够保证内存的可见性，如果用<code>volatile</code>声明了一个变量，在一个线程里改变了这个变量的值，那么在其他线程是立马可见更改后的值的。</strong></p><p>举例：两个线程a、b轮流递增地打印数字；(线程a打印0，线程b打印1，线程a打印2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (signal&lt;<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (signal%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadA: "</span>+signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (threadTest)&#123;</span><br><span class="line">                        signal++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (signal&lt;<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (signal%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadB: "</span>+signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (threadTest)&#123;</span><br><span class="line">                        signal++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>需要原子操作，而<code>signal++</code>并非原子操作，所以需要使用<code>synchronized</code>上锁。</strong></p><p>信号量常用于处理公共资源时，此时需要多个线程相互合作。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是基于“管道流”的通信方式。JDK提供了<code>PipedWriter</code>、<code>PipedReader</code>、<code>PipedOutputStream</code>、<code>PipedInputStream</code>。其中，前两个是基于字符的，后两个是基于字节的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(PipedReader reader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is ReaderThread"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (((receive = reader.read()) != -<span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(PipedWriter writer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is WriterThread"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.write(<span class="string">"write test!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        PipedReader pipedReader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        PipedWriter pipedWriter = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        pipedWriter.connect(pipedReader);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderThread(pipedReader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WriterThread(pipedWriter)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">this</span> is ReaderThread</span><br><span class="line"><span class="keyword">this</span> is WriterThread</span><br><span class="line">write test!</span><br></pre></td></tr></table></figure><p>通过线程的构造函数，我们传入了<code>PipedReader</code>、<code>PipedWriter</code>对象。</p><ol><li>线程<code>ReaderThread</code>开始执行</li><li>线程<code>ReaderThread</code>使用<code>reader.read()</code>进入阻塞</li><li>线程<code>WriterThread</code>开始执行</li><li>线程<code>WriterThread</code>用<code>writer.write()</code>向管道中写入字符</li><li>线程<code>WriterThread</code>使用<code>writer.close()</code>结束管道写入</li><li>线程<code>ReaderThread</code>接受管道输出的字符串并打印</li><li>执行完毕。</li></ol><p>很明显，管道通信多用于IO相关。</p><h2 id="其他通信相关"><a href="#其他通信相关" class="headerlink" title="其他通信相关"></a>其他通信相关</h2><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a><code>join</code>方法</h4><p><code>join()</code>方法是<code>Thread</code>类的实例方法，它可以让当前线程进入等待状态，直到join的这个线程执行完毕，再继续执行当前线程。</p><p>有时候，主线程创建并启动子线程，如果子线程要进行大量耗时计算而主线程需要子线程计算的结果，就可以用到<code>join()</code>方法，避免主线程早于子线程结束。</p><h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a><code>sleep</code>方法</h4><p><code>sleep()</code>方法是<code>Thread</code>类的静态方法，它可以让当前线程睡眠一段时间。</p><p><strong>注意，与<code>wait(long)</code>不同，<code>sleep(long)</code>不会释放当前的锁！</strong></p><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a><code>ThreadLocal</code>类</h4><p><code>ThreadLocal</code>是本地线程副本变量工具类，内部使用一个弱引用的<code>Map</code>来维护。</p><p>它使每个线程都有自己独立的变量，互不干扰。它为每个线程都创建了副本，每个线程都可以访问自己内部的副本变量。</p><p>最常见的<code>ThreadLocal</code>类应用场景就是用来解决数据库连接、Session管理等。</p><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a><code>InheritableThreadLocal</code></h4><p>它不仅仅是当前线程可以存取副本值，它的子线程也可以存取这个副本值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一般来讲，线程内部有自己私有的线程上下文，互不干扰。但当我们需要多个线程相互协作时，就需要利用线程间的通信。以下介绍几种常用的通信机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的状态与主要转换方法</title>
    <link href="http://yoursite.com/2020/04/10/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/10/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-10T06:32:34.000Z</published>
    <updated>2020-04-11T06:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="操作系统中的线程状态转换"><a href="#操作系统中的线程状态转换" class="headerlink" title="操作系统中的线程状态转换"></a>操作系统中的线程状态转换</h2><p>在现代操作系统中，线程被视为轻量级进程，所以操作系统中线程的状态其实是和操作系统中进程的状态是一致的。</p><p><img src="https://f1bu920.github.io/images/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="操作系统中线程状态转换.png"></p><p>操作系统中线程主要有三个状态：</p><ul><li>就绪状态(ready)：线程正在等待使用CPU，等分配到CPU时间片就可以进入running状态。</li><li>执行状态(running)：线程正在使用CPU。</li><li>等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源，如 I/O等。</li></ul><a id="more"></a><h2 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h2><p>Java中有一个枚举类，代表了Java线程的6个状态，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a><code>NEW</code></h4><p>处于<code>NEW</code>状态的线程尚未启动，即未调用<code>Thread</code>类的<code>start</code>方法。</p><p><code>start</code>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>start()</code>方法的内部有一个<code>threadStatus</code>变量，如果它不为0，会直接抛出异常。</p><p>在第一次调用<code>start()</code>方法后，<code>threadStatus</code>变量会从0变为其他值，若第二次调用<code>start()</code>方法就会抛出<code>IllegalThreadStateException</code>异常。</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a><code>RUNNABLE</code></h4><p><code>RUNNABLE</code>表示当前线程正在运行中。<code>RUNNABLE</code>状态的线程运行在虚拟机中，也有可能在等待操作系统的其他资源。<strong>Java中<code>RUNNABLE</code>状态其实包括了操作系统线程的<code>ready</code>和<code>waiting</code>两个状态。</strong></p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a><code>BLOCKED</code></h4><p>阻塞状态。处于<code>BLOCKED</code>状态的线程正等待锁的释放以进入同步区。</p><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a><code>WAITING</code></h4><p>等待状态。处于等待状态的线程要想变为<code>RUNNABLE</code>状态需要其他线程唤醒。</p><p>调用下面三个方法会使线程进入<code>WAITING</code>状态：</p><ul><li><code>Object wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它。</li><li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是<code>Object</code>实例的<code>wait</code>方法。</li><li><code>LockSupport.park()</code>：除非获得调用许可，否则禁止当前线程进行线程调度。</li></ul><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a><code>TIMED_WAITING</code></h4><p>超时等待状态。线程等待一个具体的时间，时间到后自动唤醒。</p><p>调用下面方法会使线程进入超时等待状态：</p><ul><li><code>Tread.sleep(long millis)</code>：使当前线程睡眠指定时间</li><li><code>Object wait(long millis)</code>：线程休眠指定时间，等待期间可以通过<code>notify()</code>方法唤醒。</li><li><code>Thread.join(long millis)</code>：等待当前线程最多执行millis毫秒，如果<code>millis</code>为0，则会一直执行。</li><li><code>LockSupport.parkNanos(long nanos)</code>：除非获得调用许可，否则禁用当前线程进行线程调度指定时间。</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间。</li></ul><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a><code>TERMINATED</code></h4><p>终止状态，线程执行完毕。</p><h2 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h2><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="线程状态的转换"></p><h4 id="BLOCKED与RUNNABLE状态的转换"><a href="#BLOCKED与RUNNABLE状态的转换" class="headerlink" title="BLOCKED与RUNNABLE状态的转换"></a><code>BLOCKED</code>与<code>RUNNABLE</code>状态的转换</h4><p>处于<code>BLOCKED</code>状态的线程是因为在等待锁的释放。当线程获取到锁之后就会进入<code>RUNNABLE</code>状态。</p><h4 id="WAITING状态与RUNNABLE状态的转换"><a href="#WAITING状态与RUNNABLE状态的转换" class="headerlink" title="WAITING状态与RUNNABLE状态的转换"></a><code>WAITING</code>状态与<code>RUNNABLE</code>状态的转换</h4><p>将线程从<code>RUNNABLE</code>状态转换为<code>WAITING</code>状态主要有2种方法。</p><ul><li><p><code>Object.wait()</code></p><p>调用<code>wait()</code>方法前线程必须持有对象的锁，<strong>调用<code>wait()</code>方法后，会释放当前的锁，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>唤醒等待锁的线程</strong>。</p></li><li><p><code>Thread.join()</code></p><p><strong>调用<code>join()</code>方法不会释放锁，会一直等待当前线程执行完毕(转换为<code>TERMINTED</code>状态)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> ThreadTest().testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> ThreadTest().testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        a.join();</span><br><span class="line">        b.start();</span><br><span class="line">        System.out.println(a.getName() + <span class="string">": "</span> + a.getState());</span><br><span class="line">        System.out.println(b.getName() + <span class="string">": "</span> + b.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">Thread-<span class="number">0</span>: TERMINATED</span><br><span class="line">Thread-<span class="number">1</span>: TIMED_WAITING</span><br></pre></td></tr></table></figure><p>要是没有调用<code>join()</code>方法，<code>main</code>线程不管<code>a</code>线程是否执行完毕都会往下执行，但<code>a</code>线程启动后立刻调用了<code>join()</code>方法，这里<code>main</code>线程就会等待直到<code>a</code>执行完毕(转换为<code>TERMINTED</code>状态)。</p><p>所以<code>a</code>会打印的状态为<code>TERMINATED</code>，而<code>b</code>线程可能为<code>TIMED_WAITING</code>状态(已进入同步方法)也可能为<code>RUNNABLE</code>状态(未进入同步方法)。</p></li></ul><h4 id="TIMED-WAITING与RUNNABLE状态的转换"><a href="#TIMED-WAITING与RUNNABLE状态的转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态的转换"></a><code>TIMED_WAITING</code>与<code>RUNNABLE</code>状态的转换</h4><p><code>TIMED_WAITING</code>与<code>WAITING</code>状态类似，只是<code>TIMED_WAITING</code>等待时间是指定的。</p><ul><li><p><code>Thread.sleep(long)</code></p><p>使当前线程睡眠指定时间。<strong>这里的睡眠指的是暂停执行，并不会释放锁</strong>。时间到后，会自动进入<code>RUNNABLE</code>状态。</p></li><li><p><code>Object.wait(long)</code></p><p>使线程进入<code>TIMED_WAITING</code>状态，<strong>会释放锁</strong>。经过指定时间后，自动唤醒，拥有去争夺锁的资格。</p></li><li><p><code>Thread.join(long)</code></p><p>使当前线程执行指定时间，并且使线程进入<code>TIMED_WAITING</code>状态。</p></li></ul><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>当线程启动后不需要它继续执行下去的时候，需要线程中断机制。线程中断机制是一种协作机制，<strong>通过中断操作并不能直接终止一个线程，而是通知需要中断的线程自行处理。</strong></p><ul><li><p><code>Thread.interrupt()</code></p><p>中断线程。并不会立即停止线程，而是设置线程的中断状态为<code>true</code>，默认为<code>false</code>。</p></li><li><p><code>Thread.interrupted()</code></p><p>测试当前线程是否被中断。调用一次这个方法会使中断状态设置为<code>true</code>，调用两次中断状态重新转变为<code>false</code>。</p></li><li><p><code>Thread.isInterrupted()</code></p><p>测试当前线程状态是否被中断，与上面方法不同的是不会影响线程的中断状态。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;操作系统中的线程状态转换&quot;&gt;&lt;a href=&quot;#操作系统中的线程状态转换&quot; class=&quot;headerlink&quot; title=&quot;操作系统中的线程状态转换&quot;&gt;&lt;/a&gt;操作系统中的线程状态转换&lt;/h2&gt;&lt;p&gt;在现代操作系统中，线程被视为轻量级进程，所以操作系统中线程的状态其实是和操作系统中进程的状态是一致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png&quot; alt=&quot;操作系统中线程状态转换.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;操作系统中线程主要有三个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态(ready)：线程正在等待使用CPU，等分配到CPU时间片就可以进入running状态。&lt;/li&gt;
&lt;li&gt;执行状态(running)：线程正在使用CPU。&lt;/li&gt;
&lt;li&gt;等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源，如 I/O等。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程组和线程优先级</title>
    <link href="http://yoursite.com/2020/04/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/04/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2020-04-09T08:03:05.000Z</published>
    <updated>2020-04-09T08:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="线程组与线程优先级"><a href="#线程组与线程优先级" class="headerlink" title="线程组与线程优先级"></a>线程组与线程优先级</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用<code>ThreadGoup</code>来表示线程组，我们可以使用线程组对线程进行批量控制。</p><p>每个<code>Thread</code>必然存在于一个<code>ThreadGroup</code>中，<code>Thread</code>不能独立于<code>ThreadGroup</code>存在。执行<code>main()</code>方法的主线程所在的线程组名字为”main”，如果我们<code>new Thread()</code>时不指定线程组，那么默认将父线程 (当前执行<code>new Thread</code>) 的线程组设为自己的线程组。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程组名称: "</span> + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">            System.out.println(<span class="string">"当前线程名称: "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">"main方法所在线程的线程组名称： "</span> + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%93%E6%9E%9C1.png" alt="结果"></p><a id="more"></a><p><code>ThreadGroup</code>管理着它下面的<code>Thread</code>，<code>ThreadGroup</code>是一个标准的向下引用的树状结构，这样是为了<strong>防止“上级”线程被“下级线程”引用而无法有效地被GC回收。</strong></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>Java中我们可以指定线程的优先级，从1~10。但在操作系统中并不是按1到10划分线程优先级，比如有些操作系统只支持三级划分：低、中、高。线程最终的优先级由操作系统决定。</p><p>Java默认的线程优先级为5，线程的执行顺序由调度程序确定，通常情况下，高优先级的线程会比低优先级的线程有更高的几率被运行。可以通过<code>Thread</code>类的<code>setPriority()</code>方法设定线程优先级。</p><p><strong>注：Java中的线程优先级只是给操作系统一个建议，并不是一定会按照这个优先级执行，真正的调用顺序由操作系统的线程调度算法决定。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;线程组与线程优先级&quot;&gt;&lt;a href=&quot;#线程组与线程优先级&quot; class=&quot;headerlink&quot; title=&quot;线程组与线程优先级&quot;&gt;&lt;/a&gt;线程组与线程优先级&lt;/h1&gt;&lt;h2 id=&quot;线程组&quot;&gt;&lt;a href=&quot;#线程组&quot; class=&quot;headerlink&quot; title=&quot;线程组&quot;&gt;&lt;/a&gt;线程组&lt;/h2&gt;&lt;p&gt;Java使用&lt;code&gt;ThreadGoup&lt;/code&gt;来表示线程组，我们可以使用线程组对线程进行批量控制。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Thread&lt;/code&gt;必然存在于一个&lt;code&gt;ThreadGroup&lt;/code&gt;中，&lt;code&gt;Thread&lt;/code&gt;不能独立于&lt;code&gt;ThreadGroup&lt;/code&gt;存在。执行&lt;code&gt;main()&lt;/code&gt;方法的主线程所在的线程组名字为”main”，如果我们&lt;code&gt;new Thread()&lt;/code&gt;时不指定线程组，那么默认将父线程 (当前执行&lt;code&gt;new Thread&lt;/code&gt;) 的线程组设为自己的线程组。举例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;当前线程组名称: &quot;&lt;/span&gt; + Thread.currentThread().getThreadGroup().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;当前线程名称: &quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;main方法所在线程的线程组名称： &quot;&lt;/span&gt; + Thread.currentThread().getThreadGroup().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%93%E6%9E%9C1.png&quot; alt=&quot;结果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
