<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flbu blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-18T02:15:52.430Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>flbu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode11.盛最多水的容器</title>
    <link href="http://yoursite.com/2020/04/18/Leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2020/04/18/Leetcode11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-18T01:56:45.000Z</published>
    <updated>2020-04-18T02:15:52.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode11-盛最多水的容器"><a href="#Leetcode11-盛最多水的容器" class="headerlink" title="Leetcode11.盛最多水的容器"></a>Leetcode11.盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://f1bu920.github.io/images/Leetcode11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg" alt="Leetcode11.盛最多水的容器.jpg"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p> <a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>暴力法</p><p>两次遍历整个数组，找到最大盛水容量</p></li><li><p>双指针法</p><p>开始时令两个指针分别指向数组的开头和末尾，记录当前的容量。</p><p>移动对于数组中数字较小的那个指针，这是因为<strong>容纳的水量为两个指针指向数字的较小值*指针间的距离。</strong></p><p>如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>暴力法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxCapacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                capacity = Math.min(height[i], height[j]) * (j - i);</span><br><span class="line">                maxCapacity = Math.max(capacity, maxCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxCapacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            capacity = Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            maxCapacity = Math.max(capacity, maxCapacity);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &gt; height[r]) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#Leetcode11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;Leetcode11.盛最多水的容器&quot;&gt;&lt;/a&gt;Leetcode11.盛最多水的容器&lt;/h2&gt;&lt;p&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Leetcode11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg&quot; alt=&quot;Leetcode11.盛最多水的容器.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode55.跳跃游戏</title>
    <link href="http://yoursite.com/2020/04/17/Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2020/04/17/Leetcode55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-17T00:44:56.000Z</published>
    <updated>2020-04-17T00:54:31.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode55-跳跃游戏"><a href="#Leetcode55-跳跃游戏" class="headerlink" title="Leetcode55.跳跃游戏"></a>Leetcode55.跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于数组中的任意一个位置，如果它本身可以到达，那么它跳跃的最大长度就一定可以到达，<code>i + nums[i]&gt;=y</code>，那么位置y也可以到达。</p><p>遍历整个数组中的每一个位置，记录最远可以到达的位置<code>farmost</code>，如果<code>farmost&gt;=n-1</code>，则一定可以到达最后一个位置，返回<code>true</code>；遍历结束后返回<code>false</code>。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> farmost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= farmost) &#123;</span><br><span class="line">                farmost = Math.max(farmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (farmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode55-跳跃游戏&quot;&gt;&lt;a href=&quot;#Leetcode55-跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;Leetcode55.跳跃游戏&quot;&gt;&lt;/a&gt;Leetcode55.跳跃游戏&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode56.合并区间</title>
    <link href="http://yoursite.com/2020/04/16/Leetcode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2020/04/16/Leetcode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2020-04-16T01:02:02.000Z</published>
    <updated>2020-04-16T01:11:54.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode56-合并区间"><a href="#Leetcode56-合并区间" class="headerlink" title="Leetcode56.合并区间"></a>Leetcode56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><a href="https://leetcode-cn.com/problems/merge-intervals" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p>示例 2:</p><blockquote><p>输入: [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据区间的额左端点升序排序，遍历整个数组。</p><ul><li>如果下一个区间的左端点在当前区间右端点的左边，即<code>intervals[i+1][0] &lt;= intervals[i][1]</code>，则这两个区间可以合并。将下一个区间的左端点赋为当前区间的左端点，即<code>intervals[i+1][0] = intervals[i][0]</code>，将下一个区间的右端点赋为这两个区间右端点的最大值，即<code>intervals[i+1][1] = Math.max(intervals[i][1], intervals[i+1][1])</code>。</li><li>否则将当前区间添加到集合中</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(interval -&gt; interval[<span class="number">0</span>]));</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                intervals[i + <span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">                intervals[i + <span class="number">1</span>][<span class="number">1</span>] = Math.max(intervals[i + <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(intervals[intervals.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode56-合并区间&quot;&gt;&lt;a href=&quot;#Leetcode56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;Leetcode56.合并区间&quot;&gt;&lt;/a&gt;Leetcode56.合并区间&lt;/h2&gt;&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="sort" scheme="http://yoursite.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-内存模型</title>
    <link href="http://yoursite.com/2020/04/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/04/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-04-14T05:20:02.000Z</published>
    <updated>2020-04-18T02:16:38.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="共享内存并发模型"><a href="#共享内存并发模型" class="headerlink" title="共享内存并发模型"></a>共享内存并发模型</h2><p>并发编程模型有两个关键问题，即<strong>线程间如何通信，即线程间以何种机制来交换信息；线程间如何同步，即线程以何种机制来控制不同线程间操作发生的相对顺序。</strong></p><p>有两个并发模型</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><table><thead><tr><th align="center"></th><th align="center">如何通信</th><th align="center">如何同步</th></tr></thead><tbody><tr><td align="center">消息传递并发模型</td><td align="center">线程间没有公共状态，必须通过发送消息显示地进行通信</td><td align="center">发送消息总在接受消息之前，同步是隐式的</td></tr><tr><td align="center">共享内存并发模型</td><td align="center">线程间共享程序的公共状态，通过<strong>读-写内存中的公共状态</strong>进行隐式通信</td><td align="center">必须显示指定某段代码需要在线程之间互斥执行，同步是显示的。</td></tr></tbody></table><p><strong>Java中使用的是共享内存并发模型。</strong></p><a id="more"></a><h2 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h2><h4 id="运行时内存的划分"><a href="#运行时内存的划分" class="headerlink" title="运行时内存的划分"></a>运行时内存的划分</h4><p>运行时数据区：</p><p><img src="https://f1bu920.github.io/images/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="Java运行时数据区"></p><p>其中，<strong>堆和方法区是所有线程共享的数据区，虚拟机栈、本地方法栈和程序计数器是线程私有的数据区。</strong></p><p>对于每一个线程，栈都是私有的，堆都是共有的。</p><p>在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程间共享，也就不会有内存可见性问题，不受内存模型的影响。而在堆中的变量是共享的，称为共享变量。</p><p><strong>内存可见性针对的是共享变量。</strong></p><h4 id="内存不可见性问题"><a href="#内存不可见性问题" class="headerlink" title="内存不可见性问题"></a>内存不可见性问题</h4><p><strong>线程间的共享变量存在主内存中，每个线程都有一个自己的本地内存，存储了该线程以读、写共享变量的副本</strong>。本地内存是一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器等。</p><p><strong>Java线程间的通信由Java内存模型（JMM）控制，JMM定义了线程与主内存间的抽象关系</strong>。</p><p><img src="https://f1bu920.github.io/images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java内存模型"></p><ol><li>所有的共享变量都在主内存中</li><li>每个线程保留了一份该线程使用到的共享变量的副本</li><li>线程A与线程B要通信的话，必须经过以下步骤：<ol><li>线程A将本地内存A更新过的共享变量刷新到主内存中</li><li>线程B到主内存中去读取已经更新过的共享变量</li></ol></li></ol><p><strong>线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。</strong></p><p>根据JMM规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存读取。</strong></p><p>也就是说，<strong>线程B不能直接去主内存中读取共享变量的值，而是先在本地内存找到这个共享变量，发现这个共享变量已经被更新过了，然后本地内存B去主内存中读取这个共享变量的新值，再拷贝到本地内存B中，最后线程B再读取本地内存B中的共享变量值</strong>。</p><p>至于如何知道共享变量已经被更新过了，就是JMM的作用了。<strong>JMM通过控制主内存与每个线程的本地内存之间的交互来提供内存可见性保证。</strong></p><p><em>Java中<code>volatile</code>关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，<code>synchronized</code>关键字不仅保证了可见性，也保证了原子性。在更底层，JMM通过内存屏障来实现内存的可见性与禁止重排序，并提出了happens-before。</em></p><h4 id="JMM与Java内存区域划分的区别与联系"><a href="#JMM与Java内存区域划分的区别与联系" class="headerlink" title="JMM与Java内存区域划分的区别与联系"></a>JMM与Java内存区域划分的区别与联系</h4><ul><li><p>区别</p><p><strong>JMM是抽象的，用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，时JVM运行Java程序时必要的内存划分。</strong></p></li><li><p>联系</p><p>都存在私有数据区和共享数据区。JMM中的主内存属于共享数据区，包含了堆和方法区；JMM中的本地内存属于私有数据区，包含了虚拟机栈、本地方法栈和程序计数器。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;共享内存并发模型&quot;&gt;&lt;a href=&quot;#共享内存并发模型&quot; class=&quot;headerlink&quot; title=&quot;共享内存并发模型&quot;&gt;&lt;/a&gt;共享内存并发模型&lt;/h2&gt;&lt;p&gt;并发编程模型有两个关键问题，即&lt;strong&gt;线程间如何通信，即线程间以何种机制来交换信息；线程间如何同步，即线程以何种机制来控制不同线程间操作发生的相对顺序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两个并发模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息传递并发模型&lt;/li&gt;
&lt;li&gt;共享内存并发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;如何通信&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;如何同步&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;消息传递并发模型&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;线程间没有公共状态，必须通过发送消息显示地进行通信&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;发送消息总在接受消息之前，同步是隐式的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;共享内存并发模型&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;线程间共享程序的公共状态，通过&lt;strong&gt;读-写内存中的公共状态&lt;/strong&gt;进行隐式通信&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;必须显示指定某段代码需要在线程之间互斥执行，同步是显示的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Java中使用的是共享内存并发模型。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode445.两数相加II</title>
    <link href="http://yoursite.com/2020/04/14/Leetcode445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>http://yoursite.com/2020/04/14/Leetcode445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/</id>
    <published>2020-04-14T03:19:08.000Z</published>
    <updated>2020-04-14T03:58:11.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode445-两数相加II"><a href="#Leetcode445-两数相加II" class="headerlink" title="Leetcode445.两数相加II"></a>Leetcode445.两数相加II</h2><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p> <a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例：</p><blockquote><p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>将链表反转再相加</p></li><li><p>栈</p><p>因为题中数位的顺序是逆序的，为了逆序处理所有数位，可以利用栈。</p><p>将所有数字压入栈中，再依次取出相加，注意进位。</p><p>代码略。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>反转链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode headA = reverseLinkedList(l1);</span><br><span class="line">        ListNode headB = reverseLinkedList(l2);</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode pre = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span> &amp;&amp; headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = headA.val + headB.val + carry;</span><br><span class="line">            <span class="keyword">if</span> (result &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                result %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">            ListNode cur = <span class="keyword">new</span> ListNode(result);</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1-&gt;null, 9-&gt;null的情况</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span> &amp;&amp; headA == <span class="keyword">null</span> &amp;&amp; headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            pre.next.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.next = headA;</span><br><span class="line">            <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> result = headA.val + carry;</span><br><span class="line">                <span class="keyword">if</span> (result &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    result %= <span class="number">10</span>;</span><br><span class="line">                    carry = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    carry = <span class="number">0</span>;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                headA.val = result;</span><br><span class="line">                pre = headA;</span><br><span class="line">                headA = headA.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">                pre.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.next = headB;</span><br><span class="line">            <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> result = headB.val + carry;</span><br><span class="line">                <span class="keyword">if</span> (result &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    result %= <span class="number">10</span>;</span><br><span class="line">                    carry = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    carry = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                headB.val = result;</span><br><span class="line">                pre = headB;</span><br><span class="line">                headB = headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">                pre.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseLinkedList(dummyHead.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseLinkedList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode445-两数相加II&quot;&gt;&lt;a href=&quot;#Leetcode445-两数相加II&quot; class=&quot;headerlink&quot; title=&quot;Leetcode445.两数相加II&quot;&gt;&lt;/a&gt;Leetcode445.两数相加II&lt;/h2&gt;&lt;p&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;p&gt;如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程间的通信</title>
    <link href="http://yoursite.com/2020/04/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/04/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-13T06:52:18.000Z</published>
    <updated>2020-04-13T08:49:39.044Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一般来讲，线程内部有自己私有的线程上下文，互不干扰。但当我们需要多个线程相互协作时，就需要利用线程间的通信。以下介绍几种常用的通信机制。</p><a id="more"></a><h2 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h2><p>Java中锁的概念是基于对象的，所以又叫对象锁。<strong>一个锁同一时间只能被一个线程持有，也就是说一个锁如果被一个线程持有，其他线程要想获得这个锁只能等待这个锁被释放。</strong></p><p>线程同步就是<strong>线程按照一定的顺序执行</strong>。可以利用锁来实现同步。</p><p>如果我们想让两个线程按顺序打印，可以利用锁来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样线程a启动后首先获得锁，线程b启动后因为锁被线程a持有而一直处于等待状态，直到线程a执行完锁被释放。</p><h2 id="等待通知机制"><a href="#等待通知机制" class="headerlink" title="等待通知机制"></a>等待通知机制</h2><p>如上例基于锁的实现中，线程b会一直尝试去获得锁，如果失败了，再继续去尝试。这可能会很耗费资源。这时可以考虑等待/通知机制。</p><p><strong>等待/通知机制是基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>、<code>notifyAll()</code>方法实现的。<code>notify()</code>会随机唤醒一个等待的线程，<code>notifyAll()</code>会唤醒所有处于等待状态的线程</strong>。</p><p><strong>注意<code>wait()</code>方法会使线程释放锁！</strong></p><p>如果我们想要线程a、b交替打印的话，可以使用等待/通知机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadTest.testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个demo中，线程a、b先打印自己的内容，然后调用<code>notify()</code>方法唤醒另一个在等待的线程，然后调用<code>wait()</code>方法进入等待并释放锁。</p><p><strong>注意等待通知机制使用的是同一个对象锁，如果是使用不同的对象锁，是不能用等待通知机制的。</strong></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>JDK中提供了一个类似地实现了信号量功能的类<code>Semaphore</code>，这里我们利用<code>volatile</code>关键字自己实现信号量通信。</p><p><strong><code>volatile</code>关键字能够保证内存的可见性，如果用<code>volatile</code>声明了一个变量，在一个线程里改变了这个变量的值，那么在其他线程是立马可见更改后的值的。</strong></p><p>举例：两个线程a、b轮流递增地打印数字；(线程a打印0，线程b打印1，线程a打印2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (signal&lt;<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (signal%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadA: "</span>+signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (threadTest)&#123;</span><br><span class="line">                        signal++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (signal&lt;<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (signal%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ThreadB: "</span>+signal);</span><br><span class="line">                    <span class="keyword">synchronized</span> (threadTest)&#123;</span><br><span class="line">                        signal++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>需要原子操作，而<code>signal++</code>并非原子操作，所以需要使用<code>synchronized</code>上锁。</strong></p><p>信号量常用于处理公共资源时，此时需要多个线程相互合作。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是基于“管道流”的通信方式。JDK提供了<code>PipedWriter</code>、<code>PipedReader</code>、<code>PipedOutputStream</code>、<code>PipedInputStream</code>。其中，前两个是基于字符的，后两个是基于字节的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(PipedReader reader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is ReaderThread"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (((receive = reader.read()) != -<span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(PipedWriter writer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is WriterThread"</span>);</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.write(<span class="string">"write test!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        PipedReader pipedReader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        PipedWriter pipedWriter = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        pipedWriter.connect(pipedReader);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReaderThread(pipedReader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WriterThread(pipedWriter)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">this</span> is ReaderThread</span><br><span class="line"><span class="keyword">this</span> is WriterThread</span><br><span class="line">write test!</span><br></pre></td></tr></table></figure><p>通过线程的构造函数，我们传入了<code>PipedReader</code>、<code>PipedWriter</code>对象。</p><ol><li>线程<code>ReaderThread</code>开始执行</li><li>线程<code>ReaderThread</code>使用<code>reader.read()</code>进入阻塞</li><li>线程<code>WriterThread</code>开始执行</li><li>线程<code>WriterThread</code>用<code>writer.write()</code>向管道中写入字符</li><li>线程<code>WriterThread</code>使用<code>writer.close()</code>结束管道写入</li><li>线程<code>ReaderThread</code>接受管道输出的字符串并打印</li><li>执行完毕。</li></ol><p>很明显，管道通信多用于IO相关。</p><h2 id="其他通信相关"><a href="#其他通信相关" class="headerlink" title="其他通信相关"></a>其他通信相关</h2><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a><code>join</code>方法</h4><p><code>join()</code>方法是<code>Thread</code>类的实例方法，它可以让当前线程进入等待状态，直到join的这个线程执行完毕，再继续执行当前线程。</p><p>有时候，主线程创建并启动子线程，如果子线程要进行大量耗时计算而主线程需要子线程计算的结果，就可以用到<code>join()</code>方法，避免主线程早于子线程结束。</p><h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a><code>sleep</code>方法</h4><p><code>sleep()</code>方法是<code>Thread</code>类的静态方法，它可以让当前线程睡眠一段时间。</p><p><strong>注意，与<code>wait(long)</code>不同，<code>sleep(long)</code>不会释放当前的锁！</strong></p><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a><code>ThreadLocal</code>类</h4><p><code>ThreadLocal</code>是本地线程副本变量工具类，内部使用一个弱引用的<code>Map</code>来维护。</p><p>它使每个线程都有自己独立的变量，互不干扰。它为每个线程都创建了副本，每个线程都可以访问自己内部的副本变量。</p><p>最常见的<code>ThreadLocal</code>类应用场景就是用来解决数据库连接、Session管理等。</p><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a><code>InheritableThreadLocal</code></h4><p>它不仅仅是当前线程可以存取副本值，它的子线程也可以存取这个副本值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一般来讲，线程内部有自己私有的线程上下文，互不干扰。但当我们需要多个线程相互协作时，就需要利用线程间的通信。以下介绍几种常用的通信机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode42.接雨水</title>
    <link href="http://yoursite.com/2020/04/12/Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://yoursite.com/2020/04/12/Leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-04-12T05:41:18.000Z</published>
    <updated>2020-04-12T05:56:07.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode42-接雨水"><a href="#Leetcode42-接雨水" class="headerlink" title="Leetcode42.接雨水"></a>Leetcode42.接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://f1bu920.github.io/images/rainwatertrap.png" alt="rainwatertrap"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例:</p><blockquote><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>暴力法</p><p>对于数组中的每个元素，我们找到下雨水后能达到的最高位置等于两边最大高度的较小值减去其本身的高度。</p></li><li><p>动态规划</p><p>我们使用<code>max_left[i]</code>存储<code>i</code>左边的最大高度，用<code>max_right[i]</code>存储<code>i</code>右边的最大高度，<strong>注意不包括<code>i</code>本身</strong>。最后，将<code>min(max_left,max_right)-height[i]</code>累加到结果上。</p></li><li><p>双指针与栈</p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/" target="_blank" rel="noopener">参考链接</a></p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>暴力法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> max_right = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//往左搜索，找到左边的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                max_left = Math.max(max_left, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往右搜索，找到右边的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                max_right = Math.max(max_right, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += Math.min(max_left, max_right) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] max_left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] max_right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//存储左边的最大高度，不包括本身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max_left[i] = Math.max(max_left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储右边的最大高度，不包括本身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max_right[i] = Math.max(max_right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(max_left[i], max_right[i]);</span><br><span class="line">            <span class="comment">//因为不包括本身，所以要判断</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[i]) &#123;</span><br><span class="line">                res += min - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode42-接雨水&quot;&gt;&lt;a href=&quot;#Leetcode42-接雨水&quot; class=&quot;headerlink&quot; title=&quot;Leetcode42.接雨水&quot;&gt;&lt;/a&gt;Leetcode42.接雨水&lt;/h2&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/rainwatertrap.png&quot; alt=&quot;rainwatertrap&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode887.鸡蛋掉落</title>
    <link href="http://yoursite.com/2020/04/11/Leetcode887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/"/>
    <id>http://yoursite.com/2020/04/11/Leetcode887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/</id>
    <published>2020-04-11T03:37:45.000Z</published>
    <updated>2020-04-11T04:21:13.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode887-鸡蛋掉落"><a href="#Leetcode887-鸡蛋掉落" class="headerlink" title="Leetcode887.鸡蛋掉落"></a>Leetcode887.鸡蛋掉落</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p> <a href="https://leetcode-cn.com/problems/super-egg-drop" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：K = 1, N = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</p></blockquote><p>示例 2：</p><blockquote><p>输入：K = 2, N = 6<br>输出：3<br>示例 3：</p><p>输入：K = 3, N = 14<br>输出：4</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= K &lt;= 100<br>1 &lt;= N &lt;= 10000</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/" target="_blank" rel="noopener">参考链接</a></p><p>题意解释：</p><ul><li>题目中“移动”的意思是：把一个鸡蛋从某个楼层扔下去，看它是否破碎。没破的鸡蛋可以重复使用。</li><li>这 K 个鸡蛋，F 值满足的特点是：<br>在所有小于等于 F 的楼层扔下它不破碎；<br>在所有大于 F 的楼层扔下它一定会破碎；<br>所有鸡蛋的 F 值都一样，且确定的，并且 0 &lt;= F &lt;= N，即 F 值一定不会超过楼层高度。</li><li>F值是确定的，但它不是题目要我们求的。题目要我们求的是找到这个 F 值的最小实验次数。这其实是时间复杂度的概念，时间复杂度是在最坏情况下（即运气最差的情况下），程序执行完毕最少执行的次数，例如：<ul><li>在一个数组（长度为 NN）里查找一个数，找到某个数可以用线性查找，最好情况下，下标为 0 的位置就是要找的元素，但是在计算复杂度的时候，需要考虑到最差情况，即看到最后一个位置的时候，才找到这个元素，因此至少执行数组长度这么多次的查找，才能找到；</li><li>在一个有序数组（长度为 NN）里查找，可以使用二分查找算法，最好情况下依然是 1 次就找到（中点位置），但是最坏情况下，例如中点的两个邻居，就得找 \log NlogN（这个数值需要上取整，这里不深究）次；</li></ul></li><li>题目中的「最小」字眼很让人迷惑，我的理解是：把求解 F 的过程认为是用最好的算法，即使是在最坏的运气下，为了准确得到结果，找到 F 这个值的实验的次数最少是多少。</li></ul><p>解法：</p><ul><li><p>动态规划</p><p>令<code>dp[i][j]</code>代表<code>i</code>层使用<code>j</code>个鸡蛋的最少试验次数，<strong>注意这里<code>i</code>不是楼层高度，而是层数</strong>。<code>j</code>表示可以使用鸡蛋的个数，是约束条件。</p><p>设指定的楼层为<code>k</code>，<code>k&gt;=1</code>且<code>k&lt;=i</code>.</p><ul><li>如果鸡蛋破碎，所以<code>F</code>在<code>k</code>层以下(不包括<code>k</code>层)，因为这里已经使用了一个鸡蛋，所以最少试验次数为<code>dp[k-1][j-1]</code></li><li>如果鸡蛋完好，则<code>F</code>在<code>k</code>层以上，这个鸡蛋还能使用，所以最少试验次数为<code>dp[k+1][j]</code>。</li></ul><p>最坏的情况是这两个子问题的较大者，<code>k</code>的取值范围为<code>[1,i]</code>，对于每个<code>k</code>都对应着一个最大值，所以<br>$$<br>dp[i][j]=<br>1≤k≤i<br>min</p><p> (max(dp[k−1][j−1],dp[i−k][j]+1))<br>$$<br>初始化：</p><p>这里需要<code>0</code>这个状态的值，它的值会被后来的值参考到，所以表格需要<code>N+1</code>行<code>K+1</code>列。</p><ul><li>第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 <code>F</code> 值，故全为 0； </li><li>第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次； </li><li>第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 <code>F</code> 值，故全为 0，虽然不符合题意，但是这个值有效，它在后面的计算中会被用到； </li><li>第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 <code>F</code> 值，最少次数就等于楼层高度； </li></ul><p>单纯的动态规划时间复杂度为O(<del>NK^2</del>)，超出时间限制。</p></li><li><p>二分搜索+动态规划</p><p><code>dp[k - 1][j - 1]</code>：根据语义，<code>k</code> 增大的时候，楼层大小越大，它的值就越大，是单调递增的函数；</p><p><code>dp[i - k][j]</code>：根据语义，<code>k</code> 增大的时候，楼层大小越小，它的值就越小，是单调递减的函数。</p><p>当找到他们交汇的时候，二者较大值的最小者一定出现在那里。</p><p>也就是找到使得 <code>dp[i - k][j] &lt;= dp[k - i][j - 1]</code>最大的那个 <code>k</code>值即可。这里使用二分查找算法。关键在于 <code>dp[i - k][j] &gt; dp[k - i][j - 1]</code>的时候，<code>k</code> 一定不是我们要找的，根据这一点写出二分的代码。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第0行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>二分搜索+动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第0行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp[mid - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp[i - mid][j];</span><br><span class="line">                    <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.max(dp[left - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - left][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode887-鸡蛋掉落&quot;&gt;&lt;a href=&quot;#Leetcode887-鸡蛋掉落&quot; class=&quot;headerlink&quot; title=&quot;Leetcode887.鸡蛋掉落&quot;&gt;&lt;/a&gt;Leetcode887.鸡蛋掉落&lt;/h2&gt;&lt;p&gt;你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。&lt;/p&gt;
&lt;p&gt;每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。&lt;/p&gt;
&lt;p&gt;你知道存在楼层 F ，满足 0 &amp;lt;= F &amp;lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。&lt;/p&gt;
&lt;p&gt;每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &amp;lt;= X &amp;lt;= N）。&lt;/p&gt;
&lt;p&gt;你的目标是确切地知道 F 的值是多少。&lt;/p&gt;
&lt;p&gt;无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/super-egg-drop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分搜索" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的状态与主要转换方法</title>
    <link href="http://yoursite.com/2020/04/10/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/10/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-10T06:32:34.000Z</published>
    <updated>2020-04-11T06:51:08.005Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="操作系统中的线程状态转换"><a href="#操作系统中的线程状态转换" class="headerlink" title="操作系统中的线程状态转换"></a>操作系统中的线程状态转换</h2><p>在现代操作系统中，线程被视为轻量级进程，所以操作系统中线程的状态其实是和操作系统中进程的状态是一致的。</p><p><img src="https://f1bu920.github.io/images/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="操作系统中线程状态转换.png"></p><p>操作系统中线程主要有三个状态：</p><ul><li>就绪状态(ready)：线程正在等待使用CPU，等分配到CPU时间片就可以进入running状态。</li><li>执行状态(running)：线程正在使用CPU。</li><li>等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源，如 I/O等。</li></ul><a id="more"></a><h2 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a>Java线程的6个状态</h2><p>Java中有一个枚举类，代表了Java线程的6个状态，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        WAITING,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a><code>NEW</code></h4><p>处于<code>NEW</code>状态的线程尚未启动，即未调用<code>Thread</code>类的<code>start</code>方法。</p><p><code>start</code>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>start()</code>方法的内部有一个<code>threadStatus</code>变量，如果它不为0，会直接抛出异常。</p><p>在第一次调用<code>start()</code>方法后，<code>threadStatus</code>变量会从0变为其他值，若第二次调用<code>start()</code>方法就会抛出<code>IllegalThreadStateException</code>异常。</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a><code>RUNNABLE</code></h4><p><code>RUNNABLE</code>表示当前线程正在运行中。<code>RUNNABLE</code>状态的线程运行在虚拟机中，也有可能在等待操作系统的其他资源。<strong>Java中<code>RUNNABLE</code>状态其实包括了操作系统线程的<code>ready</code>和<code>waiting</code>两个状态。</strong></p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a><code>BLOCKED</code></h4><p>阻塞状态。处于<code>BLOCKED</code>状态的线程正等待锁的释放以进入同步区。</p><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a><code>WAITING</code></h4><p>等待状态。处于等待状态的线程要想变为<code>RUNNABLE</code>状态需要其他线程唤醒。</p><p>调用下面三个方法会使线程进入<code>WAITING</code>状态：</p><ul><li><code>Object wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它。</li><li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是<code>Object</code>实例的<code>wait</code>方法。</li><li><code>LockSupport.park()</code>：除非获得调用许可，否则禁止当前线程进行线程调度。</li></ul><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a><code>TIMED_WAITING</code></h4><p>超时等待状态。线程等待一个具体的时间，时间到后自动唤醒。</p><p>调用下面方法会使线程进入超时等待状态：</p><ul><li><code>Tread.sleep(long millis)</code>：使当前线程睡眠指定时间</li><li><code>Object wait(long millis)</code>：线程休眠指定时间，等待期间可以通过<code>notify()</code>方法唤醒。</li><li><code>Thread.join(long millis)</code>：等待当前线程最多执行millis毫秒，如果<code>millis</code>为0，则会一直执行。</li><li><code>LockSupport.parkNanos(long nanos)</code>：除非获得调用许可，否则禁用当前线程进行线程调度指定时间。</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间。</li></ul><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a><code>TERMINATED</code></h4><p>终止状态，线程执行完毕。</p><h2 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h2><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="线程状态的转换"></p><h4 id="BLOCKED与RUNNABLE状态的转换"><a href="#BLOCKED与RUNNABLE状态的转换" class="headerlink" title="BLOCKED与RUNNABLE状态的转换"></a><code>BLOCKED</code>与<code>RUNNABLE</code>状态的转换</h4><p>处于<code>BLOCKED</code>状态的线程是因为在等待锁的释放。当线程获取到锁之后就会进入<code>RUNNABLE</code>状态。</p><h4 id="WAITING状态与RUNNABLE状态的转换"><a href="#WAITING状态与RUNNABLE状态的转换" class="headerlink" title="WAITING状态与RUNNABLE状态的转换"></a><code>WAITING</code>状态与<code>RUNNABLE</code>状态的转换</h4><p>将线程从<code>RUNNABLE</code>状态转换为<code>WAITING</code>状态主要有2种方法。</p><ul><li><p><code>Object.wait()</code></p><p>调用<code>wait()</code>方法前线程必须持有对象的锁，<strong>调用<code>wait()</code>方法后，会释放当前的锁，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>唤醒等待锁的线程</strong>。</p></li><li><p><code>Thread.join()</code></p><p><strong>调用<code>join()</code>方法不会释放锁，会一直等待当前线程执行完毕(转换为<code>TERMINTED</code>状态)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> ThreadTest().testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> ThreadTest().testMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        a.join();</span><br><span class="line">        b.start();</span><br><span class="line">        System.out.println(a.getName() + <span class="string">": "</span> + a.getState());</span><br><span class="line">        System.out.println(b.getName() + <span class="string">": "</span> + b.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">Thread-<span class="number">0</span>: TERMINATED</span><br><span class="line">Thread-<span class="number">1</span>: TIMED_WAITING</span><br></pre></td></tr></table></figure><p>要是没有调用<code>join()</code>方法，<code>main</code>线程不管<code>a</code>线程是否执行完毕都会往下执行，但<code>a</code>线程启动后立刻调用了<code>join()</code>方法，这里<code>main</code>线程就会等待直到<code>a</code>执行完毕(转换为<code>TERMINTED</code>状态)。</p><p>所以<code>a</code>会打印的状态为<code>TERMINATED</code>，而<code>b</code>线程可能为<code>TIMED_WAITING</code>状态(已进入同步方法)也可能为<code>RUNNABLE</code>状态(未进入同步方法)。</p></li></ul><h4 id="TIMED-WAITING与RUNNABLE状态的转换"><a href="#TIMED-WAITING与RUNNABLE状态的转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态的转换"></a><code>TIMED_WAITING</code>与<code>RUNNABLE</code>状态的转换</h4><p><code>TIMED_WAITING</code>与<code>WAITING</code>状态类似，只是<code>TIMED_WAITING</code>等待时间是指定的。</p><ul><li><p><code>Thread.sleep(long)</code></p><p>使当前线程睡眠指定时间。<strong>这里的睡眠指的是暂停执行，并不会释放锁</strong>。时间到后，会自动进入<code>RUNNABLE</code>状态。</p></li><li><p><code>Object.wait(long)</code></p><p>使线程进入<code>TIMED_WAITING</code>状态，<strong>会释放锁</strong>。经过指定时间后，自动唤醒，拥有去争夺锁的资格。</p></li><li><p><code>Thread.join(long)</code></p><p>使当前线程执行指定时间，并且使线程进入<code>TIMED_WAITING</code>状态。</p></li></ul><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>当线程启动后不需要它继续执行下去的时候，需要线程中断机制。线程中断机制是一种协作机制，<strong>通过中断操作并不能直接终止一个线程，而是通知需要中断的线程自行处理。</strong></p><ul><li><p><code>Thread.interrupt()</code></p><p>中断线程。并不会立即停止线程，而是设置线程的中断状态为<code>true</code>，默认为<code>false</code>。</p></li><li><p><code>Thread.interrupted()</code></p><p>测试当前线程是否被中断。调用一次这个方法会使中断状态设置为<code>true</code>，调用两次中断状态重新转变为<code>false</code>。</p></li><li><p><code>Thread.isInterrupted()</code></p><p>测试当前线程状态是否被中断，与上面方法不同的是不会影响线程的中断状态。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;操作系统中的线程状态转换&quot;&gt;&lt;a href=&quot;#操作系统中的线程状态转换&quot; class=&quot;headerlink&quot; title=&quot;操作系统中的线程状态转换&quot;&gt;&lt;/a&gt;操作系统中的线程状态转换&lt;/h2&gt;&lt;p&gt;在现代操作系统中，线程被视为轻量级进程，所以操作系统中线程的状态其实是和操作系统中进程的状态是一致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png&quot; alt=&quot;操作系统中线程状态转换.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;操作系统中线程主要有三个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态(ready)：线程正在等待使用CPU，等分配到CPU时间片就可以进入running状态。&lt;/li&gt;
&lt;li&gt;执行状态(running)：线程正在使用CPU。&lt;/li&gt;
&lt;li&gt;等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源，如 I/O等。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode72.编辑距离</title>
    <link href="http://yoursite.com/2020/04/10/Leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2020/04/10/Leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-10T05:43:54.000Z</published>
    <updated>2020-04-10T06:16:14.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode72-编辑距离"><a href="#Leetcode72-编辑距离" class="headerlink" title="Leetcode72.编辑距离"></a>Leetcode72.编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></blockquote><p>示例 2：</p><blockquote><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>运用动态规划的思想，令<code>dp[i][j]</code>代表输入单词长度为<code>i</code>和<code>j</code>的编辑距离。当我们获得<code>dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1]</code>的值后就可以计算出<code>dp[i][j]</code>。</p><p><code>dp[i][j]</code>代表<code>word1</code>中<code>[0,i)</code>位置转换成<code>word2</code>中<code>[0,j)</code>位置所需的最小编辑距离。所以当<code>word1[i-1]=word2[j-1]</code>时，<code>dp[i][j] = dp[i-1][j-1]</code>。</p><p>如果不等<code>word1[i-1] =word2[j-1]</code>，我们要从三种变换方法中找到最小的一种。</p><ul><li><p>插入</p><p>对于插入操作，我们是在原有的基础上<code>dp[i][j-1]</code>增加一个操作，因为我们插入时是在<code>word1</code>的<code>i</code>的后面插入<code>word2[j-1]</code>，所以状态转移方程为<code>dp[i][j] = dp[i][j-1]+1</code>。</p></li><li><p>删除</p><p>对于删除操作，我们是在原有基础上<code>dp[i-1][j]</code>上面加一，所以状态转移方程为<code>dp[i][j] = dp[i-1][j]+1</code>.</p></li><li><p>替换</p><p>对于替换操作，我们是在<code>dp[i-1][j-1]</code>上加一，所以状态转移方程为<code>dp[i][j] = dp[i-1][j-1]+1</code>.</p></li></ul><p>初始化：很明显<code>dp[0][j] = j</code>、<code>dp[i][0] = 1</code>。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = word1.length();</span><br><span class="line">        <span class="keyword">int</span> col = word2.length();</span><br><span class="line">        <span class="comment">//有一个为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (row * col == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> row + col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i][j]的意义是word1[0,i)变为word2[0,j)所需的最小编辑距离</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//替换</span></span><br><span class="line">                <span class="keyword">int</span> replace = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                <span class="keyword">int</span> delete = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入</span></span><br><span class="line">                <span class="keyword">int</span> insert = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    replace += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(replace, Math.min(delete, insert));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode72-编辑距离&quot;&gt;&lt;a href=&quot;#Leetcode72-编辑距离&quot; class=&quot;headerlink&quot; title=&quot;Leetcode72.编辑距离&quot;&gt;&lt;/a&gt;Leetcode72.编辑距离&lt;/h2&gt;&lt;p&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;p&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode151.翻转字符串里的单词</title>
    <link href="http://yoursite.com/2020/04/10/Leetcode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/04/10/Leetcode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2020-04-10T02:40:22.000Z</published>
    <updated>2020-04-10T02:50:38.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode151-翻转字符串里的单词"><a href="#Leetcode151-翻转字符串里的单词" class="headerlink" title="Leetcode151.翻转字符串里的单词"></a>Leetcode151.翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p> <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p></blockquote><p>示例 2：</p><blockquote><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></blockquote><p>示例 3：</p><blockquote><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p>说明：</p><blockquote><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用双指针除去空格、找到单词，再将单词添加到<code>list</code>集合中。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = s.trim();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != <span class="string">' '</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str.substring(i, j));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sb.append(list.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode151-翻转字符串里的单词&quot;&gt;&lt;a href=&quot;#Leetcode151-翻转字符串里的单词&quot; class=&quot;headerlink&quot; title=&quot;Leetcode151.翻转字符串里的单词&quot;&gt;&lt;/a&gt;Leetcode151.翻转字符串里的单词&lt;/h2&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程组和线程优先级</title>
    <link href="http://yoursite.com/2020/04/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/04/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2020-04-09T08:03:05.000Z</published>
    <updated>2020-04-09T08:35:47.647Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="线程组与线程优先级"><a href="#线程组与线程优先级" class="headerlink" title="线程组与线程优先级"></a>线程组与线程优先级</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用<code>ThreadGoup</code>来表示线程组，我们可以使用线程组对线程进行批量控制。</p><p>每个<code>Thread</code>必然存在于一个<code>ThreadGroup</code>中，<code>Thread</code>不能独立于<code>ThreadGroup</code>存在。执行<code>main()</code>方法的主线程所在的线程组名字为”main”，如果我们<code>new Thread()</code>时不指定线程组，那么默认将父线程 (当前执行<code>new Thread</code>) 的线程组设为自己的线程组。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前线程组名称: "</span> + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">            System.out.println(<span class="string">"当前线程名称: "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">"main方法所在线程的线程组名称： "</span> + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%93%E6%9E%9C1.png" alt="结果"></p><a id="more"></a><p><code>ThreadGroup</code>管理着它下面的<code>Thread</code>，<code>ThreadGroup</code>是一个标准的向下引用的树状结构，这样是为了<strong>防止“上级”线程被“下级线程”引用而无法有效地被GC回收。</strong></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>Java中我们可以指定线程的优先级，从1~10。但在操作系统中并不是按1到10划分线程优先级，比如有些操作系统只支持三级划分：低、中、高。线程最终的优先级由操作系统决定。</p><p>Java默认的线程优先级为5，线程的执行顺序由调度程序确定，通常情况下，高优先级的线程会比低优先级的线程有更高的几率被运行。可以通过<code>Thread</code>类的<code>setPriority()</code>方法设定线程优先级。</p><p><strong>注：Java中的线程优先级只是给操作系统一个建议，并不是一定会按照这个优先级执行，真正的调用顺序由操作系统的线程调度算法决定。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;线程组与线程优先级&quot;&gt;&lt;a href=&quot;#线程组与线程优先级&quot; class=&quot;headerlink&quot; title=&quot;线程组与线程优先级&quot;&gt;&lt;/a&gt;线程组与线程优先级&lt;/h1&gt;&lt;h2 id=&quot;线程组&quot;&gt;&lt;a href=&quot;#线程组&quot; class=&quot;headerlink&quot; title=&quot;线程组&quot;&gt;&lt;/a&gt;线程组&lt;/h2&gt;&lt;p&gt;Java使用&lt;code&gt;ThreadGoup&lt;/code&gt;来表示线程组，我们可以使用线程组对线程进行批量控制。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Thread&lt;/code&gt;必然存在于一个&lt;code&gt;ThreadGroup&lt;/code&gt;中，&lt;code&gt;Thread&lt;/code&gt;不能独立于&lt;code&gt;ThreadGroup&lt;/code&gt;存在。执行&lt;code&gt;main()&lt;/code&gt;方法的主线程所在的线程组名字为”main”，如果我们&lt;code&gt;new Thread()&lt;/code&gt;时不指定线程组，那么默认将父线程 (当前执行&lt;code&gt;new Thread&lt;/code&gt;) 的线程组设为自己的线程组。举例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;当前线程组名称: &quot;&lt;/span&gt; + Thread.currentThread().getThreadGroup().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;当前线程名称: &quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;main方法所在线程的线程组名称： &quot;&lt;/span&gt; + Thread.currentThread().getThreadGroup().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://f1bu920.github.io/images/%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%93%E6%9E%9C1.png&quot; alt=&quot;结果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题01.07.翻转矩阵</title>
    <link href="http://yoursite.com/2020/04/09/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801.07-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/04/09/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9801.07-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-09T02:43:17.000Z</published>
    <updated>2020-04-09T03:01:46.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题01-07-旋转矩阵"><a href="#Leetcode面试题01-07-旋转矩阵" class="headerlink" title="Leetcode面试题01.07.旋转矩阵"></a>Leetcode面试题01.07.旋转矩阵</h2><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p> <a href="https://leetcode-cn.com/problems/rotate-matrix-lcci" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>给定 matrix =<br>[<br> [1,2,3],<br> [4,5,6],<br> [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br> [7,4,1],<br> [8,5,2],<br> [9,6,3]<br>]</p></blockquote><p>示例 2:</p><blockquote><p>给定 matrix =<br>[<br> [ 5, 1, 9,11],<br> [ 2, 4, 8,10],<br> [13, 3, 6, 7],<br> [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br> [15,13, 2, 5],<br> [14, 3, 4, 1],<br> [12, 6, 8, 9],<br> [16, 7,10,11]<br>]</p></blockquote><h4 id="思路及代码实现"><a href="#思路及代码实现" class="headerlink" title="思路及代码实现"></a>思路及代码实现</h4><ul><li><p>借助辅助数组</p><blockquote><p>对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。 </p></blockquote><p>我们将其翻译成代码。由于矩阵中的行列从 00 开始计数，因此对于矩阵中的元素 <code>temp[i][j]</code>，旋转后他的新位置为<code>matrix[j][N-i-1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] temps = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                temps[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                matrix[j][N - i - <span class="number">1</span>] = temps[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>用翻转代替旋转</p><blockquote><p>5  1  9 11<br>2  4  8 10<br>13  3  6  7<br>15 14 12 16</p></blockquote><p>作为例子，先将其通过水平轴翻转得到：</p><blockquote><p>5  1  9 11                 15 14 12 16<br>2  4  8 10                 13  3  6  7<br>————   =水平翻转=&gt;   ————<br>13  3  6  7                  2  4  8 10<br>15 14 12 16                  5  1  9 11</p></blockquote><p>再根据主对角线 \ 翻转得到：</p><blockquote><p>15 14 12 16                           15 13  2  5<br>13  3  6  7   =主对角线翻转=&gt;       14  3  4  1<br>2  4  8 10                               12  6  8  9<br>5  1  9 11                               16  7 10 11</p></blockquote><p>对于水平翻转，我们只需要枚举上半部分元素与下半部分元素进行交换。</p><p><code>matrix[row][col] = matrix[N-row-1][col]</code></p><p>对于主对角线翻转，只需要枚举对角线左侧元素与右侧进行交换。</p><p><code>matrix[row][col] = matrix[col][row]</code>.</p><p>代码实现略。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题01-07-旋转矩阵&quot;&gt;&lt;a href=&quot;#Leetcode面试题01-07-旋转矩阵&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题01.07.旋转矩阵&quot;&gt;&lt;/a&gt;Leetcode面试题01.07.旋转矩阵&lt;/h2&gt;&lt;p&gt;给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;/p&gt;
&lt;p&gt;不占用额外内存空间能否做到？&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/rotate-matrix-lcci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode22括号生成</title>
    <link href="http://yoursite.com/2020/04/09/Leetcode22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2020/04/09/Leetcode22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2020-04-09T01:47:50.000Z</published>
    <updated>2020-04-09T02:05:30.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode22-括号生成"><a href="#Leetcode22-括号生成" class="headerlink" title="Leetcode22.括号生成"></a>Leetcode22.括号生成</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><p><a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>深度优先遍历，采用递归的形式，所以可以使用系统栈，不需要自己定义栈。</p><p><img src="https://f1bu920.github.io/images/LeetCode22%E6%8B%AC%E5%8F%B7%E7%94%9F%E5%87%BA%E9%A2%98%E8%A7%A3%E9%85%8D%E5%9B%BE.png" alt="题解配图"></p><p>如上图所示：</p><ol><li>左括号数大于右括号数时，需要剪枝，此情况一定不合法</li><li>左括号数和右括号数都为0时，添加到结果集中</li><li><code>left&gt;0</code>时，递归调用；<code>right&gt;0</code>时递归。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String str = <span class="keyword">new</span> String();</span><br><span class="line">        dfs(str, n, n);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左括号数大于右括号数时减枝</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入结果集中</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(sb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb + <span class="string">'('</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(sb + <span class="string">')'</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode22-括号生成&quot;&gt;&lt;a href=&quot;#Leetcode22-括号生成&quot; class=&quot;headerlink&quot; title=&quot;Leetcode22.括号生成&quot;&gt;&lt;/a&gt;Leetcode22.括号生成&lt;/h2&gt;&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 n = 3，生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="深度优先遍历" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode面试题13.机器人的运动范围</title>
    <link href="http://yoursite.com/2020/04/08/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/04/08/Leetcode%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2020-04-08T06:28:09.000Z</published>
    <updated>2020-04-08T06:46:58.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode面试题13-机器人的运动范围"><a href="#Leetcode面试题13-机器人的运动范围" class="headerlink" title="Leetcode面试题13.机器人的运动范围"></a>Leetcode面试题13.机器人的运动范围</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p> <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1：</p><blockquote><p>输入：m = 2, n = 3, k = 1<br>输出：3</p></blockquote><p>示例 1：</p><blockquote><p>输入：m = 3, n = 1, k = 0<br>输出：1</p></blockquote><p>提示：</p><blockquote><p>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>看完题目很明显要用广度优先搜索，题目中要用到行坐标和列坐标之和，所以我们利用一个辅助函数<code>help</code>求行坐标和列坐标，注意边界条件和防止死循环即可。</p><p><strong>注意：这题也是表格类题，可能会将二维坐标转化为一维，但此题不可。因为将二维坐标转化为一维的前提是列数小于等于行数，即<code>temp = x * m + y; x = temp / m; y = temp % m;</code>,当<code>y&gt;m</code>时，<code>temp / m</code>就会大于<code>x</code>了。这也是我写的时候出错的地方！</strong>所以，我们有一对二维坐标需要存储，但因为Java中没有提供<code>Pair</code>类的数据结构，我们可以自己定义，但简单起见，我这里定义了两个队列，分别存放横坐标与纵坐标。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                table[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上、下、左、右四个方向向量</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue1.add(<span class="number">0</span>);</span><br><span class="line">        queue2.add(<span class="number">0</span>);</span><br><span class="line">        table[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queue1.poll();</span><br><span class="line">            <span class="keyword">int</span> y = queue2.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + direction[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = y + direction[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; help(newX) + help(newY) &lt;= k &amp;&amp; table[newX][newY] != <span class="number">2</span>) &#123;</span><br><span class="line">                    queue1.add(newX);</span><br><span class="line">                    queue2.add(newY);</span><br><span class="line">                    table[newX][newY] = <span class="number">2</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己定义的求横、纵坐标的辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode面试题13-机器人的运动范围&quot;&gt;&lt;a href=&quot;#Leetcode面试题13-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;Leetcode面试题13.机器人的运动范围&quot;&gt;&lt;/a&gt;Leetcode面试题13.机器人的运动范围&lt;/h2&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="广度优先遍历" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码学习</title>
    <link href="http://yoursite.com/2020/04/07/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/04/07/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-07T03:39:59.000Z</published>
    <updated>2020-04-08T09:35:40.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码学习"><a href="#HashMap源码学习" class="headerlink" title="HashMap源码学习"></a>HashMap源码学习</h1><h3 id="HashMap集合简介"><a href="#HashMap集合简介" class="headerlink" title="HashMap集合简介"></a>HashMap集合简介</h3><p><code>HashMap</code>的类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><code>HashMap</code>继承自<code>AbstractMap</code>抽象类，实现了<code>Map</code>接口、<code>Cloneable</code>接口和<code>Serializable</code>接口。</p><p><code>HashMap</code>是基于哈希表的<code>Map</code>接口实现，是以<code>key-value</code>存储形式存在，主要用来存储键值对。<code>HashMap</code>的实现不是同步的，即意味着不是线程安全的。<code>HashMap</code>的键、值都可以为<code>null</code>。此外，<code>HashMap</code>的映射不是有序的。</p><p>  JDK1.8以前，<code>HashMap</code>由数组+链表组成，数组是<code>HashMap</code>的主体，链表则是为了解决哈希冲突(<strong>两个对象调用的<code>hashCode()</code>方法计算得到的哈希值一致导致计算的数组索引相同</strong>)，(<strong>使用“拉链法”解决冲突</strong>)。</p><p>JDK1.8以后解决哈希冲突时发生了较大变化。<strong>当链表长度大于阈值(或者红黑树边界值，默认为8)并且当前数组长度大于64时，此时此索引上的所有数据采用红黑树存储。</strong></p><a id="more"></a><p>补充：将链表转为红黑树时会进行判断，当链表长度大于阈值但数组长度小于64时，并不会转化为红黑树，而是对数组进行扩容。这样做的目的是因为数组较小，尽量避开红黑树结构，强行转化为红黑树反而会降低效率。，因为红黑树需要进行左旋、右旋、变色等操作来保持平衡。具体参考<code>treeifyBin()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//判断数组长度小于64时采用扩容</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>存取无序</li><li>键和值都可以为<code>null</code>，但键位置只能有一个<code>null</code></li><li>键位置是惟一的，底层的数据结构控制键的</li><li><strong>jdk1.8以前数据结构是数组+链表，1.8之后是数组+链表+红黑树</strong></li><li><strong>阈值大于8且数组长度大于64时，才会将链表转换为红黑树</strong></li></ol><h3 id="HashMap集合底层数据结构"><a href="#HashMap集合底层数据结构" class="headerlink" title="HashMap集合底层数据结构"></a>HashMap集合底层数据结构</h3><p><code>HashMap</code>底层数据结构：<strong>jdk1.8以前数据结构是数组+链表，1.8之后是数组+链表+红黑树</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>在jdk1.8之前，上面这行代码会直接创建一个默认长度为16，类型为<code>Map.Entry</code>的数组<code>table[]</code>；</p><p>而在<strong>jdk1.8之后，是在第一次调用<code>put</code>方法时才会创建数组<code>Node[] table</code>，这与<code>ArrayList</code>不指定初始容量时一致</strong>。</p><p><strong><code>HashMap</code>通过<code>key</code>的<code>hashCode</code>经过扰动函数处理过后得到<code>hash</code>值，然后通过<code>(n-1)&amp;hash</code>计算当前元素存放位置(n指数组长度)，如果当前位置存在元素，就比较已存在元素和要存放元素的<code>key</code>的<code>hash</code>值是否一致，如果不一致，就采用拉链法解决冲突，如果一致，就会发生哈希碰撞，然后会调用<code>key</code>所属类的<code>equals()</code>方法，如果相等，直接覆盖，如果不相等，遍历链表，直到找到相等的，否则采用拉链法新建一个节点存储数据。</strong></p><p>注：不同<code>key</code>的<code>hashCode()</code>方法得到的值可能会相等。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"重地"</span>.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"通话"</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为：</span></span><br><span class="line"><span class="comment">//1179395</span></span><br><span class="line"><span class="comment">//1179395</span></span><br></pre></td></tr></table></figure><p>注：<strong>从上述过程可以看出，一个类中<code>hashCode()</code>和<code>equals()</code>方法一定要一致。</strong></p><p>这里扰动函数就是<code>HashMap</code>的<code>hash()</code>方法，使用<code>hash</code>方法就是为了防止一些实现比较差的<code>hashCode()</code>方法从而减少碰撞。</p><h3 id="HashMap集合类的成员"><a href="#HashMap集合类的成员" class="headerlink" title="HashMap集合类的成员"></a>HashMap集合类的成员</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>实现了<code>Serializable</code>接口。</p></li><li><p>集合的初始化容量(<strong>必须为2的n次幂</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>默认的初始化容量必须为2的n次幂，是<strong>为了让<code>HashMap</code>存取高效，尽量减少碰撞，也就是尽量把数据分配均匀。</strong></p><p><strong>根据<code>key</code>计算得到的<code>hash</code>值数值很大，不能当成内存地址，将其转化为数组下标的计算方法为<code>(n-1)&amp;hash</code>。所以<code>HashMap</code>的长度必须为2的n次幂。</strong></p><p><strong>因为取余操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作，即<code>hash%length == hash&amp;(length-1)</code>的前提是<code>length</code>是2的n次幂。而计算机中采用二进制操作&amp;效率远远大于%，所以<code>HashMap</code>的长度必须为2的n次幂。</strong></p><p><strong>如果我们传入的初始容量<code>initCapacity</code>不为2的n次幂，<code>HashMap</code>会自动将容量扩为比<code>initCapacity</code>大的最近的2的n次幂</strong>。这个过程是通过调用<code>tableSizeFor(initCapacity)</code>方法实现的。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为了防止传入的容量恰好为2的n次幂，所以减1</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认的负载因子, 默认值为0.75</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>当元素个数达到数组长度*负载因子时，就会扩容。例：当长度为16的数组中有12个元素时，就会触发扩容。</p></li><li><p>集合最大容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>当链表元素个数超过8就会转为红黑树(1.8新增)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> *当桶(bucket)上结点数大于这个值时才会转为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><em>为什么是8？</em></p><blockquote><p>红黑树的节点占用空间比链表节点大，所以我们只在包含足够的节点时 (链表长度大于8)才使用树节点。当他们变得太小时 (链表长度小于6) 就会变成普通节点。根据统计学中的泊松分布，长度为8时概率很小，所以这是为了权衡时间与空间！</p></blockquote></li><li><p><strong>当链表元素小于6就会从红黑树转为普通链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>桶中结构转化为红黑树对应的数组长度最小值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>存储元素的数组table</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>jdk1.8之前<code>table</code>是<code>Map.Entry</code>类型，1.8之后为<code>Node</code>类型。</p></li><li><p>用于存放缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 存放具体元素的集合</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure></li><li><p><strong>HashMap中存放元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></li><li><p>用来记录HashMap的修改次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure></li><li><p>用来调整大小下一个容量的计算方式为(容量*负载因子)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界值 当实际大小超过临界值(容量*负载因子)时，会扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><strong>是衡量数组容量是否需要扩容的标准</strong>。扩容容量是原来的2倍。</p></li><li><p><strong>哈希表的加载因子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ol><li><p><code>loadFactor</code>用来衡量<code>HashMap</code>满的程度，<strong>表示<code>HashMap</code>疏密程度，影响<code>hash</code>操作到同一数组位置的概率</strong>，计算<code>HashMap</code>的实时加载因子的方法为<code>size / capacity</code>，而不是占用桶的数量除以<code>capacity</code>。<code>capacity</code>是桶的数量，也就是数组长度。</p><p><strong><code>loadFactor</code>太大会导致元素查找效率低，太小会导致数组空间浪费。默认值0.75f是较好的临界值。</strong></p><p><strong>当<code>HashMap</code>中容纳的元素达到数组长度的75%时，表示<code>HashMap</code>已经太挤了，需要扩容，而扩容涉及到<code>rehash</code>、复制数据等非常消耗性能的操作，所以要尽可能的减少扩容次数，可以通过指定初始容量来尽量避免。同时也可以指定<code>loadFactor</code>。</strong></p><p>构造一个指定初始容量和加载因子的空<code>HashMap</code>。</p></li></ol></li></ol><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>构造一个空的<code>HashMap</code>，默认初始容量为16，默认加载因子为0.75f</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造一个指定初始容量和默认加载因子的空<code>HashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽量使用这个构造方法，为了减少扩容。指定的初始容量必须为2的n次幂，如果不为，会调用<code>tableSizeFor</code>方法，使初始容量变为比指定值大的最小2的n次幂。</p></li></ul><ul><li><p>构造一个指定初始容量和负载因子的空<code>HashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包含另一个“Map”的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//构造一个映射关系与指定“Map”相同的 HashMap</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后调用了<code>putMapEntries</code>方法，我们来看一下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment"> * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//这里+1是为了防止扩容的发生，使容量尽量大点，更大的容量会减少resize调用的次数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>​     </p><p>​       </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashMap源码学习&quot;&gt;&lt;a href=&quot;#HashMap源码学习&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码学习&quot;&gt;&lt;/a&gt;HashMap源码学习&lt;/h1&gt;&lt;h3 id=&quot;HashMap集合简介&quot;&gt;&lt;a href=&quot;#HashMap集合简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap集合简介&quot;&gt;&lt;/a&gt;HashMap集合简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;的类定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Map&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;继承自&lt;code&gt;AbstractMap&lt;/code&gt;抽象类，实现了&lt;code&gt;Map&lt;/code&gt;接口、&lt;code&gt;Cloneable&lt;/code&gt;接口和&lt;code&gt;Serializable&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;是基于哈希表的&lt;code&gt;Map&lt;/code&gt;接口实现，是以&lt;code&gt;key-value&lt;/code&gt;存储形式存在，主要用来存储键值对。&lt;code&gt;HashMap&lt;/code&gt;的实现不是同步的，即意味着不是线程安全的。&lt;code&gt;HashMap&lt;/code&gt;的键、值都可以为&lt;code&gt;null&lt;/code&gt;。此外，&lt;code&gt;HashMap&lt;/code&gt;的映射不是有序的。&lt;/p&gt;
&lt;p&gt;  JDK1.8以前，&lt;code&gt;HashMap&lt;/code&gt;由数组+链表组成，数组是&lt;code&gt;HashMap&lt;/code&gt;的主体，链表则是为了解决哈希冲突(&lt;strong&gt;两个对象调用的&lt;code&gt;hashCode()&lt;/code&gt;方法计算得到的哈希值一致导致计算的数组索引相同&lt;/strong&gt;)，(&lt;strong&gt;使用“拉链法”解决冲突&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;JDK1.8以后解决哈希冲突时发生了较大变化。&lt;strong&gt;当链表长度大于阈值(或者红黑树边界值，默认为8)并且当前数组长度大于64时，此时此索引上的所有数据采用红黑树存储。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码学习" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程入门类与接口</title>
    <link href="http://yoursite.com/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-06T03:38:24.000Z</published>
    <updated>2020-04-09T08:42:48.877Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Java入门类和接口"><a href="#Java入门类和接口" class="headerlink" title="Java入门类和接口"></a>Java入门类和接口</h1><h2 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a><code>Thread</code>类和<code>Runnable</code>接口</h2><p>Java中，JDK提供了<code>Thread</code>类和<code>Runnable</code>接口，我们有两种方法来实现自己的线程类。</p><ul><li>继承<code>Thread</code>类，并重写<code>run</code>方法。</li><li>实现<code>Runnable</code>接口的<code>run</code>方法。</li></ul><a id="more"></a><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承<code>Thread</code>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是线程： "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一定要调用<code>start()</code>方法该线程才算启动。</strong></p><p><strong><code>new</code>一个<code>Thread</code>，线程进入新建状态；调用<code>start()</code>方法会启动一个线程并使线程进入就绪状态，当分配到CPU时间片就可以运行了。<code>start()</code>方法会执行线程的相应准备工作，然后自动执行<code>run()</code>方法的内容，这才是真正的多线程。而直接调用<code>run()</code>方法，会把<code>run()</code>方法当成一个<code>main</code>线程下的普通方法去执行，还是在主线程中。</strong></p><p>多次调用<code>start()</code>方法会抛出<code>java.lang.IllegalThreadStateException</code>异常。</p><h4 id="实现Runnable-接口"><a href="#实现Runnable-接口" class="headerlink" title="实现Runnable()接口"></a>实现<code>Runnable()</code>接口</h4><p><code>Runnable()</code>接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Runnable</code>接口是一个函数式接口，这代表着可以使用函数式编程简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是线程： "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不采用<code>lambda</code>要这样用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"runnable "</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> thread1()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread类构造器"><a href="#Thread类构造器" class="headerlink" title="Thread类构造器"></a><code>Thread</code>类构造器</h4><p><code>Thread</code>类是<code>Runnable</code>接口的实现类，其构造方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, null, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, target, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  target</span></span><br><span class="line"><span class="comment"> *         the object whose &#123;<span class="doctag">@code</span> run&#125; method is invoked when this thread</span></span><br><span class="line"><span class="comment"> *         is started. If &#123;<span class="doctag">@code</span> null&#125;, this classes &#123;<span class="doctag">@code</span> run&#125; method does</span></span><br><span class="line"><span class="comment"> *         nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, target, name)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  target</span></span><br><span class="line"><span class="comment"> *         the object whose &#123;<span class="doctag">@code</span> run&#125; method is invoked when this thread</span></span><br><span class="line"><span class="comment"> *         is started. If &#123;<span class="doctag">@code</span> null&#125;, this thread's run method is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         the name of the new thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Thread</code>类的构造器会调用私有的<code>init()</code>方法来实现初始化。<code>init</code>方法的方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span></span></span><br></pre></td></tr></table></figure><p><code>init</code>方法参数的解释：</p><ul><li><code>g</code>：线程组，制定这个线程在哪个线程组下</li><li><code>target</code>：指定要执行的任务；</li><li><code>name</code>：线程的名字，多个线程的名字是可以重复的。如果不指定名字，会默认指定为<code>&quot;Thread-&quot; + nextThreadNum()</code>。</li><li><code>acc</code>：用于初始化私有变量<code>inheritedAccessControlContext</code>。</li><li><code>inheritThreadLocals</code>：可继承的<code>ThreadLocal</code>，<code>Thread</code>类中有两个私有属性来支持<code>ThreadLocal</code>。</li></ul><p>大多数情况下我们调用下面两种构造方法：</p><ul><li><code>Thread(Runnable target)</code></li><li><code>Thread(Runnable target, String name)</code></li></ul><h4 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a><code>Thread</code>类的常用方法</h4><ul><li><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用。</li><li><code>start()</code>：开始执行线程的方法，Java虚拟机会调用线程内的<code>run</code>方法。</li><li><code>yield()</code>：当前线程愿意让出对当前处理器的占用。要注意的是，就算当前线程调用了<code>yield()</code>方法，程序在调度的时候，也还有可能继续运行这个线程的。</li><li><code>sleep()</code>：静态方法，使当前线程睡眠指定时间。</li><li><code>join()</code>：使当前线程等待另一个线程执行完毕后再继续执行，内部调用的是<code>Object类</code>的<code>wait()</code>方法。</li></ul><h4 id="Thread类与Runnable接口的比较"><a href="#Thread类与Runnable接口的比较" class="headerlink" title="Thread类与Runnable接口的比较"></a><strong><code>Thread</code>类与<code>Runnable</code>接口的比较</strong></h4><p>实现一个自定义线程类，可以有继承<code>Thread</code>类和实现<code>Runnable</code>接口两种方法。</p><ul><li>由于Java单继承、多实现的特点，<code>Runnable</code>接口使用更加灵活；</li><li><code>Thread</code>类就是<code>Runnable</code>接口的实现；</li><li><code>Runnable</code>接口更加符合面对对象，将线程单独进行对象的封装；</li><li><code>Runnable</code>接口的出现，降低了线程对象与线程任务的耦合性；</li><li>如果不需要使用<code>Thread</code>类的其他方法，使用<code>Runnable</code>接口更加轻量</li></ul><p>综上，我们通常优先使用<code>Runnable</code>接口来自定义线程类。</p><h2 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a><code>Callable</code>、<code>Future</code>与<code>FutureTask</code></h2><p>通常我们使用<code>Runnable</code>和<code>Thread</code>来创建一个线程，但是<code>run</code>方法是没有返回值的。如果我们希望执行一个任务后返回一个值，我们可以使用JDK提供的<code>Callable</code>接口和<code>Future</code>类。这也是所谓的“异步”模型。</p><h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a><code>Callable</code>接口</h4><p><code>Callable</code>接口与<code>Runnable</code>接口类似，同样是一个函数式接口，不同的是<code>Callable</code>接口<strong>有返回值且支持泛型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Callable</code>接口一般是配合线程池工具<code>ExecutorSevice</code>来使用的。<code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行，它会返回一个<code>Future</code>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果</strong>。一个简单的demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//使用</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//传入一个Callable对象</span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(<span class="keyword">new</span> ThreadTest());</span><br><span class="line">        <span class="comment">//注意调用get方法会阻塞当前线程，直到得到结果</span></span><br><span class="line">        <span class="comment">//实际编码中建议使用可以设置超时时间的重载get方法</span></span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a><code>Future</code>接口</h4><p><code>Future</code>接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cancel</code>方法是试图取消一个线程的执行。<strong>注意是试图取消，不一定取消成功。</strong>因为任务可能已完成、已取消或者不可取消。最后返回是否取消成功。</p><p>参数<code>mayInterruptIfRunning</code>代表是否采用中断的方式取消线程执行。</p><p>所以有时候，为了让线程有能够取消的可能，就会使用<code>Callable</code>代替<code>Runnable</code>。若只是为了可取消性，而不需要结果，可以声明<code>Future&lt;?&gt;</code>形式类型，并返回<code>null</code>作为结果。</p><h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a><code>FutureTask</code>类</h4><p><code>Future</code>接口有一个实现类<code>FutureTask</code>，这个类实现了<code>RunnableFuture</code>接口，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。</p><p><code>RunnableFuture</code>接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>只是一个接口，里面的<code>cancel</code>、<code>get</code>、<code>isDone</code>等方法自己实现会很复杂，所以JDk提供了一个<code>FutureTask</code>类。使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> ThreadTest());</span><br><span class="line">        <span class="comment">//这里实际调用的是submit(Runnable task)方法</span></span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用<code>submit</code>方法是没有返回值的。这里实际上调用的是<code>submit(Runnable task)</code>方法，而上面那个demo中，调用的是<code>submit(Callable&lt;T&gt; task)</code>方法。</p><p>这里是使用<code>futureTask</code>直接<code>get</code>取值，而上面Demo中是使用返回的<code>Future</code>去取值。</p><p><strong>在高并发的情景下，有可能<code>Callable</code>和<code>FutureTask</code>会创建多次。<code>FutureTask</code>能确保在高并发下任务只被执行一次。</strong></p><h4 id="FutureTask的几个状态"><a href="#FutureTask的几个状态" class="headerlink" title="FutureTask的几个状态"></a><code>FutureTask</code>的几个状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *state可能的状态转变路径如下：</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><code>state</code>表示任务的运行状态。<strong>初始状态为<code>NEW</code>。运行状态只会在<code>set</code>、<code>setException</code>、<code>cancel</code>方法中终止。<code>COMPLETING</code>、<code>INTERRUPTING</code>是任务完成后的瞬时状态。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Java入门类和接口&quot;&gt;&lt;a href=&quot;#Java入门类和接口&quot; class=&quot;headerlink&quot; title=&quot;Java入门类和接口&quot;&gt;&lt;/a&gt;Java入门类和接口&lt;/h1&gt;&lt;h2 id=&quot;Thread类和Runnable接口&quot;&gt;&lt;a href=&quot;#Thread类和Runnable接口&quot; class=&quot;headerlink&quot; title=&quot;Thread类和Runnable接口&quot;&gt;&lt;/a&gt;&lt;code&gt;Thread&lt;/code&gt;类和&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/h2&gt;&lt;p&gt;Java中，JDK提供了&lt;code&gt;Thread&lt;/code&gt;类和&lt;code&gt;Runnable&lt;/code&gt;接口，我们有两种方法来实现自己的线程类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，并重写&lt;code&gt;run&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;Runnable&lt;/code&gt;接口的&lt;code&gt;run&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-进程与线程</title>
    <link href="http://yoursite.com/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-06T02:52:31.000Z</published>
    <updated>2020-04-09T08:08:29.044Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>进程</p><p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序，是系统运行程序的基本单位</strong>。</p><p>在Java中，当我们启动<code>main</code>函数时其实就是启动了一个<code>JVM</code>进程，而<code>main</code>函数所在的线程就是这个进程中的一个线程，叫做主线程。</p></li><li><p>线程</p><p>线程是一个比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。与进程不同的是<strong>同类的多个线程共享进程的堆和方法区，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈</strong>，所以系统在各个线程间切换工作时，负担会比进程小得多，因此线程也被称为轻量级进程。</p></li></ul><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>线程是一个比进程更小的执行单位，一个进程在其执行过程中可以产生多个线程。</p><p>进程是一个独立的运行环境，而线程是其中执行的一个任务，他们间本质的区别是<strong>是否单独占有内存地址以及其他系统资源(比如 I/O)</strong>。</p><ul><li>进程间存在内存隔离，数据是分开的，数据共享复杂但同步简单，各个进程间互不干扰；而线程共享进程占有的内存地址空间和资源，数据共享简单但同步复杂。</li><li>进程的创建和销毁开销较大，而线程的开销较小。</li><li>进程间通信比较复杂，线程间通信比较简单。</li><li><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位。</strong></li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换是指CPU从一个进程(或线程)切换到另一个进程(或线程)。上下文是指<strong>某一时间点CPU寄存器和程序计数器的内容</strong>。</p><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前执行一个时间片后会切换到下一个任务。</p><p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下文切换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode148.排序链表</title>
    <link href="http://yoursite.com/2020/04/03/Leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/03/Leetcode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-03T07:29:45.000Z</published>
    <updated>2020-04-03T07:38:26.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode148-排序链表"><a href="#Leetcode148-排序链表" class="headerlink" title="Leetcode148.排序链表"></a>Leetcode148.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><a href="https://leetcode-cn.com/problems/sort-list" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p>示例 2:</p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在<code>O(n logn)</code>时间复杂度和常数级空间复杂度下，所以我们可以使用归并排序。</p><p>归并排序有两种形式：递归与非递归，这里我使用的是递归写法。</p><ol><li>先用快慢指针找到链表的中点的前一个元素，在此基础上就相当于找到了两个子序列的头结点。</li><li>递归调用</li><li>归并</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//这里找的的是链表中间结点的前一个节点</span></span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode rightHead = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(rightHead);</span><br><span class="line">        <span class="keyword">return</span> mergeListNode(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeListNode</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = (l1 != <span class="keyword">null</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode148-排序链表&quot;&gt;&lt;a href=&quot;#Leetcode148-排序链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode148.排序链表&quot;&gt;&lt;/a&gt;Leetcode148.排序链表&lt;/h2&gt;&lt;p&gt;在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode8.字符串转整数(atoi)</title>
    <link href="http://yoursite.com/2020/04/03/Leetcode8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0-atoi/"/>
    <id>http://yoursite.com/2020/04/03/Leetcode8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0-atoi/</id>
    <published>2020-04-03T02:42:02.000Z</published>
    <updated>2020-04-03T02:55:56.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode8-字符串转整数-atoi"><a href="#Leetcode8-字符串转整数-atoi" class="headerlink" title="Leetcode8.字符串转整数(atoi)"></a>Leetcode8.字符串转整数(atoi)</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>提示：</p><blockquote><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><p>示例 1:</p><blockquote><p>输入: “42”<br>输出: 42</p></blockquote><p>示例 2:</p><blockquote><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>    我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 </p></blockquote><p>示例 3:</p><blockquote><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><p>示例 4:</p><blockquote><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>    因此无法执行有效的转换。</p></blockquote><p>示例 5:</p><blockquote><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>先处理首尾空格</p></li><li><p>再处理正负号</p></li><li><p>遍历字符串，直到遇到非数字字符</p></li><li><p><strong>字符串转整数时有可能会发生溢出，如<code>res*10+digit&gt;Integer.MAX_VALUE</code>，则移到右边即可，如<code>res&gt;(Integer.MAX_VALUE-digit)/10</code></strong>。</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.trim();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//符号位，默认为正号</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            start = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            start = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> digit = chars[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//注意要移到右边防止溢出</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; (Integer.MAX_VALUE - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> flag == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res * <span class="number">10</span> + digit;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="comment">//遇到非数字字符直接截断退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode8-字符串转整数-atoi&quot;&gt;&lt;a href=&quot;#Leetcode8-字符串转整数-atoi&quot; class=&quot;headerlink&quot; title=&quot;Leetcode8.字符串转整数(atoi)&quot;&gt;&lt;/a&gt;Leetcode8.字符串转整数(atoi)&lt;/h2&gt;&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：&lt;/p&gt;
&lt;p&gt;如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。&lt;br&gt;假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。&lt;br&gt;该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。&lt;br&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
</feed>
